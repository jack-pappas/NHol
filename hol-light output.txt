This is a run of the gzip version of HOL-Light from http://www.cl.cam.ac.uk/~jrh13/hol-light/ which is a snapshot from 10th January 2010. 
This code is not the same as the current release on googlecode version r163.
This was run using OCaml version 3.11.2 on a Debian system.


# #use "hol.ml";;
val hol_version : string = "2.20++"
val hol_dir : string ref =
  {contents = "/home/student/OCaml/hol_light (gzip)"}
val temp_path : string ref = {contents = "/tmp"}
- : unit = ()
- : unit = ()
val use_file : string -> unit = <fun>
val hol_expand_directory : string -> string = <fun>
val load_path : string list ref = {contents = ["."; "$"]}
val loaded_files : '_a list ref = {contents = []}
val file_on_path : string list -> string -> string = <fun>
val load_on_path : string list -> string -> unit = <fun>
val loads : string -> unit = <fun>
val loadt : string -> unit = <fun>
val needs : string -> unit = <fun>
- : unit = ()
- : unit = ()
val quotexpander : string -> string = <fun>
- : unit = ()
File "/home/student/OCaml/hol_light (gzip)/sys.ml", line 31, characters 0-34:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
false
- : bool -> bool = <fun>
type num =
  Num.num =
    Int of int
  | Big_int of Big_int.big_int
  | Ratio of Ratio.ratio
val ( +/ ) : num -> num -> num = <fun>
val add_num : num -> num -> num = <fun>
val minus_num : num -> num = <fun>
val ( -/ ) : num -> num -> num = <fun>
val sub_num : num -> num -> num = <fun>
val ( */ ) : num -> num -> num = <fun>
val mult_num : num -> num -> num = <fun>
val square_num : num -> num = <fun>
val ( // ) : num -> num -> num = <fun>
val div_num : num -> num -> num = <fun>
val quo_num : num -> num -> num = <fun>
val mod_num : num -> num -> num = <fun>
val ( **/ ) : num -> num -> num = <fun>
val power_num : num -> num -> num = <fun>
val abs_num : num -> num = <fun>
val succ_num : num -> num = <fun>
val pred_num : num -> num = <fun>
val incr_num : num ref -> unit = <fun>
val decr_num : num ref -> unit = <fun>
val is_integer_num : num -> bool = <fun>
val integer_num : num -> num = <fun>
val floor_num : num -> num = <fun>
val round_num : num -> num = <fun>
val ceiling_num : num -> num = <fun>
val sign_num : num -> int = <fun>
val ( =/ ) : num -> num -> bool = <fun>
val ( </ ) : num -> num -> bool = <fun>
val ( >/ ) : num -> num -> bool = <fun>
val ( <=/ ) : num -> num -> bool = <fun>
val ( >=/ ) : num -> num -> bool = <fun>
val ( <>/ ) : num -> num -> bool = <fun>
val eq_num : num -> num -> bool = <fun>
val lt_num : num -> num -> bool = <fun>
val le_num : num -> num -> bool = <fun>
val gt_num : num -> num -> bool = <fun>
val ge_num : num -> num -> bool = <fun>
val compare_num : num -> num -> int = <fun>
val max_num : num -> num -> num = <fun>
val min_num : num -> num -> num = <fun>
val string_of_num : num -> string = <fun>
val approx_num_fix : int -> num -> string = <fun>
val approx_num_exp : int -> num -> string = <fun>
val num_of_string : string -> num = <fun>
val int_of_num : num -> int = <fun>
val num_of_int : int -> num = <fun>
val nat_of_num : num -> Nat.nat = <fun>
val num_of_nat : Nat.nat -> num = <fun>
val num_of_big_int : Big_int.big_int -> num = <fun>
val big_int_of_num : num -> Big_int.big_int = <fun>
val ratio_of_num : num -> Ratio.ratio = <fun>
val num_of_ratio : Ratio.ratio -> num = <fun>
val float_of_num : num -> float = <fun>
val print_num : num -> unit = <fun>
- : unit = ()
val fail : unit -> 'a = <fun>
val curry : ('a * 'b -> 'c) -> 'a -> 'b -> 'c = <fun>
val uncurry : ('a -> 'b -> 'c) -> 'a * 'b -> 'c = <fun>
val ( I ) : 'a -> 'a = <fun>
val ( K ) : 'a -> 'b -> 'a = <fun>
val ( C ) : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c = <fun>
val ( W ) : ('a -> 'a -> 'b) -> 'a -> 'b = <fun>
val o : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
val f_f_ : ('a -> 'b) -> ('c -> 'd) -> 'a * 'c -> 'b * 'd = <fun>
val hd : 'a list -> 'a = <fun>
val tl : 'a list -> 'a list = <fun>
val map : ('a -> 'b) -> 'a list -> 'b list = <fun>
val last : 'a list -> 'a = <fun>
val butlast : 'a list -> 'a list = <fun>
val el : int -> 'a list -> 'a = <fun>
val rev : 'a list -> 'a list = <fun>
val map2 : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list = <fun>
val can : ('a -> 'b) -> 'a -> bool = <fun>
val check : ('a -> bool) -> 'a -> 'a = <fun>
val funpow : int -> ('a -> 'a) -> 'a -> 'a = <fun>
val repeat : ('a -> 'a) -> 'a -> 'a = <fun>
exception Unchanged
val itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>
val rev_itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>
val end_itlist : ('a -> 'a -> 'a) -> 'a list -> 'a = <fun>
val itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c =
  <fun>
val rev_itlist2 : ('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> 'c -> 'c =
  <fun>
val splitlist : ('a -> 'b * 'a) -> 'a -> 'b list * 'a = <fun>
val rev_splitlist : ('a -> 'a * 'b) -> 'a -> 'a * 'b list = <fun>
val striplist : ('a -> 'a * 'a) -> 'a -> 'a list = <fun>
val nsplit : ('a -> 'b * 'a) -> 'c list -> 'a -> 'b list * 'a = <fun>
val replicate : 'a -> int -> 'a list = <fun>
val ( -- ) : int -> int -> int list = <fun>
val forall : ('a -> bool) -> 'a list -> bool = <fun>
val forall2 : ('a -> 'b -> bool) -> 'a list -> 'b list -> bool = <fun>
val exists : ('a -> bool) -> 'a list -> bool = <fun>
val length : 'a list -> int = <fun>
val filter : ('a -> bool) -> 'a list -> 'a list = <fun>
val partition : ('a -> bool) -> 'a list -> 'a list * 'a list = <fun>
val mapfilter : ('a -> 'b) -> 'a list -> 'b list = <fun>
val find : ('a -> bool) -> 'a list -> 'a = <fun>
val tryfind : ('a -> 'b) -> 'a list -> 'b = <fun>
val flat : 'a list list -> 'a list = <fun>
val remove : ('a -> bool) -> 'a list -> 'a * 'a list = <fun>
val chop_list : int -> 'a list -> 'a list * 'a list = <fun>
val index : 'a -> 'a list -> int = <fun>
val mem : 'a -> 'a list -> bool = <fun>
val insert : 'a -> 'a list -> 'a list = <fun>
val union : 'a list -> 'a list -> 'a list = <fun>
val unions : 'a list list -> 'a list = <fun>
val intersect : 'a list -> 'a list -> 'a list = <fun>
val subtract : 'a list -> 'a list -> 'a list = <fun>
val subset : 'a list -> 'a list -> bool = <fun>
val set_eq : 'a list -> 'a list -> bool = <fun>
val assoc : 'a -> ('a * 'b) list -> 'b = <fun>
val rev_assoc : 'a -> ('b * 'a) list -> 'b = <fun>
val zip : 'a list -> 'b list -> ('a * 'b) list = <fun>
val unzip : ('a * 'b) list -> 'a list * 'b list = <fun>
val shareout : 'a list list -> 'b list -> 'b list list = <fun>
val do_list : ('a -> 'b) -> 'a list -> unit = <fun>
val sort : ('a -> 'a -> bool) -> 'a list -> 'a list = <fun>
val uniq : 'a list -> 'a list = <fun>
val setify : 'a list -> 'a list = <fun>
val implode : string list -> string = <fun>
val explode : string -> string list = <fun>
val gcd : int -> int -> int = <fun>
val num_0 : num = 0
val num_1 : num = 1
val num_2 : num = 2
val num_10 : num = 10
val pow2 : int -> num = <fun>
val pow10 : int -> num = <fun>
val numdom : num -> num * num = <fun>
val numerator : num -> num = <fun>
val denominator : num -> num = <fun>
val gcd_num : num -> num -> num = <fun>
val lcm_num : num -> num -> num = <fun>
val allpairs : ('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list = <fun>
val report : string -> unit = <fun>
val warn : bool -> string -> unit = <fun>
val verbose : bool ref = {contents = true}
val report_timing : bool ref = {contents = true}
val remark : string -> unit = <fun>
val time : ('a -> 'b) -> 'a -> 'b = <fun>
val assocd : 'a -> ('a * 'b) list -> 'b -> 'b = <fun>
val rev_assocd : 'a -> ('b * 'a) list -> 'b -> 'b = <fun>
val qmap : ('a -> 'a) -> 'a list -> 'a list = <fun>
val merge : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list = <fun>
val mergesort : ('a -> 'a -> bool) -> 'a list -> 'a list = <fun>
val increasing : ('a -> 'b) -> 'a -> 'a -> bool = <fun>
val decreasing : ('a -> 'b) -> 'a -> 'a -> bool = <fun>
type ('a, 'b) func =
    Empty
  | Leaf of int * ('a * 'b) list
  | Branch of int * int * ('a, 'b) func * ('a, 'b) func
val undefined : ('a, 'b) func = Empty
val is_undefined : ('a, 'b) func -> bool = <fun>
val mapf : ('a -> 'b) -> ('c, 'a) func -> ('c, 'b) func = <fun>
val foldl : ('a -> 'b -> 'c -> 'a) -> 'a -> ('b, 'c) func -> 'a = <fun>
val foldr : ('a -> 'b -> 'c -> 'c) -> ('a, 'b) func -> 'c -> 'c = <fun>
val graph : ('a, 'b) func -> ('a * 'b) list = <fun>
val dom : ('a, 'b) func -> 'a list = <fun>
val ran : ('a, 'b) func -> 'b list = <fun>
val applyd : ('a, 'b) func -> ('a -> 'b) -> 'a -> 'b = <fun>
val apply : ('a, 'b) func -> 'a -> 'b = <fun>
val tryapplyd : ('a, 'b) func -> 'a -> 'b -> 'b = <fun>
val defined : ('a, 'b) func -> 'a -> bool = <fun>
val undefine : 'a -> ('a, 'b) func -> ('a, 'b) func = <fun>
val ( |-> ) : 'a -> 'b -> ('a, 'b) func -> ('a, 'b) func = <fun>
val combine :
  ('a -> 'a -> 'a) ->
  ('a -> bool) -> ('b, 'a) func -> ('b, 'a) func -> ('b, 'a) func = <fun>
val ( |=> ) : 'a -> 'b -> ('a, 'b) func = <fun>
val choose : ('a, 'b) func -> 'a * 'b = <fun>
val print_fpf : ('a, 'b) func -> unit = <fun>
val mem' : ('a -> 'b -> bool) -> 'a -> 'b list -> bool = <fun>
val insert' : ('a -> 'a -> bool) -> 'a -> 'a list -> 'a list = <fun>
val union' : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list = <fun>
val unions' : ('a -> 'a -> bool) -> 'a list list -> 'a list = <fun>
val subtract' : ('a -> 'b -> bool) -> 'a list -> 'b list -> 'a list = <fun>
val num_of_string : string -> num = <fun>
val strings_of_file : string -> string list = <fun>
val string_of_file : string -> string = <fun>
val file_of_string : string -> string -> unit = <fun>
- : unit = ()
module type Hol_kernel =
  sig
    type hol_type = private Tyvar of string | Tyapp of string * hol_type list
    type term = private
        Var of string * hol_type
      | Const of string * hol_type
      | Comb of term * term
      | Abs of term * term
    type thm
    val types : unit -> (string * int) list
    val get_type_arity : string -> int
    val new_type : string * int -> unit
    val mk_type : string * hol_type list -> hol_type
    val mk_vartype : string -> hol_type
    val dest_type : hol_type -> string * hol_type list
    val dest_vartype : hol_type -> string
    val is_type : hol_type -> bool
    val is_vartype : hol_type -> bool
    val tyvars : hol_type -> hol_type list
    val type_subst : (hol_type * hol_type) list -> hol_type -> hol_type
    val bool_ty : hol_type
    val aty : hol_type
    val constants : unit -> (string * hol_type) list
    val get_const_type : string -> hol_type
    val new_constant : string * hol_type -> unit
    val type_of : term -> hol_type
    val alphaorder : term -> term -> int
    val is_var : term -> bool
    val is_const : term -> bool
    val is_abs : term -> bool
    val is_comb : term -> bool
    val mk_var : string * hol_type -> term
    val mk_const : string * (hol_type * hol_type) list -> term
    val mk_abs : term * term -> term
    val mk_comb : term * term -> term
    val dest_var : term -> string * hol_type
    val dest_const : term -> string * hol_type
    val dest_comb : term -> term * term
    val dest_abs : term -> term * term
    val frees : term -> term list
    val freesl : term list -> term list
    val freesin : term list -> term -> bool
    val vfree_in : term -> term -> bool
    val type_vars_in_term : term -> hol_type list
    val variant : term list -> term -> term
    val vsubst : (term * term) list -> term -> term
    val inst : (hol_type * hol_type) list -> term -> term
    val rand : term -> term
    val rator : term -> term
    val dest_eq : term -> term * term
    val dest_thm : thm -> term list * term
    val hyp : thm -> term list
    val concl : thm -> term
    val ( REFL ) : term -> thm
    val ( TRANS ) : thm -> thm -> thm
    val ( MK_COMB ) : thm * thm -> thm
    val ( ABS ) : term -> thm -> thm
    val ( BETA ) : term -> thm
    val ( ASSUME ) : term -> thm
    val ( EQ_MP ) : thm -> thm -> thm
    val ( DEDUCT_ANTISYM_RULE ) : thm -> thm -> thm
    val ( INST_TYPE ) : (hol_type * hol_type) list -> thm -> thm
    val ( INST ) : (term * term) list -> thm -> thm
    val axioms : unit -> thm list
    val new_axiom : term -> thm
    val definitions : unit -> thm list
    val new_basic_definition : term -> thm
    val new_basic_type_definition :
      string -> string * string -> thm -> thm * thm
  end
File "/home/student/OCaml/hol_light (gzip)/fusion.ml", line 432, characters 7-18:
Warning Y: unused variable tp.
File "/home/student/OCaml/hol_light (gzip)/fusion.ml", line 588, characters 30-48:
Warning Y: unused variable l.
File "/home/student/OCaml/hol_light (gzip)/fusion.ml", line 233, characters 4-170:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Abs ((Abs (_, _)|Comb (_, _)|Const (_, _)), _)
File "/home/student/OCaml/hol_light (gzip)/fusion.ml", line 328, characters 4-231:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Abs ((Abs (_, _)|Comb (_, _)|Const (_, _)), _)
File "/home/student/OCaml/hol_light (gzip)/fusion.ml", line 440, characters 4-551:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Abs ((Abs (_, _)|Comb (_, _)|Const (_, _)), _), Abs (_, _))
module Hol : Hol_kernel
type hol_type =
  Hol.hol_type = private
    Tyvar of string
  | Tyapp of string * hol_type list
type term =
  Hol.term = private
    Var of string * hol_type
  | Const of string * hol_type
  | Comb of term * term
  | Abs of term * term
type thm = Hol.thm
val types : unit -> (string * int) list = <fun>
val get_type_arity : string -> int = <fun>
val new_type : string * int -> unit = <fun>
val mk_type : string * hol_type list -> hol_type = <fun>
val mk_vartype : string -> hol_type = <fun>
val dest_type : hol_type -> string * hol_type list = <fun>
val dest_vartype : hol_type -> string = <fun>
val is_type : hol_type -> bool = <fun>
val is_vartype : hol_type -> bool = <fun>
val tyvars : hol_type -> hol_type list = <fun>
val type_subst : (hol_type * hol_type) list -> hol_type -> hol_type = <fun>
val bool_ty : hol_type = Tyapp ("bool", [])
val aty : hol_type = Tyvar "A"
val constants : unit -> (string * hol_type) list = <fun>
val get_const_type : string -> hol_type = <fun>
val new_constant : string * hol_type -> unit = <fun>
val type_of : term -> hol_type = <fun>
val alphaorder : term -> term -> int = <fun>
val is_var : term -> bool = <fun>
val is_const : term -> bool = <fun>
val is_abs : term -> bool = <fun>
val is_comb : term -> bool = <fun>
val mk_var : string * hol_type -> term = <fun>
val mk_const : string * (hol_type * hol_type) list -> term = <fun>
val mk_abs : term * term -> term = <fun>
val mk_comb : term * term -> term = <fun>
val dest_var : term -> string * hol_type = <fun>
val dest_const : term -> string * hol_type = <fun>
val dest_comb : term -> term * term = <fun>
val dest_abs : term -> term * term = <fun>
val frees : term -> term list = <fun>
val freesl : term list -> term list = <fun>
val freesin : term list -> term -> bool = <fun>
val vfree_in : term -> term -> bool = <fun>
val type_vars_in_term : term -> hol_type list = <fun>
val variant : term list -> term -> term = <fun>
val vsubst : (term * term) list -> term -> term = <fun>
val inst : (hol_type * hol_type) list -> term -> term = <fun>
val rand : term -> term = <fun>
val rator : term -> term = <fun>
val dest_eq : term -> term * term = <fun>
val dest_thm : thm -> term list * term = <fun>
val hyp : thm -> term list = <fun>
val concl : thm -> term = <fun>
val ( REFL ) : term -> thm = <fun>
val ( TRANS ) : thm -> thm -> thm = <fun>
val ( MK_COMB ) : thm * thm -> thm = <fun>
val ( ABS ) : term -> thm -> thm = <fun>
val ( BETA ) : term -> thm = <fun>
val ( ASSUME ) : term -> thm = <fun>
val ( EQ_MP ) : thm -> thm -> thm = <fun>
val ( DEDUCT_ANTISYM_RULE ) : thm -> thm -> thm = <fun>
val ( INST_TYPE ) : (hol_type * hol_type) list -> thm -> thm = <fun>
val ( INST ) : (term * term) list -> thm -> thm = <fun>
val axioms : unit -> thm list = <fun>
val new_axiom : term -> thm = <fun>
val definitions : unit -> thm list = <fun>
val new_basic_definition : term -> thm = <fun>
val new_basic_type_definition : string -> string * string -> thm -> thm * thm =
  <fun>
val mk_fun_ty : hol_type -> hol_type -> hol_type = <fun>
val bty : hol_type = Tyvar "B"
val is_eq : term -> bool = <fun>
val mk_eq : term * term -> term = <fun>
val aconv : term -> term -> bool = <fun>
val equals_thm : thm -> thm -> bool = <fun>
- : unit = ()
val genvar : hol_type -> term = <fun>
val dest_fun_ty : hol_type -> hol_type * hol_type = <fun>
val occurs_in : hol_type -> hol_type -> bool = <fun>
val tysubst : (hol_type * hol_type) list -> hol_type -> hol_type = <fun>
val bndvar : term -> term = <fun>
val body : term -> term = <fun>
val list_mk_comb : term * term list -> term = <fun>
val list_mk_abs : term list * term -> term = <fun>
val strip_comb : term -> term * term list = <fun>
val strip_abs : term -> term list * term = <fun>
val is_binary : string -> term -> bool = <fun>
val dest_binary : string -> term -> term * term = <fun>
val mk_binary : string -> term * term -> term = <fun>
val variants : term list -> term list -> term list = <fun>
val variables : term -> term list = <fun>
val subst : (term * term) list -> term -> term = <fun>
val alpha : term -> term -> term = <fun>
val type_match :
  hol_type ->
  hol_type -> (hol_type * hol_type) list -> (hol_type * hol_type) list =
  <fun>
val mk_mconst : string * hol_type -> term = <fun>
File "/home/student/OCaml/hol_light (gzip)/basics.ml", line 163, characters 6-18:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
("", _)
val mk_icomb : term * term -> term = <fun>
val list_mk_icomb : string -> term list -> term = <fun>
val thm_frees : thm -> term list = <fun>
val free_in : term -> term -> bool = <fun>
val find_term : (term -> bool) -> term -> term = <fun>
val find_terms : (term -> bool) -> term -> term list = <fun>
val is_binder : string -> term -> bool = <fun>
val dest_binder : string -> term -> term * term = <fun>
val mk_binder : string -> term * term -> term = <fun>
val is_binop : term -> term -> bool = <fun>
val dest_binop : term -> term -> term * term = <fun>
val mk_binop : term -> term -> term -> term = <fun>
val list_mk_binop : term -> term list -> term = <fun>
val binops : term -> term -> term list = <fun>
val is_conj : term -> bool = <fun>
val dest_conj : term -> term * term = <fun>
val conjuncts : term -> term list = <fun>
val is_imp : term -> bool = <fun>
val dest_imp : term -> term * term = <fun>
val is_forall : term -> bool = <fun>
val dest_forall : term -> term * term = <fun>
val strip_forall : term -> term list * term = <fun>
val is_exists : term -> bool = <fun>
val dest_exists : term -> term * term = <fun>
val strip_exists : term -> term list * term = <fun>
val is_disj : term -> bool = <fun>
val dest_disj : term -> term * term = <fun>
val disjuncts : term -> term list = <fun>
val is_neg : term -> bool = <fun>
val dest_neg : term -> term = <fun>
val is_uexists : term -> bool = <fun>
val dest_uexists : term -> term * term = <fun>
val dest_cons : term -> term * term = <fun>
val is_cons : term -> bool = <fun>
val dest_list : term -> term list = <fun>
val is_list : term -> bool = <fun>
val dest_numeral : term -> num = <fun>
val dest_gabs : term -> term * term = <fun>
val is_gabs : term -> bool = <fun>
val mk_gabs : term * term -> term = <fun>
val list_mk_gabs : term list * term -> term = <fun>
val strip_gabs : term -> term list * term = <fun>
val dest_let : term -> (term * term) list * term = <fun>
val is_let : term -> bool = <fun>
val mk_let : (term * term) list * term -> term = <fun>
val make_args : string -> term list -> hol_type list -> term list = <fun>
val find_path : (term -> bool) -> term -> string = <fun>
val follow_path : string -> term -> term = <fun>
- : unit = ()
type term_label =
    Vnet
  | Lcnet of (string * int)
  | Cnet of (string * int)
  | Lnet of int
type 'a net = Netnode of (term_label * 'a net) list * 'a list
val empty_net : 'a net = Netnode ([], [])
val enter : term list -> term * 'a -> 'a net -> 'a net = <fun>
val lookup : term -> 'a net -> 'a list = <fun>
val merge_nets : 'a net * 'a net -> 'a net = <fun>
- : unit = ()
val isspace : string -> bool = <fun>
val issep : string -> bool = <fun>
val isbra : string -> bool = <fun>
val issymb : string -> bool = <fun>
val isalpha : string -> bool = <fun>
val isnum : string -> bool = <fun>
val isalnum : string -> bool = <fun>
val ignore_constant_varstruct : bool ref = {contents = true}
val type_invention_warning : bool ref = {contents = true}
val the_interface : (string * (string * hol_type)) list ref = {contents = []}
val the_overload_skeletons : (string * hol_type) list ref = {contents = []}
val make_overloadable : string -> hol_type -> unit = <fun>
val remove_interface : string -> unit = <fun>
val reduce_interface : string * term -> unit = <fun>
val override_interface : string * term -> unit = <fun>
val overload_interface : string * term -> unit = <fun>
val prioritize_overload : hol_type -> unit = <fun>
val new_type_abbrev : string * hol_type -> unit = <fun>
val remove_type_abbrev : string -> unit = <fun>
val type_abbrevs : unit -> (string * hol_type) list = <fun>
val hide_constant : string -> unit = <fun>
val unhide_constant : string -> unit = <fun>
val is_hidden : string -> bool = <fun>
type pretype = Utv of string | Ptycon of string * pretype list | Stv of int
val dpty : pretype = Ptycon ("", [])
val pretype_of_type : hol_type -> pretype = <fun>
type preterm =
    Varp of string * pretype
  | Constp of string * pretype
  | Combp of preterm * preterm
  | Absp of preterm * preterm
  | Typing of preterm * pretype
val preterm_of_term : term -> preterm = <fun>
File "/home/student/OCaml/hol_light (gzip)/preterm.ml", line 300, characters 4-430:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Typing (_, _)
File "/home/student/OCaml/hol_light (gzip)/preterm.ml", line 325, characters 4-493:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Typing (_, _)
val type_of_pretype : pretype -> hol_type = <fun>
val term_of_preterm : preterm -> term = <fun>
val retypecheck : (string * pretype) list -> preterm -> preterm = <fun>
- : unit = ()
val reserve_words : string list -> unit = <fun>
val unreserve_words : string list -> unit = <fun>
val is_reserved_word : string -> bool = <fun>
val reserved_words : unit -> string list = <fun>
val unparse_as_binder : string -> unit = <fun>
val parse_as_binder : string -> unit = <fun>
val parses_as_binder : string -> bool = <fun>
val binders : unit -> string list = <fun>
val unparse_as_prefix : string -> unit = <fun>
val parse_as_prefix : string -> unit = <fun>
val is_prefix : string -> bool = <fun>
val prefixes : unit -> string list = <fun>
val unparse_as_infix : string -> unit = <fun>
val parse_as_infix : string * (int * string) -> unit = <fun>
val get_infix_status : string -> int * string = <fun>
val infixes : unit -> (string * (int * string)) list = <fun>
- : unit = ()
exception Noparse
val ( || ) : ('a -> 'b) -> ('a -> 'b) -> 'a -> 'b = <fun>
val ( ++ ) : ('a -> 'b * 'c) -> ('c -> 'd * 'e) -> 'a -> ('b * 'd) * 'e =
  <fun>
val many : ('a -> 'b * 'a) -> 'a -> 'b list * 'a = <fun>
val ( >> ) : ('a -> 'b * 'c) -> ('b -> 'd) -> 'a -> 'd * 'c = <fun>
val fix : string -> ('a -> 'b) -> 'a -> 'b = <fun>
val listof :
  ('a -> 'b * 'c) -> ('c -> 'd * 'a) -> string -> 'a -> 'b list * 'c = <fun>
val nothing : 'a -> 'b list * 'a = <fun>
val elistof :
  ('a -> 'b * 'a) -> ('a -> 'c * 'a) -> string -> 'a -> 'b list * 'a = <fun>
val leftbin :
  ('a -> 'b * 'c) ->
  ('c -> 'd * 'a) -> ('d -> 'b -> 'b -> 'b) -> string -> 'a -> 'b * 'c =
  <fun>
val rightbin :
  ('a -> 'b * 'c) ->
  ('c -> 'd * 'a) -> ('d -> 'b -> 'b -> 'b) -> string -> 'a -> 'b * 'c =
  <fun>
val possibly : ('a -> 'b * 'a) -> 'a -> 'b list * 'a = <fun>
val some : ('a -> bool) -> 'a list -> 'a * 'a list = <fun>
val a : 'a -> 'a list -> 'a * 'a list = <fun>
val atleast : int -> ('a -> 'b * 'a) -> 'a -> 'b list * 'a = <fun>
val finished : 'a list -> int * 'a list = <fun>
type lexcode = Ident of string | Resword of string
- : unit = ()
val comment_token : lexcode ref = {contents = Resword "//"}
val lex : string list -> lexcode list = <fun>
val parse_pretype : lexcode list -> pretype * lexcode list = <fun>
val install_parser :
  string * (lexcode list -> preterm * lexcode list) -> unit = <fun>
val delete_parser : string -> unit = <fun>
val installed_parsers :
  unit -> (string * (lexcode list -> preterm * lexcode list)) list = <fun>
val try_user_parser : lexcode list -> preterm * lexcode list = <fun>
File "/home/student/OCaml/hol_light (gzip)/parser.ml", line 322, characters 15-60:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Typing (_, _)|Absp (_, _)|Constp (_, _)|Varp (_, _))
File "/home/student/OCaml/hol_light (gzip)/parser.ml", line 375, characters 11-64:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
Resword _
val parse_preterm : lexcode list -> preterm * lexcode list = <fun>
val parse_type : string -> hol_type = <fun>
val parse_term : string -> term = <fun>
- : unit = ()
val open_box : int -> unit = <fun>
val close_box : unit -> unit = <fun>
val print_string : string -> unit = <fun>
val print_as : int -> string -> unit = <fun>
val print_int : int -> unit = <fun>
val print_float : float -> unit = <fun>
val print_char : char -> unit = <fun>
val print_bool : bool -> unit = <fun>
val print_space : unit -> unit = <fun>
val print_cut : unit -> unit = <fun>
val print_break : int -> int -> unit = <fun>
val print_flush : unit -> unit = <fun>
val print_newline : unit -> unit = <fun>
val force_newline : unit -> unit = <fun>
val print_if_newline : unit -> unit = <fun>
val set_margin : int -> unit = <fun>
val get_margin : unit -> int = <fun>
val set_max_indent : int -> unit = <fun>
val get_max_indent : unit -> int = <fun>
val set_max_boxes : int -> unit = <fun>
val get_max_boxes : unit -> int = <fun>
val over_max_boxes : unit -> bool = <fun>
val open_hbox : unit -> unit = <fun>
val open_vbox : int -> unit = <fun>
val open_hvbox : int -> unit = <fun>
val open_hovbox : int -> unit = <fun>
val open_tbox : unit -> unit = <fun>
val close_tbox : unit -> unit = <fun>
val print_tbreak : int -> int -> unit = <fun>
val set_tab : unit -> unit = <fun>
val print_tab : unit -> unit = <fun>
val set_ellipsis_text : string -> unit = <fun>
val get_ellipsis_text : unit -> string = <fun>
type tag = string
val open_tag : tag -> unit = <fun>
val close_tag : unit -> unit = <fun>
val set_tags : bool -> unit = <fun>
val set_print_tags : bool -> unit = <fun>
val set_mark_tags : bool -> unit = <fun>
val get_print_tags : unit -> bool = <fun>
val get_mark_tags : unit -> bool = <fun>
val set_formatter_out_channel : out_channel -> unit = <fun>
val set_formatter_output_functions :
  (string -> int -> int -> unit) -> (unit -> unit) -> unit = <fun>
val get_formatter_output_functions :
  unit -> (string -> int -> int -> unit) * (unit -> unit) = <fun>
val set_all_formatter_output_functions :
  out:(string -> int -> int -> unit) ->
  flush:(unit -> unit) ->
  newline:(unit -> unit) -> spaces:(int -> unit) -> unit = <fun>
val get_all_formatter_output_functions :
  unit ->
  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
  (int -> unit) = <fun>
type formatter_tag_functions =
  Format.formatter_tag_functions = {
  mark_open_tag : tag -> string;
  mark_close_tag : tag -> string;
  print_open_tag : tag -> unit;
  print_close_tag : tag -> unit;
}
val set_formatter_tag_functions : formatter_tag_functions -> unit = <fun>
val get_formatter_tag_functions : unit -> formatter_tag_functions = <fun>
type formatter = Format.formatter
val formatter_of_out_channel : out_channel -> formatter = <fun>
val std_formatter : formatter = <abstr>
val err_formatter : formatter = <abstr>
val formatter_of_buffer : Buffer.t -> formatter = <fun>
val stdbuf : Buffer.t = <abstr>
val str_formatter : formatter = <abstr>
val flush_str_formatter : unit -> string = <fun>
val make_formatter :
  (string -> int -> int -> unit) -> (unit -> unit) -> formatter = <fun>
val pp_open_hbox : formatter -> unit -> unit = <fun>
val pp_open_vbox : formatter -> int -> unit = <fun>
val pp_open_hvbox : formatter -> int -> unit = <fun>
val pp_open_hovbox : formatter -> int -> unit = <fun>
val pp_open_box : formatter -> int -> unit = <fun>
val pp_close_box : formatter -> unit -> unit = <fun>
val pp_open_tag : formatter -> string -> unit = <fun>
val pp_close_tag : formatter -> unit -> unit = <fun>
val pp_print_string : formatter -> string -> unit = <fun>
val pp_print_as : formatter -> int -> string -> unit = <fun>
val pp_print_int : formatter -> int -> unit = <fun>
val pp_print_float : formatter -> float -> unit = <fun>
val pp_print_char : formatter -> char -> unit = <fun>
val pp_print_bool : formatter -> bool -> unit = <fun>
val pp_print_break : formatter -> int -> int -> unit = <fun>
val pp_print_cut : formatter -> unit -> unit = <fun>
val pp_print_space : formatter -> unit -> unit = <fun>
val pp_force_newline : formatter -> unit -> unit = <fun>
val pp_print_flush : formatter -> unit -> unit = <fun>
val pp_print_newline : formatter -> unit -> unit = <fun>
val pp_print_if_newline : formatter -> unit -> unit = <fun>
val pp_open_tbox : formatter -> unit -> unit = <fun>
val pp_close_tbox : formatter -> unit -> unit = <fun>
val pp_print_tbreak : formatter -> int -> int -> unit = <fun>
val pp_set_tab : formatter -> unit -> unit = <fun>
val pp_print_tab : formatter -> unit -> unit = <fun>
val pp_set_tags : formatter -> bool -> unit = <fun>
val pp_set_print_tags : formatter -> bool -> unit = <fun>
val pp_set_mark_tags : formatter -> bool -> unit = <fun>
val pp_get_print_tags : formatter -> unit -> bool = <fun>
val pp_get_mark_tags : formatter -> unit -> bool = <fun>
val pp_set_margin : formatter -> int -> unit = <fun>
val pp_get_margin : formatter -> unit -> int = <fun>
val pp_set_max_indent : formatter -> int -> unit = <fun>
val pp_get_max_indent : formatter -> unit -> int = <fun>
val pp_set_max_boxes : formatter -> int -> unit = <fun>
val pp_get_max_boxes : formatter -> unit -> int = <fun>
val pp_over_max_boxes : formatter -> unit -> bool = <fun>
val pp_set_ellipsis_text : formatter -> string -> unit = <fun>
val pp_get_ellipsis_text : formatter -> unit -> string = <fun>
val pp_set_formatter_out_channel : formatter -> out_channel -> unit = <fun>
val pp_set_formatter_output_functions :
  formatter -> (string -> int -> int -> unit) -> (unit -> unit) -> unit =
  <fun>
val pp_get_formatter_output_functions :
  formatter -> unit -> (string -> int -> int -> unit) * (unit -> unit) =
  <fun>
val pp_set_all_formatter_output_functions :
  formatter ->
  out:(string -> int -> int -> unit) ->
  flush:(unit -> unit) ->
  newline:(unit -> unit) -> spaces:(int -> unit) -> unit = <fun>
val pp_get_all_formatter_output_functions :
  formatter ->
  unit ->
  (string -> int -> int -> unit) * (unit -> unit) * (unit -> unit) *
  (int -> unit) = <fun>
val pp_set_formatter_tag_functions :
  formatter -> formatter_tag_functions -> unit = <fun>
val pp_get_formatter_tag_functions :
  formatter -> unit -> formatter_tag_functions = <fun>
val fprintf : formatter -> ('a, formatter, unit) format -> 'a = <fun>
val printf : ('a, formatter, unit) format -> 'a = <fun>
val eprintf : ('a, formatter, unit) format -> 'a = <fun>
val sprintf : ('a, unit, string) format -> 'a = <fun>
val bprintf : Buffer.t -> ('a, formatter, unit) format -> 'a = <fun>
val kfprintf :
  (formatter -> 'a) -> formatter -> ('b, formatter, unit, 'a) format4 -> 'b =
  <fun>
val ifprintf : formatter -> ('a, formatter, unit) format -> 'a = <fun>
val ksprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b = <fun>
val kprintf : (string -> 'a) -> ('b, unit, string, 'a) format4 -> 'b = <fun>
- : unit = ()
val reverse_interface_mapping : bool ref = {contents = true}
val unspaced_binops : string list ref = {contents = [","; ".."; "$"]}
val prebroken_binops : string list ref = {contents = ["==>"]}
val print_unambiguous_comprehensions : bool ref = {contents = false}
val typify_universal_set : bool ref = {contents = true}
val print_all_thm : bool ref = {contents = true}
val name_of : term -> string = <fun>
val pp_print_type : formatter -> hol_type -> unit = <fun>
val pp_print_qtype : formatter -> hol_type -> unit = <fun>
val install_user_printer : string * (term -> unit) -> unit = <fun>
val delete_user_printer : string -> unit = <fun>
val try_user_printer : term -> unit = <fun>
File "/home/student/OCaml/hol_light (gzip)/printer.ml", line 363, characters 4-194:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/printer.ml", line 370, characters 4-313:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val pp_print_term : formatter -> term -> unit = <fun>
val pp_print_qterm : formatter -> term -> unit = <fun>
val pp_print_thm : formatter -> thm -> unit = <fun>
val print_type : hol_type -> unit = <fun>
val print_qtype : hol_type -> unit = <fun>
val print_term : term -> unit = <fun>
val print_qterm : term -> unit = <fun>
val print_thm : thm -> unit = <fun>
val print_to_string : (formatter -> 'a -> 'b) -> 'a -> string = <fun>
val string_of_type : hol_type -> string = <fun>
val string_of_term : term -> string = <fun>
val string_of_thm : thm -> string = <fun>
- : unit = ()
type conv = term -> thm
val lhand : term -> term = <fun>
val lhs : term -> term = <fun>
val rhs : term -> term = <fun>
val mk_primed_var : term list -> term -> term = <fun>
val ( BETA_CONV ) : term -> thm = <fun>
val ( AP_TERM ) : term -> thm -> thm = <fun>
val ( AP_THM ) : thm -> term -> thm = <fun>
val ( SYM ) : thm -> thm = <fun>
val ( ALPHA ) : term -> term -> thm = <fun>
val ( ALPHA_CONV ) : term -> term -> thm = <fun>
val ( GEN_ALPHA_CONV ) : term -> term -> thm = <fun>
val ( MK_BINOP ) : term -> thm * thm -> thm = <fun>
val ( NO_CONV ) : conv = <fun>
val ( ALL_CONV ) : conv = <fun>
val thenc_ : conv -> conv -> conv = <fun>
val orelsec_ : conv -> conv -> conv = <fun>
val ( FIRST_CONV ) : conv list -> conv = <fun>
val ( EVERY_CONV ) : conv list -> conv = <fun>
val ( REPEATC ) : conv -> conv = <fun>
val ( CHANGED_CONV ) : conv -> conv = <fun>
val ( TRY_CONV ) : conv -> conv = <fun>
val ( RATOR_CONV ) : conv -> conv = <fun>
val ( RAND_CONV ) : conv -> conv = <fun>
val ( LAND_CONV ) : conv -> conv = <fun>
val ( COMB2_CONV ) : conv -> conv -> conv = <fun>
val ( COMB_CONV ) : conv -> conv = <fun>
val ( ABS_CONV ) : conv -> conv = <fun>
val ( BINDER_CONV ) : conv -> term -> thm = <fun>
val ( SUB_CONV ) : conv -> term -> thm = <fun>
val ( BINOP_CONV ) : (term -> thm) -> term -> thm = <fun>
val ( ONCE_DEPTH_CONV ) : conv -> conv = <fun>
val ( DEPTH_CONV ) : conv -> conv = <fun>
val ( REDEPTH_CONV ) : conv -> conv = <fun>
val ( TOP_DEPTH_CONV ) : conv -> conv = <fun>
val ( TOP_SWEEP_CONV ) : conv -> conv = <fun>
val ( DEPTH_BINOP_CONV ) : term -> (term -> thm) -> term -> thm = <fun>
val ( PATH_CONV ) : string -> conv -> conv = <fun>
val ( PAT_CONV ) : term -> conv -> conv = <fun>
val ( SYM_CONV ) : term -> thm = <fun>
val ( CONV_RULE ) : conv -> thm -> thm = <fun>
val ( SUBS_CONV ) : thm list -> term -> thm = <fun>
val ( BETA_RULE ) : thm -> thm = <fun>
val ( GSYM ) : thm -> thm = <fun>
val ( SUBS ) : thm list -> thm -> thm = <fun>
val ( CACHE_CONV ) : (term -> thm) -> term -> thm = <fun>
- : unit = ()
- : unit = ()
- : unit list = [(); (); (); ()]
- : unit list = [(); (); ()]
- : unit = ()
- : unit = ()
- : unit = ()
val is_iff : term -> bool = <fun>
val dest_iff : term -> term * term = <fun>
val mk_iff : term * term -> term = <fun>
val ( PINST ) :
  (hol_type * hol_type) list -> (term * term) list -> thm -> thm = <fun>
val ( PROVE_HYP ) : thm -> thm -> thm = <fun>
val ( T_DEF ) : thm = |- T <=> (\p. p) = (\p. p)
val ( TRUTH ) : thm = |- T
val ( EQT_ELIM ) : thm -> thm = <fun>
val ( EQT_INTRO ) : thm -> thm = <fun>
val ( AND_DEF ) : thm = |- (/\) = (\p q. (\f. f p q) = (\f. f T T))
val mk_conj : term * term -> term = <fun>
val list_mk_conj : term list -> term = <fun>
val ( CONJ ) : thm -> thm -> thm = <fun>
val ( CONJUNCT1 ) : thm -> thm = <fun>
val ( CONJUNCT2 ) : thm -> thm = <fun>
val ( CONJ_PAIR ) : thm -> thm * thm = <fun>
val ( CONJUNCTS ) : thm -> thm list = <fun>
val ( IMP_DEF ) : thm = |- (==>) = (\p q. p /\ q <=> p)
val mk_imp : term * term -> term = <fun>
val ( MP ) : thm -> thm -> thm = <fun>
val ( DISCH ) : term -> thm -> thm = <fun>
val ( DISCH_ALL ) : thm -> thm = <fun>
val ( UNDISCH ) : thm -> thm = <fun>
val ( UNDISCH_ALL ) : thm -> thm = <fun>
val ( IMP_ANTISYM_RULE ) : thm -> thm -> thm = <fun>
val ( ADD_ASSUM ) : term -> thm -> thm = <fun>
val ( EQ_IMP_RULE ) : thm -> thm * thm = <fun>
val ( IMP_TRANS ) : thm -> thm -> thm = <fun>
val ( FORALL_DEF ) : thm = |- (!) = (\P. P = (\x. T))
val mk_forall : term * term -> term = <fun>
val list_mk_forall : term list * term -> term = <fun>
val ( SPEC ) : term -> thm -> thm = <fun>
val ( SPECL ) : term list -> thm -> thm = <fun>
val ( SPEC_VAR ) : thm -> term * thm = <fun>
val ( SPEC_ALL ) : thm -> thm = <fun>
val ( ISPEC ) : term -> thm -> thm = <fun>
val ( ISPECL ) : term list -> thm -> thm = <fun>
val ( GEN ) : term -> thm -> thm = <fun>
val ( GENL ) : term list -> thm -> thm = <fun>
val ( GEN_ALL ) : thm -> thm = <fun>
val ( EXISTS_DEF ) : thm = |- (?) = (\P. !q. (!x. P x ==> q) ==> q)
val mk_exists : term * term -> term = <fun>
val list_mk_exists : term list * term -> term = <fun>
val ( EXISTS ) : term * term -> thm -> thm = <fun>
val ( SIMPLE_EXISTS ) : term -> thm -> thm = <fun>
val ( CHOOSE ) : term * thm -> thm -> thm = <fun>
val ( SIMPLE_CHOOSE ) : term -> thm -> thm = <fun>
val ( OR_DEF ) : thm = |- (\/) = (\p q. !r. (p ==> r) ==> (q ==> r) ==> r)
val mk_disj : term * term -> term = <fun>
val list_mk_disj : term list -> term = <fun>
val ( DISJ1 ) : thm -> term -> thm = <fun>
val ( DISJ2 ) : term -> thm -> thm = <fun>
val ( DISJ_CASES ) : thm -> thm -> thm -> thm = <fun>
val ( SIMPLE_DISJ_CASES ) : thm -> thm -> thm = <fun>
val ( F_DEF ) : thm = |- F <=> (!p. p)
val ( NOT_DEF ) : thm = |- (~) = (\p. p ==> F)
val mk_neg : term -> term = <fun>
val ( NOT_ELIM ) : thm -> thm = <fun>
val ( NOT_INTRO ) : thm -> thm = <fun>
val ( EQF_INTRO ) : thm -> thm = <fun>
val ( EQF_ELIM ) : thm -> thm = <fun>
val ( CONTR ) : term -> thm -> thm = <fun>
val ( EXISTS_UNIQUE_DEF ) : thm =
  |- (?!) = (\P. (?) P /\ (!x y. P x /\ P y ==> x = y))
val mk_uexists : term * term -> term = <fun>
val ( EXISTENCE ) : thm -> thm = <fun>
- : unit = ()
type instantiation =
    (int * term) list * (term * term) list * (hol_type * hol_type) list
val mk_thm : term list * term -> thm = <fun>
val ( MK_CONJ ) : thm -> thm -> thm = <fun>
val ( MK_DISJ ) : thm -> thm -> thm = <fun>
val ( MK_FORALL ) : term -> thm -> thm = <fun>
val ( MK_EXISTS ) : term -> thm -> thm = <fun>
val ( MP_CONV ) : conv -> thm -> thm = <fun>
val ( BETAS_CONV ) : conv = <fun>
val instantiate : instantiation -> term -> term = <fun>
val ( INSTANTIATE ) : instantiation -> thm -> thm = <fun>
val ( INSTANTIATE_ALL ) : instantiation -> thm -> thm = <fun>
val term_match : term list -> term -> term -> instantiation = <fun>
val term_unify : term list -> term -> term -> instantiation = <fun>
val deep_alpha : (string * string) list -> term -> term = <fun>
val ( PART_MATCH ) : (term -> term) -> thm -> term -> thm = <fun>
val ( GEN_PART_MATCH ) : (term -> term) -> thm -> term -> thm = <fun>
val ( MATCH_MP ) : thm -> thm -> thm = <fun>
val ( HIGHER_REWRITE_CONV ) : thm list -> bool -> term -> thm = <fun>
val new_definition : term -> thm = <fun>
- : unit = ()
val null_inst : instantiation = ([], [], [])
val null_meta : term list * instantiation = ([], ([], [], []))
type goal = (string * thm) list * term
val equals_goal : goal -> goal -> bool = <fun>
type justification = instantiation -> thm list -> thm
type goalstate = (term list * instantiation) * goal list * justification
type goalstack = goalstate list
type refinement = goalstate -> goalstate
type tactic = goal -> goalstate
type thm_tactic = thm -> tactic
type thm_tactical = thm_tactic -> thm_tactic
val inst_goal : instantiation -> goal -> goal = <fun>
val compose_insts : instantiation -> instantiation -> instantiation = <fun>
val _FALSITY_ : thm = |- _FALSITY_ <=> F
val mk_fthm : term list * term -> thm = <fun>
val ( VALID ) : tactic -> tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 127, characters 24-31:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::_
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 128, characters 25-50:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::_
val then_ : tactic -> tactic -> tactic = <fun>
val thenl_ : tactic -> tactic list -> tactic = <fun>
val orelse_ : tactic -> tactic -> tactic = <fun>
val ( FAIL_TAC ) : string -> tactic = <fun>
val ( NO_TAC ) : tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 170, characters 31-41:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( ALL_TAC ) : tactic = <fun>
val ( TRY ) : tactic -> tactic = <fun>
val ( REPEAT ) : tactic -> tactic = <fun>
val ( EVERY ) : tactic list -> tactic = <fun>
val ( FIRST ) : tactic list -> tactic = <fun>
val ( MAP_EVERY ) : ('a -> tactic) -> 'a list -> tactic = <fun>
val ( MAP_FIRST ) : ('a -> tactic) -> 'a list -> tactic = <fun>
val ( CHANGED_TAC ) : tactic -> tactic = <fun>
val ( REPLICATE_TAC ) : int -> tactic -> tactic = <fun>
val then_tcl_ : thm_tactical -> thm_tactical -> thm_tactical = <fun>
val orelse_tcl_ : thm_tactical -> thm_tactical -> thm_tactical = <fun>
val ( REPEAT_TCL ) : thm_tactical -> thm_tactical = <fun>
val ( REPEAT_GTCL ) : thm_tactical -> thm_tactical = <fun>
val ( ALL_THEN ) : thm_tactical = <fun>
val ( NO_THEN ) : thm_tactical = <fun>
val ( EVERY_TCL ) : thm_tactical list -> thm_tactical = <fun>
val ( FIRST_TCL ) : thm_tactical list -> thm_tactical = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 239, characters 10-54:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( LABEL_TAC ) : string -> thm_tactic = <fun>
val ( ASSUME_TAC ) : thm_tactic = <fun>
val ( FIND_ASSUM ) : thm_tactic -> term -> tactic = <fun>
val ( POP_ASSUM ) : thm_tactic -> tactic = <fun>
val ( ASSUM_LIST ) : (thm list -> tactic) -> tactic = <fun>
val ( POP_ASSUM_LIST ) : (thm list -> tactic) -> tactic = <fun>
val ( EVERY_ASSUM ) : thm_tactic -> tactic = <fun>
val ( FIRST_ASSUM ) : thm_tactic -> tactic = <fun>
val ( RULE_ASSUM_TAC ) : (thm -> thm) -> tactic = <fun>
val ( USE_THEN ) : string -> thm_tactic -> tactic = <fun>
val ( REMOVE_THEN ) : string -> thm_tactic -> tactic = <fun>
val ( ASM ) : (thm list -> tactic) -> thm list -> tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 303, characters 25-50:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::_
val ( ACCEPT_TAC ) : thm_tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 325, characters 28-68:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( CONV_TAC ) : conv -> tactic = <fun>
val ( REFL_TAC ) : tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 344, characters 14-113:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( ABS_TAC ) : tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 354, characters 14-43:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( MK_COMB_TAC ) : tactic = <fun>
val ( AP_TERM_TAC ) : tactic = <fun>
val ( AP_THM_TAC ) : tactic = <fun>
val ( BINOP_TAC ) : tactic = <fun>
val ( SUBST1_TAC ) : thm_tactic = <fun>
val ( SUBST_ALL_TAC ) : thm -> tactic = <fun>
val ( BETA_TAC ) : tactic = <fun>
val ( SUBST_VAR_TAC ) : thm -> tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 403, characters 14-50:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 408, characters 14-61:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( DISCH_TAC ) : tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 414, characters 10-47:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( MP_TAC ) : thm_tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 420, characters 14-52:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( EQ_TAC ) : tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 428, characters 13-50:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( UNDISCH_TAC ) : term -> tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 434, characters 14-47:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( SPEC_TAC ) : term * term -> tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 446, characters 16-39:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( X_GEN_TAC ) : term -> tactic = <fun>
val ( GEN_TAC ) : tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 461, characters 14-65:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( EXISTS_TAC ) : term -> tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 475, characters 16-59:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( X_CHOOSE_TAC ) : term -> thm_tactic = <fun>
val ( CHOOSE_TAC ) : thm_tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 491, characters 39-64:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( CONJ_TAC ) : tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 497, characters 32-66:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( DISJ1_TAC ) : tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 503, characters 34-68:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( DISJ2_TAC ) : tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 514, characters 16-71:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( DISJ_CASES_TAC ) : thm_tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 518, characters 25-50:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::_
val ( CONTR_TAC ) : thm_tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 525, characters 25-50:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::_
val ( MATCH_ACCEPT_TAC ) : thm_tactic = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 550, characters 29-66:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( MATCH_MP_TAC ) : thm_tactic = <fun>
val ( CONJUNCTS_THEN2 ) : thm_tactic -> thm_tactic -> thm_tactic = <fun>
val ( CONJUNCTS_THEN ) : thm_tactical = <fun>
val ( DISJ_CASES_THEN2 ) : thm_tactic -> thm_tactic -> thm_tactic = <fun>
val ( DISJ_CASES_THEN ) : thm_tactical = <fun>
val ( DISCH_THEN ) : thm_tactic -> tactic = <fun>
val ( X_CHOOSE_THEN ) : term -> thm_tactical = <fun>
val ( CHOOSE_THEN ) : thm_tactical = <fun>
val ( STRIP_THM_THEN ) : thm_tactical = <fun>
val ( ANTE_RES_THEN ) : thm_tactical = <fun>
val ( IMP_RES_THEN ) : thm_tactical = <fun>
val ( STRIP_ASSUME_TAC ) : thm_tactic = <fun>
val ( STRUCT_CASES_TAC ) : thm_tactic = <fun>
val ( STRIP_GOAL_THEN ) : thm_tactic -> tactic = <fun>
val ( STRIP_TAC ) : tactic = <fun>
val ( UNDISCH_THEN ) : term -> thm_tactic -> tactic = <fun>
val ( FIRST_X_ASSUM ) : thm_tactic -> tactic = <fun>
val ( SUBGOAL_THEN ) : term -> thm_tactic -> tactic = <fun>
val ( SUBGOAL_TAC ) : string -> term -> tactic list -> tactic = <fun>
val ( FREEZE_THEN ) : thm_tactical = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 666, characters 14-65:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( X_META_EXISTS_TAC ) : term -> tactic = <fun>
val ( META_EXISTS_TAC ) : (string * thm) list * term -> goalstate = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 679, characters 10-59:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( META_SPEC_TAC ) : term -> thm -> tactic = <fun>
val ( CHEAT_TAC ) : tactic = <fun>
val ( RECALL_ACCEPT_TAC ) : ('a -> thm) -> 'a -> goal -> goalstate = <fun>
val ( ANTS_TAC ) : tactic = <fun>
val print_goal : goal -> unit = <fun>
val print_goalstack : goalstack -> unit = <fun>
val by : tactic -> refinement = <fun>
val rotate : int -> refinement = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 805, characters 16-47:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val mk_goalstate : goal -> goalstate = <fun>
val ( TAC_PROOF ) : goal * tactic -> thm = <fun>
val prove : term * tactic -> thm = <fun>
val current_goalstack : goalstack ref = {contents = []}
val refine : refinement -> goalstack = <fun>
val flush_goalstack : unit -> unit = <fun>
val e : tactic -> goalstack = <fun>
val r : int -> goalstack = <fun>
val set_goal : term list * term -> goalstack = <fun>
val g : term -> goalstack = <fun>
val b : unit -> goalstack = <fun>
val p : unit -> goalstack = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 868, characters 6-27:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val top_realgoal : unit -> (string * thm) list * term = <fun>
val top_goal : unit -> term list * term = <fun>
File "/home/student/OCaml/hol_light (gzip)/tactics.ml", line 876, characters 6-17:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val top_thm : unit -> thm = <fun>
- : unit = ()
File "/home/student/OCaml/hol_light (gzip)/itab.ml", line 14, characters 8-31:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
_::_
val ( UNIFY_ACCEPT_TAC ) :
  term list ->
  thm ->
  'a * term ->
  ('b list * instantiation) * 'c list * (instantiation -> 'd list -> thm) =
  <fun>
val ( ITAUT_TAC ) : tactic = <fun>
val ( ITAUT ) : term -> thm = <fun>
- : unit = ()
type gconv = int * conv
val ( REWR_CONV ) : thm -> term -> thm = <fun>
val ( IMP_REWR_CONV ) : thm -> term -> thm = <fun>
val ( ORDERED_REWR_CONV ) : (term -> term -> bool) -> thm -> term -> thm =
  <fun>
val ( ORDERED_IMP_REWR_CONV ) : (term -> term -> bool) -> thm -> term -> thm =
  <fun>
val term_order : term -> term -> bool = <fun>
File "/home/student/OCaml/hol_light (gzip)/simp.ml", line 89, characters 2-1063:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(Abs (_, _)|Const (_, _)|Var (_, _))
val net_of_thm :
  bool -> thm -> (int * (term -> thm)) net -> (int * (term -> thm)) net =
  <fun>
val net_of_conv : term -> 'a -> (int * 'a) net -> (int * 'a) net = <fun>
val net_of_cong :
  thm -> (int * (term -> thm)) net -> (int * (term -> thm)) net = <fun>
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Warning: inventing type variables
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val mk_rewrites : bool -> thm -> thm list -> thm list = <fun>
val ( REWRITES_CONV ) : ('a * (term -> 'b)) net -> term -> 'b = <fun>
type prover = Prover of conv * (thm list -> prover)
val mk_prover : ('a -> conv) -> ('a -> thm list -> 'a) -> 'a -> prover =
  <fun>
val augment : prover -> thm list -> prover = <fun>
val apply_prover : prover -> term -> thm = <fun>
type simpset =
    Simpset of gconv net * (strategy -> strategy) * prover list *
      (thm -> thm list -> thm list)
and strategy = simpset -> int -> term -> thm
val basic_prover :
  (simpset -> 'a -> term -> thm) -> simpset -> 'a -> term -> thm = <fun>
val ss_of_thms : thm list -> simpset -> simpset = <fun>
val ss_of_conv : term -> conv -> simpset -> simpset = <fun>
val ss_of_congs : thm list -> simpset -> simpset = <fun>
val ss_of_prover : (strategy -> strategy) -> simpset -> simpset = <fun>
val ss_of_provers : prover list -> simpset -> simpset = <fun>
val ss_of_maker : (thm -> thm list -> thm list) -> simpset -> simpset = <fun>
val ( AUGMENT_SIMPSET ) : thm -> simpset -> simpset = <fun>
File "/home/student/OCaml/hol_light (gzip)/simp.ml", line 323, characters 6-20:
Warning Y: unused variable trivial_prover.
val ( ONCE_DEPTH_SQCONV ) : strategy = <fun>
val ( DEPTH_SQCONV ) : strategy = <fun>
val ( REDEPTH_SQCONV ) : strategy = <fun>
val ( TOP_DEPTH_SQCONV ) : strategy = <fun>
val ( TOP_SWEEP_SQCONV ) : strategy = <fun>
val set_basic_rewrites : thm list -> unit = <fun>
val extend_basic_rewrites : thm list -> unit = <fun>
val basic_rewrites : unit -> thm list = <fun>
val set_basic_convs : (string * (term * conv)) list -> unit = <fun>
val extend_basic_convs : string * (term * conv) -> unit = <fun>
val basic_convs : unit -> (string * (term * conv)) list = <fun>
val basic_net : unit -> gconv net = <fun>
val set_basic_congs : thm list -> unit = <fun>
val extend_basic_congs : thm list -> unit = <fun>
val basic_congs : unit -> thm list = <fun>
val ( GENERAL_REWRITE_CONV ) :
  bool -> (conv -> conv) -> gconv net -> thm list -> conv = <fun>
val ( GEN_REWRITE_CONV ) : (conv -> conv) -> thm list -> conv = <fun>
val ( PURE_REWRITE_CONV ) : thm list -> conv = <fun>
val ( REWRITE_CONV ) : thm list -> conv = <fun>
val ( PURE_ONCE_REWRITE_CONV ) : thm list -> conv = <fun>
val ( ONCE_REWRITE_CONV ) : thm list -> conv = <fun>
val ( GEN_REWRITE_RULE ) : (conv -> conv) -> thm list -> thm -> thm = <fun>
val ( PURE_REWRITE_RULE ) : thm list -> thm -> thm = <fun>
val ( REWRITE_RULE ) : thm list -> thm -> thm = <fun>
val ( PURE_ONCE_REWRITE_RULE ) : thm list -> thm -> thm = <fun>
val ( ONCE_REWRITE_RULE ) : thm list -> thm -> thm = <fun>
val ( PURE_ASM_REWRITE_RULE ) : thm list -> thm -> thm = <fun>
val ( ASM_REWRITE_RULE ) : thm list -> thm -> thm = <fun>
val ( PURE_ONCE_ASM_REWRITE_RULE ) : thm list -> thm -> thm = <fun>
val ( ONCE_ASM_REWRITE_RULE ) : thm list -> thm -> thm = <fun>
val ( GEN_REWRITE_TAC ) : (conv -> conv) -> thm list -> tactic = <fun>
val ( PURE_REWRITE_TAC ) : thm list -> tactic = <fun>
val ( REWRITE_TAC ) : thm list -> tactic = <fun>
val ( PURE_ONCE_REWRITE_TAC ) : thm list -> tactic = <fun>
val ( ONCE_REWRITE_TAC ) : thm list -> tactic = <fun>
val ( PURE_ASM_REWRITE_TAC ) : thm list -> tactic = <fun>
val ( ASM_REWRITE_TAC ) : thm list -> tactic = <fun>
val ( PURE_ONCE_ASM_REWRITE_TAC ) : thm list -> tactic = <fun>
val ( ONCE_ASM_REWRITE_TAC ) : thm list -> tactic = <fun>
val ( GEN_SIMPLIFY_CONV ) : strategy -> simpset -> int -> thm list -> conv =
  <fun>
val ( ONCE_SIMPLIFY_CONV ) : simpset -> thm list -> conv = <fun>
val ( SIMPLIFY_CONV ) : simpset -> thm list -> conv = <fun>
val empty_ss : simpset = Simpset (Netnode ([], []), <fun>, [], <fun>)
val basic_ss : thm list -> simpset = <fun>
val ( SIMP_CONV ) : thm list -> conv = <fun>
val ( PURE_SIMP_CONV ) : thm list -> conv = <fun>
val ( ONCE_SIMP_CONV ) : thm list -> conv = <fun>
val ( SIMP_RULE ) : thm list -> thm -> thm = <fun>
val ( PURE_SIMP_RULE ) : thm list -> thm -> thm = <fun>
val ( ONCE_SIMP_RULE ) : thm list -> thm -> thm = <fun>
val ( SIMP_TAC ) : thm list -> tactic = <fun>
val ( PURE_SIMP_TAC ) : thm list -> tactic = <fun>
val ( ONCE_SIMP_TAC ) : thm list -> tactic = <fun>
val ( ASM_SIMP_TAC ) : thm list -> tactic = <fun>
val ( PURE_ASM_SIMP_TAC ) : thm list -> tactic = <fun>
val ( ONCE_ASM_SIMP_TAC ) : thm list -> tactic = <fun>
val ( ABBREV_TAC ) : term -> (string * thm) list * term -> goalstate = <fun>
val ( EXPAND_TAC ) : string -> tactic = <fun>
- : unit = ()
val ( EQ_REFL ) : thm = |- !x. x = x
val ( EQ_REFL_T ) : thm = |- !x. x = x <=> T
val ( EQ_SYM ) : thm = |- !x y. x = y ==> y = x
val ( EQ_SYM_EQ ) : thm = |- !x y. x = y <=> y = x
val ( EQ_TRANS ) : thm = |- !x y z. x = y /\ y = z ==> x = z
val ( REFL_CLAUSE ) : thm = |- !x. x = x <=> T
val ( AC ) : thm -> term -> thm = <fun>
val ( BETA_THM ) : thm = |- !f y. (\x. f x) y = f y
val ( ABS_SIMP ) : thm = |- !t1 t2. (\x. t1) t2 = t1
Searching with limit 0
Searching with limit 1
val ( CONJ_ASSOC ) : thm = |- !t1 t2 t3. t1 /\ t2 /\ t3 <=> (t1 /\ t2) /\ t3
Searching with limit 0
Searching with limit 1
val ( CONJ_SYM ) : thm = |- !t1 t2. t1 /\ t2 <=> t2 /\ t1
Searching with limit 0
Searching with limit 1
val ( CONJ_ACI ) : thm =
  |- (p /\ q <=> q /\ p) /\
     ((p /\ q) /\ r <=> p /\ q /\ r) /\
     (p /\ q /\ r <=> q /\ p /\ r) /\
     (p /\ p <=> p) /\
     (p /\ p /\ q <=> p /\ q)
Searching with limit 0
Searching with limit 1
val ( DISJ_ASSOC ) : thm = |- !t1 t2 t3. t1 \/ t2 \/ t3 <=> (t1 \/ t2) \/ t3
Searching with limit 0
Searching with limit 1
val ( DISJ_SYM ) : thm = |- !t1 t2. t1 \/ t2 <=> t2 \/ t1
Searching with limit 0
Searching with limit 1
val ( DISJ_ACI ) : thm =
  |- (p \/ q <=> q \/ p) /\
     ((p \/ q) \/ r <=> p \/ q \/ r) /\
     (p \/ q \/ r <=> q \/ p \/ r) /\
     (p \/ p <=> p) /\
     (p \/ p \/ q <=> p \/ q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( IMP_CONJ ) : thm = |- p /\ q ==> r <=> p ==> q ==> r
val ( IMP_IMP ) : thm = |- p ==> q ==> r <=> p /\ q ==> r
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( IMP_CONJ_ALT ) : thm = |- p /\ q ==> r <=> q ==> p ==> r
Searching with limit 0
Searching with limit 1
val ( LEFT_OR_DISTRIB ) : thm = |- !p q r. p /\ (q \/ r) <=> p /\ q \/ p /\ r
Searching with limit 0
Searching with limit 1
val ( RIGHT_OR_DISTRIB ) : thm =
  |- !p q r. (p \/ q) /\ r <=> p /\ r \/ q /\ r
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( FORALL_SIMP ) : thm = |- !t. (!x. t) <=> t
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( EXISTS_SIMP ) : thm = |- !t. (?x. t) <=> t
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( EQ_IMP ) : thm = |- (a <=> b) ==> a ==> b
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( EQ_CLAUSES ) : thm =
  |- !t. ((T <=> t) <=> t) /\
         ((t <=> T) <=> t) /\
         ((F <=> t) <=> ~t) /\
         ((t <=> F) <=> ~t)
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( NOT_CLAUSES_WEAK ) : thm = |- (~T <=> F) /\ (~F <=> T)
Searching with limit 0
Searching with limit 1
val ( AND_CLAUSES ) : thm =
  |- !t. (T /\ t <=> t) /\
         (t /\ T <=> t) /\
         (F /\ t <=> F) /\
         (t /\ F <=> F) /\
         (t /\ t <=> t)
Searching with limit 0
Searching with limit 1
val ( OR_CLAUSES ) : thm =
  |- !t. (T \/ t <=> T) /\
         (t \/ T <=> T) /\
         (F \/ t <=> t) /\
         (t \/ F <=> t) /\
         (t \/ t <=> t)
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( IMP_CLAUSES ) : thm =
  |- !t. (T ==> t <=> t) /\
         (t ==> T <=> T) /\
         (F ==> t <=> T) /\
         (t ==> t <=> T) /\
         (t ==> F <=> ~t)
Warning: inventing type variables
- : unit = ()
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
- : unit = ()
val ( EXISTS_UNIQUE_THM ) : thm =
  |- !P. (?!x. P x) <=> (?x. P x) /\ (!x x'. P x /\ P x' ==> x = x')
val ( EXISTS_REFL ) : thm = |- !a. ?x. x = a
val ( EXISTS_UNIQUE_REFL ) : thm = |- !a. ?!x. x = a
val ( UNWIND_THM1 ) : thm = |- !P a. (?x. a = x /\ P x) <=> P a
val ( UNWIND_THM2 ) : thm = |- !P a. (?x. x = a /\ P x) <=> P a
val ( FORALL_UNWIND_THM2 ) : thm = |- !P a. (!x. x = a ==> P x) <=> P a
Warning: inventing type variables
val ( FORALL_UNWIND_THM1 ) : thm = |- !P a. (!x. a = x ==> P x) <=> P a
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
Searching with limit 5
val ( SWAP_FORALL_THM ) : thm = |- !P. (!x y. P x y) <=> (!y x. P x y)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
Searching with limit 5
val ( SWAP_EXISTS_THM ) : thm = |- !P. (?x y. P x y) <=> (?y x. P x y)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( FORALL_AND_THM ) : thm =
  |- !P Q. (!x. P x /\ Q x) <=> (!x. P x) /\ (!x. Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( AND_FORALL_THM ) : thm =
  |- !P Q. (!x. P x) /\ (!x. Q x) <=> (!x. P x /\ Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( LEFT_AND_FORALL_THM ) : thm =
  |- !P Q. (!x. P x) /\ Q <=> (!x. P x /\ Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( RIGHT_AND_FORALL_THM ) : thm =
  |- !P Q. P /\ (!x. Q x) <=> (!x. P /\ Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( EXISTS_OR_THM ) : thm =
  |- !P Q. (?x. P x \/ Q x) <=> (?x. P x) \/ (?x. Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( OR_EXISTS_THM ) : thm =
  |- !P Q. (?x. P x) \/ (?x. Q x) <=> (?x. P x \/ Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( LEFT_OR_EXISTS_THM ) : thm = |- !P Q. (?x. P x) \/ Q <=> (?x. P x \/ Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( RIGHT_OR_EXISTS_THM ) : thm =
  |- !P Q. P \/ (?x. Q x) <=> (?x. P \/ Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( LEFT_EXISTS_AND_THM ) : thm =
  |- !P Q. (?x. P x /\ Q) <=> (?x. P x) /\ Q
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( RIGHT_EXISTS_AND_THM ) : thm =
  |- !P Q. (?x. P /\ Q x) <=> P /\ (?x. Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( TRIV_EXISTS_AND_THM ) : thm =
  |- !P Q. (?x. P /\ Q) <=> (?x. P) /\ (?x. Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( LEFT_AND_EXISTS_THM ) : thm =
  |- !P Q. (?x. P x) /\ Q <=> (?x. P x /\ Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( RIGHT_AND_EXISTS_THM ) : thm =
  |- !P Q. P /\ (?x. Q x) <=> (?x. P /\ Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( TRIV_AND_EXISTS_THM ) : thm =
  |- !P Q. (?x. P) /\ (?x. Q) <=> (?x. P /\ Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( TRIV_FORALL_OR_THM ) : thm =
  |- !P Q. (!x. P \/ Q) <=> (!x. P) \/ (!x. Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( TRIV_OR_FORALL_THM ) : thm =
  |- !P Q. (!x. P) \/ (!x. Q) <=> (!x. P \/ Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val ( RIGHT_IMP_FORALL_THM ) : thm =
  |- !P Q. P ==> (!x. Q x) <=> (!x. P ==> Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val ( RIGHT_FORALL_IMP_THM ) : thm =
  |- !P Q. (!x. P ==> Q x) <=> P ==> (!x. Q x)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val ( LEFT_IMP_EXISTS_THM ) : thm =
  |- !P Q. (?x. P x) ==> Q <=> (!x. P x ==> Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val ( LEFT_FORALL_IMP_THM ) : thm =
  |- !P Q. (!x. P x ==> Q) <=> (?x. P x) ==> Q
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val ( TRIV_FORALL_IMP_THM ) : thm =
  |- !P Q. (!x. P ==> Q) <=> (?x. P) ==> (!x. Q)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val ( TRIV_EXISTS_IMP_THM ) : thm =
  |- !P Q. (?x. P ==> Q) <=> (!x. P) ==> (?x. Q)
val ( EXISTS_UNIQUE_ALT ) : thm =
  |- !P. (?!x. P x) <=> (?x. !y. P y <=> x = y)
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( EXISTS_UNIQUE ) : thm =
  |- !P. (?!x. P x) <=> (?x. P x /\ (!y. P y ==> y = x))
- : unit = ()
val strip_ncomb : int -> term -> term * term list = <fun>
val ( RIGHT_BETAS ) : term list -> thm -> thm = <fun>
val ( EXISTS_EQUATION ) : term -> thm -> thm = <fun>
File "/home/student/OCaml/hol_light (gzip)/ind-defs.ml", line 82, characters 10-14:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val derive_nonschematic_inductive_relations : term -> thm = <fun>
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( MONO_AND ) : thm = |- (A ==> B) /\ (C ==> D) ==> A /\ C ==> B /\ D
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( MONO_OR ) : thm = |- (A ==> B) /\ (C ==> D) ==> A \/ C ==> B \/ D
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( MONO_IMP ) : thm = |- (B ==> A) /\ (C ==> D) ==> (A ==> C) ==> B ==> D
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
val ( MONO_NOT ) : thm = |- (B ==> A) ==> ~A ==> ~B
val ( MONO_FORALL ) : thm = |- (!x. P x ==> Q x) ==> (!x. P x) ==> (!x. Q x)
val ( MONO_EXISTS ) : thm = |- (!x. P x ==> Q x) ==> (?x. P x) ==> (?x. Q x)
val monotonicity_theorems : thm list ref =
  {contents =
    [|- (A ==> B) /\ (C ==> D) ==> A /\ C ==> B /\ D;
     |- (A ==> B) /\ (C ==> D) ==> A \/ C ==> B \/ D;
     |- (B ==> A) /\ (C ==> D) ==> (A ==> C) ==> B ==> D;
     |- (B ==> A) ==> ~A ==> ~B;
     |- (!x. P x ==> Q x) ==> (?x. P x) ==> (?x. Q x);
     |- (!x. P x ==> Q x) ==> (!x. P x) ==> (!x. Q x)]}
File "/home/student/OCaml/hol_light (gzip)/ind-defs.ml", line 283, characters 32-69:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
Searching with limit 0
Searching with limit 1
val ( MONO_TAC ) : goal -> goalstate = <fun>
val prove_monotonicity_hyps : thm -> thm = <fun>
val the_inductive_definitions : '_a list ref = {contents = []}
val prove_inductive_relations_exist : term -> thm = <fun>
val new_inductive_definition : term -> thm * thm * thm = <fun>
File "/home/student/OCaml/hol_light (gzip)/ind-defs.ml", line 451, characters 12-17:
Warning Y: unused variable kth_p.
val derive_strong_induction : thm * thm -> thm = <fun>
- : unit = ()
val ( ETA_AX ) : thm = |- !t. (\x. t x) = t
val ( ETA_CONV ) : term -> thm = <fun>
val ( EQ_EXT ) : thm = |- !f g. (!x. f x = g x) ==> f = g
val ( FUN_EQ_THM ) : thm = |- !f g. f = g <=> (!x. f x = g x)
- : unit = ()
- : unit = ()
val is_select : term -> bool = <fun>
val dest_select : term -> term * term = <fun>
val mk_select : term * term -> term = <fun>
val ( SELECT_AX ) : thm = |- !P x. P x ==> P ((@) P)
val ( EXISTS_THM ) : thm = |- (?) = (\P. P ((@) P))
val ( SELECT_RULE ) : thm -> thm = <fun>
val ( SELECT_CONV ) : term -> thm = <fun>
val ( SELECT_REFL ) : thm = |- !x. (@y. y = x) = x
val ( SELECT_UNIQUE ) : thm = |- !P x. (!y. P y <=> y = x) ==> (@) P = x
- : unit = ()
val the_specifications : '_a list ref = {contents = []}
File "/home/student/OCaml/hol_light (gzip)/class.ml", line 119, characters 8-71:
Warning S: this expression should have type unit.
val new_specification : string list -> thm -> thm = <fun>
val the_type_definitions :
  ((string * string * string) * (thm * thm)) list ref = {contents = []}
val new_type_definition : string -> string * string -> thm -> thm = <fun>
Searching with limit 0
Searching with limit 1
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( EXCLUDED_MIDDLE ) : thm = |- !t. t \/ ~t
val ( BOOL_CASES_AX ) : thm = |- !t. (t <=> T) \/ (t <=> F)
val ( BOOL_CASES_TAC ) : term -> tactic = <fun>
val ( ASM_CASES_TAC ) : term -> tactic = <fun>
val ( TAUT ) : term -> thm = <fun>
val ( DE_MORGAN_THM ) : thm =
  |- !t1 t2. (~(t1 /\ t2) <=> ~t1 \/ ~t2) /\ (~(t1 \/ t2) <=> ~t1 /\ ~t2)
val ( NOT_CLAUSES ) : thm = |- (!t. ~ ~t <=> t) /\ (~T <=> F) /\ (~F <=> T)
val ( NOT_IMP ) : thm = |- !t1 t2. ~(t1 ==> t2) <=> t1 /\ ~t2
val ( CONTRAPOS_THM ) : thm = |- !t1 t2. ~t1 ==> ~t2 <=> t2 ==> t1
- : unit = ()
val ( CCONTR ) : term -> thm -> thm = <fun>
val ( CONTRAPOS_CONV ) : term -> thm = <fun>
val ( REFUTE_THEN ) : thm_tactic -> (string * thm) list * term -> goalstate =
  <fun>
val ( NOT_EXISTS_THM ) : thm = |- !P. ~(?x. P x) <=> (!x. ~P x)
val ( EXISTS_NOT_THM ) : thm = |- !P. (?x. ~P x) <=> ~(!x. P x)
val ( NOT_FORALL_THM ) : thm = |- !P. ~(!x. P x) <=> (?x. ~P x)
val ( FORALL_NOT_THM ) : thm = |- !P. (!x. ~P x) <=> ~(?x. P x)
val ( FORALL_BOOL_THM ) : thm = |- (!b. P b) <=> P T /\ P F
val ( EXISTS_BOOL_THM ) : thm = |- (?b. P b) <=> P T \/ P F
val ( LEFT_FORALL_OR_THM ) : thm = |- !P Q. (!x. P x \/ Q) <=> (!x. P x) \/ Q
val ( RIGHT_FORALL_OR_THM ) : thm =
  |- !P Q. (!x. P \/ Q x) <=> P \/ (!x. Q x)
val ( LEFT_OR_FORALL_THM ) : thm = |- !P Q. (!x. P x) \/ Q <=> (!x. P x \/ Q)
val ( RIGHT_OR_FORALL_THM ) : thm =
  |- !P Q. P \/ (!x. Q x) <=> (!x. P \/ Q x)
val ( LEFT_IMP_FORALL_THM ) : thm =
  |- !P Q. (!x. P x) ==> Q <=> (?x. P x ==> Q)
val ( LEFT_EXISTS_IMP_THM ) : thm =
  |- !P Q. (?x. P x ==> Q) <=> (!x. P x) ==> Q
val ( RIGHT_IMP_EXISTS_THM ) : thm =
  |- !P Q. P ==> (?x. Q x) <=> (?x. P ==> Q x)
val ( RIGHT_EXISTS_IMP_THM ) : thm =
  |- !P Q. (?x. P ==> Q x) <=> P ==> (?x. Q x)
val ( COND_DEF ) : thm =
  |- COND = (\t t1 t2. @x. ((t <=> T) ==> x = t1) /\ ((t <=> F) ==> x = t2))
val ( COND_CLAUSES ) : thm =
  |- !t1 t2. (if T then t1 else t2) = t1 /\ (if F then t1 else t2) = t2
val is_cond : term -> bool = <fun>
val mk_cond : term * term * term -> term = <fun>
val dest_cond : term -> term * (term * term) = <fun>
- : unit = ()
val ( COND_EXPAND ) : thm =
  |- !b t1 t2. (if b then t1 else t2) <=> (~b \/ t1) /\ (b \/ t2)
val ( COND_ID ) : thm = |- !b t. (if b then t else t) = t
val ( COND_RAND ) : thm =
  |- !b f x y. f (if b then x else y) = (if b then f x else f y)
val ( COND_RATOR ) : thm =
  |- !b f g x. (if b then f else g) x = (if b then f x else g x)
val ( COND_ABS ) : thm =
  |- !b f g. (\x. if b then f x else g x) = (if b then f else g)
val ( MONO_COND ) : thm =
  |- (A ==> B) /\ (C ==> D) ==> (if b then A else C) ==> (if b then B else D)
- : unit = ()
val ( COND_ELIM_THM ) : thm =
  |- P (if c then x else y) <=> (c ==> P x) /\ (~c ==> P y)
val ( COND_ELIM_CONV ) : term -> thm = <fun>
val ( COND_CASES_TAC ) : tactic = <fun>
val ( SKOLEM_THM ) : thm = |- !P. (!x. ?y. P x y) <=> (?y. !x. P x (y x))
val ( UNIQUE_SKOLEM_ALT ) : thm =
  |- !P. (!x. ?!y. P x y) <=> (?f. !x y. P x y <=> f x = y)
val ( UNIQUE_SKOLEM_THM ) : thm =
  |- !P. (!x. ?!y. P x y) <=> (?!f. !x. P x (f x))
Warning: inventing type variables
- : unit = ()
Warning: inventing type variables
- : unit = ()
val bool_INDUCT : thm = |- !P. P F /\ P T ==> (!x. P x)
val bool_RECURSION : thm = |- !a b. ?f. f F = a /\ f T = b
val inductive_type_store : (string * (int * thm * thm)) list ref =
  {contents =
    [("bool",
      (2, |- !P. P F /\ P T ==> (!x. P x), |- !a b. ?f. f F = a /\ f T = b))]}
- : unit = ()
- : unit = ()
val o_DEF : thm = |- !f g. f o g = (\x. f (g x))
val ( I_DEF ) : thm = |- I = (\x. x)
val o_THM : thm = |- !f g x. (f o g) x = f (g x)
val o_ASSOC : thm = |- !f g h. f o g o h = (f o g) o h
val ( I_THM ) : thm = |- !x. I x = x
val ( I_O_ID ) : thm = |- !f. I o f = f /\ f o I = f
val ( EXISTS_ONE_REP ) : thm = |- ?b. b
val one_tydef : thm =
  |- (!a. one_ABS (one_REP a) = a) /\ (!r. r <=> one_REP (one_ABS r) <=> r)
val one_DEF : thm = |- one = (@x. T)
val one : thm = |- !v. v = one
val one_axiom : thm = |- !f g. f = g
val one_INDUCT : thm = |- !P. P one ==> (!x. P x)
val one_RECURSION : thm = |- !e. ?fn. fn one = e
val one_Axiom : thm = |- !e. ?!fn. fn one = e
- : unit = ()
- : unit = ()
val ( PRESIMP_CONV ) : conv = <fun>
val ( CONJ_ACI_RULE ) : term -> thm = <fun>
val ( DISJ_ACI_RULE ) : term -> thm = <fun>
val ( CONJ_CANON_CONV ) : term -> thm = <fun>
val ( DISJ_CANON_CONV ) : term -> thm = <fun>
File "/home/student/OCaml/hol_light (gzip)/canon.ml", line 111, characters 6-51:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( GEN_NNF_CONV ) : bool -> conv * (term -> thm * thm) -> conv = <fun>
val ( NNF_CONV ) : conv = <fun>
val ( NNFC_CONV ) : conv = <fun>
val ( SKOLEM_CONV ) : conv = <fun>
val ( PRENEX_CONV ) : conv = <fun>
val ( WEAK_DNF_CONV ) : conv = <fun>
val ( DNF_CONV ) : conv = <fun>
val ( WEAK_CNF_CONV ) : conv = <fun>
val ( CNF_CONV ) : conv = <fun>
val ( ASSOC_CONV ) : thm -> term -> thm = <fun>
val ( SELECT_ELIM_TAC ) : tactic = <fun>
Warning: inventing type variables
Warning: inventing type variables
val ( LAMBDA_ELIM_CONV ) : conv = <fun>
val ( CONDS_ELIM_CONV ) : conv = <fun>
val ( CONDS_CELIM_CONV ) : conv = <fun>
val ( ASM_FOL_TAC ) : (string * thm) list * term -> goalstate = <fun>
val ( PROP_ATOM_CONV ) : conv -> conv = <fun>
- : unit = ()
val meson_depth : bool ref = {contents = false}
val meson_prefine : bool ref = {contents = true}
val meson_dcutin : int ref = {contents = 1}
val meson_skew : int ref = {contents = 3}
val meson_brand : bool ref = {contents = false}
val meson_split_limit : int ref = {contents = 8}
val meson_chatty : bool ref = {contents = false}
exception Cut
type fol_term = Fvar of int | Fnapp of int * fol_term list
type fol_atom = int * fol_term list
type fol_form =
    Atom of fol_atom
  | Conj of fol_form * fol_form
  | Disj of fol_form * fol_form
  | Forallq of int * fol_form
type fol_goal =
    Subgoal of fol_atom * fol_goal list * (int * thm) * int *
      (fol_term * int) list
File "/home/student/OCaml/hol_light (gzip)/meson.ml", line 419, characters 20-25:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( GEN_MESON_TAC ) : int -> int -> int -> thm list -> tactic = <fun>
val ( ASM_MESON_TAC ) : thm list -> tactic = <fun>
val ( MESON_TAC ) : thm list -> tactic = <fun>
val ( MESON ) : thm list -> term -> thm = <fun>
- : unit = ()
val define_quotient_type : string -> string * string -> term -> thm * thm =
  <fun>
val lift_function : thm -> thm * thm -> string -> thm -> thm * thm = <fun>
0..0..1..3..7..15..26..54..86..136..solved at 208
0..0..1..solved at 4
0..0..solved at 2
0..0..1..4..solved at 10
0..0..1..4..9..solved at 21
0..0..solved at 2
0..0..1..solved at 4
0..0..1..2..6..11..22..38..70..solved at 116
0..0..solved at 2
0..0..solved at 2
0..0..1..2..6..11..22..41..76..solved at 108
0..0..1..solved at 4
0..0..solved at 2
val lift_theorem : thm * thm -> thm * thm * thm -> thm list -> thm -> thm =
  <fun>
- : unit = ()
val prove_recursive_functions_exist : thm -> term -> thm = <fun>
val new_recursive_definition : thm -> term -> thm = <fun>
- : unit = ()
val ( LET_DEF ) : thm = |- !f x. LET f x = f x
val ( LET_END_DEF ) : thm = |- !t. LET_END t = t
val ( GABS_DEF ) : thm = |- !P. GABS P = (@) P
val ( GEQ_DEF ) : thm = |- !a b. GEQ a b <=> a = b
Warning: inventing type variables
val _SEQPATTERN : thm =
  |- _SEQPATTERN = (\r s x. if ?y. r x y then r x else s x)
val _UNGUARDED_PATTERN : thm = |- _UNGUARDED_PATTERN = (\p r. p /\ r)
val _GUARDED_PATTERN : thm = |- _GUARDED_PATTERN = (\p g r. p /\ g /\ r)
Warning: inventing type variables
val _MATCH : thm =
  |- _MATCH = (\e r. if (?!) (r e) then (@) (r e) else @z. F)
Warning: inventing type variables
val _FUNCTION : thm =
  |- _FUNCTION = (\r x. if (?!) (r x) then (@) (r x) else @z. F)
val mk_pair_def : thm = |- !x y. mk_pair x y = (\a b. a = x /\ b = y)
0..0..solved at 2
val ( PAIR_EXISTS_THM ) : thm = |- ?x a b. x = mk_pair a b
val prod_tybij : thm =
  |- (!a. ABS_prod (REP_prod a) = a) /\
     (!r. (?a b. r = mk_pair a b) <=> REP_prod (ABS_prod r) = r)
0..0..1..solved at 4
val ( REP_ABS_PAIR ) : thm =
  |- !x y. REP_prod (ABS_prod (mk_pair x y)) = mk_pair x y
- : unit = ()
val ( COMMA_DEF ) : thm = |- !x y. x,y = ABS_prod (mk_pair x y)
val ( FST_DEF ) : thm = |- !p. FST p = (@x. ?y. p = x,y)
val ( SND_DEF ) : thm = |- !p. SND p = (@y. ?x. p = x,y)
0..0..1..2..solved at 6
0..0..1..2..solved at 6
0..0..solved at 2
val ( PAIR_EQ ) : thm = |- !x y a b. x,y = a,b <=> x = a /\ y = b
val ( PAIR_SURJECTIVE ) : thm = |- !p. ?x y. p = x,y
val ( FST ) : thm = |- !x y. FST (x,y) = x
val ( SND ) : thm = |- !x y. SND (x,y) = y
val ( PAIR ) : thm = |- !x. FST x,SND x = x
Warning: inventing type variables
val pair_INDUCT : thm = |- !P. (!x y. P (x,y)) ==> (!p. P p)
val pair_RECURSION : thm = |- !PAIR'. ?fn. !a0 a1. fn (a0,a1) = PAIR' a0 a1
val is_pair : term -> bool = <fun>
val dest_pair : term -> term * term = <fun>
val mk_pair : term * term -> term = <fun>
- : unit = ()
val the_definitions : thm list ref =
  {contents =
    [|- !p. SND p = (@y. ?x. p = x,y); |- !p. FST p = (@x. ?y. p = x,y);
     |- !x y. x,y = ABS_prod (mk_pair x y);
     |- !x y. mk_pair x y = (\a b. a = x /\ b = y);
     |- !a b. GEQ a b <=> a = b; |- !P. GABS P = (@) P; |- !t. LET_END t = t;
     |- !f x. LET f x = f x; |- one = (@x. T); |- I = (\x. x);
     |- !f g. f o g = (\x. f (g x));
     |- COND =
        (\t t1 t2. @x. ((t <=> T) ==> x = t1) /\ ((t <=> F) ==> x = t2));
     |- _FALSITY_ <=> F;
     |- (?!) = (\P. (?) P /\ (!x y. P x /\ P y ==> x = y));
     |- (~) = (\p. p ==> F); |- F <=> (!p. p);
     |- (\/) = (\p q. !r. (p ==> r) ==> (q ==> r) ==> r);
     |- (?) = (\P. !q. (!x. P x ==> q) ==> q); |- (!) = (\P. P = (\x. T));
     |- (==>) = (\p q. p /\ q <=> p);
     |- (/\) = (\p q. (\f. f p q) = (\f. f T T)); |- T <=> (\p. p) = (\p. p)]}
val new_definition : term -> thm = <fun>
val ( CURRY_DEF ) : thm = |- !f x y. CURRY f x y = f (x,y)
val ( UNCURRY_DEF ) : thm = |- !f x y. UNCURRY f (x,y) = f x y
val ( PASSOC_DEF ) : thm = |- !f x y z. PASSOC f (x,y,z) = f ((x,y),z)
val ( GABS_CONV ) : conv -> term -> thm = <fun>
Warning: inventing type variables
val ( GEN_BETA_CONV ) : term -> thm = <fun>
Warning: inventing type variables
- : unit = ()
- : unit = ()
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 6
val ( FORALL_PAIR_THM ) : thm = |- !P. (!p. P p) <=> (!p1 p2. P (p1,p2))
Warning: inventing type variables
0..0..1..2..6..11..solved at 22
0..0..solved at 2
val ( EXISTS_PAIR_THM ) : thm = |- !P. (?p. P p) <=> (?p1 p2. P (p1,p2))
Warning: inventing type variables
val ( LAMBDA_PAIR_THM ) : thm = |- !t. (\p. t p) = (\(x,y). t (x,y))
Warning: inventing type variables
val ( FORALL_PAIRED_THM ) : thm = |- !P. (!(x,y). P x y) <=> (!x y. P x y)
Warning: inventing type variables
val ( EXISTS_PAIRED_THM ) : thm = |- !P. (?(x,y). P x y) <=> (?x y. P x y)
Warning: inventing type variables
val ( FORALL_TRIPLED_THM ) : thm =
  |- !P. (!(x,y,z). P x y z) <=> (!x y z. P x y z)
Warning: inventing type variables
val ( EXISTS_TRIPLED_THM ) : thm =
  |- !P. (?(x,y,z). P x y z) <=> (?x y z. P x y z)
val let_CONV : term -> thm = <fun>
Warning: inventing type variables
0..0..1..5..13..solved at 26
0..0..1..5..13..solved at 26
0..0..solved at 2
Warning: inventing type variables
val ( LET_TAC ) : tactic = <fun>
- : unit = ()
- : unit = ()
val ( ONE_ONE ) : thm =
  |- !f. ONE_ONE f <=> (!x1 x2. f x1 = f x2 ==> x1 = x2)
val ( ONTO ) : thm = |- !f. ONTO f <=> (!y. ?x. y = f x)
val ( INFINITY_AX ) : thm = |- ?f. ONE_ONE f /\ ~ONTO f
0..0..2..solved at 5
0..0..solved at 2
0..0..1..3..solved at 9
val ( IND_SUC_0_EXISTS ) : thm =
  |- ?f z. (!x1 x2. f x1 = f x2 <=> x1 = x2) /\ (!x. ~(f x = z))
val ( IND_SUC_INJ ) : thm = |- !x1 x2. IND_SUC x1 = IND_SUC x2 <=> x1 = x2
val ( IND_SUC_0 ) : thm = |- !x. ~(IND_SUC x = IND_0)
val ( NUM_REP_RULES ) : thm =
  |- NUM_REP IND_0 /\ (!i. NUM_REP i ==> NUM_REP (IND_SUC i))
val ( NUM_REP_INDUCT ) : thm =
  |- !NUM_REP'. NUM_REP' IND_0 /\ (!i. NUM_REP' i ==> NUM_REP' (IND_SUC i))
                ==> (!a. NUM_REP a ==> NUM_REP' a)
val ( NUM_REP_CASES ) : thm =
  |- !a. NUM_REP a <=> a = IND_0 \/ (?i. a = IND_SUC i /\ NUM_REP i)
val num_tydef : thm * thm =
  (|- mk_num (dest_num a) = a, |- NUM_REP r <=> dest_num (mk_num r) = r)
val ( ZERO_DEF ) : thm = |- _0 = mk_num IND_0
val ( SUC_DEF ) : thm = |- !n. SUC n = mk_num (IND_SUC (dest_num n))
0..0..1..2..5..9..15..29..44..68..142..260..solved at 420
val ( NOT_SUC ) : thm = |- !n. ~(SUC n = _0)
val ( SUC_INJ ) : thm = |- !m n. SUC m = SUC n <=> m = n
val num_INDUCTION : thm =
  |- !P. P _0 /\ (!n. P n ==> P (SUC n)) ==> (!n. P n)
val num_Axiom : thm =
  |- !e f. ?!fn. fn _0 = e /\ (!n. fn (SUC n) = f (fn n) n)
val ( NUMERAL ) : thm = |- !n. NUMERAL n = n
File "/home/student/OCaml/hol_light (gzip)/num.ml", line 137, characters 4-39:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( NOT_SUC ) : thm = |- !n. ~(SUC n = 0)
val num_INDUCTION : thm = |- !P. P 0 /\ (!n. P n ==> P (SUC n)) ==> (!n. P n)
val num_Axiom : thm =
  |- !e f. ?!fn. fn 0 = e /\ (!n. fn (SUC n) = f (fn n) n)
val ( INDUCT_TAC ) : tactic = <fun>
val num_RECURSION : thm =
  |- !e f. ?fn. fn 0 = e /\ (!n. fn (SUC n) = f (fn n) n)
0..0..solved at 3
0..0..solved at 2
val num_CASES : thm = |- !m. m = 0 \/ (?n. m = SUC n)
val num_RECURSION_STD : thm =
  |- !e f. ?fn. fn 0 = e /\ (!n. fn (SUC n) = f n (fn n))
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val ( PRE ) : thm = |- PRE 0 = 0 /\ (!n. PRE (SUC n) = n)
val ( ADD ) : thm = |- (!n. 0 + n = n) /\ (!m n. SUC m + n = SUC (m + n))
val ( ADD_0 ) : thm = |- !m. m + 0 = m
val ( ADD_SUC ) : thm = |- !m n. m + SUC n = SUC (m + n)
val ( ADD_CLAUSES ) : thm =
  |- (!n. 0 + n = n) /\
     (!m. m + 0 = m) /\
     (!m n. SUC m + n = SUC (m + n)) /\
     (!m n. m + SUC n = SUC (m + n))
val ( ADD_SYM ) : thm = |- !m n. m + n = n + m
val ( ADD_ASSOC ) : thm = |- !m n p. m + n + p = (m + n) + p
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..7..14..35..62..solved at 73
val ( ADD_AC ) : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
val ( ADD_EQ_0 ) : thm = |- !m n. m + n = 0 <=> m = 0 /\ n = 0
val ( EQ_ADD_LCANCEL ) : thm = |- !m n p. m + n = m + p <=> n = p
val ( EQ_ADD_RCANCEL ) : thm = |- !m n p. m + p = n + p <=> m = n
val ( EQ_ADD_LCANCEL_0 ) : thm = |- !m n. m + n = m <=> n = 0
val ( EQ_ADD_RCANCEL_0 ) : thm = |- !m n. m + n = n <=> m = 0
val ( BIT0 ) : thm = |- !n. BIT0 n = n + n
val ( BIT1 ) : thm = |- !n. BIT1 n = SUC (n + n)
val ( BIT0_THM ) : thm = |- !n. NUMERAL (BIT0 n) = NUMERAL n + NUMERAL n
val ( BIT1_THM ) : thm =
  |- !n. NUMERAL (BIT1 n) = SUC (NUMERAL n + NUMERAL n)
val ( ONE ) : thm = |- 1 = SUC 0
val ( TWO ) : thm = |- 2 = SUC 1
val mk_numeral : num -> term = <fun>
val mk_small_numeral : int -> term = <fun>
val dest_small_numeral : term -> int = <fun>
val is_numeral : term -> bool = <fun>
val ( ADD1 ) : thm = |- !m. SUC m = m + 1
val ( MULT ) : thm = |- (!n. 0 * n = 0) /\ (!m n. SUC m * n = m * n + n)
val ( MULT_0 ) : thm = |- !m. m * 0 = 0
val ( MULT_SUC ) : thm = |- !m n. m * SUC n = m + m * n
val ( MULT_CLAUSES ) : thm =
  |- (!n. 0 * n = 0) /\
     (!m. m * 0 = 0) /\
     (!n. 1 * n = n) /\
     (!m. m * 1 = m) /\
     (!m n. SUC m * n = m * n + n) /\
     (!m n. m * SUC n = m + m * n)
val ( MULT_SYM ) : thm = |- !m n. m * n = n * m
val ( LEFT_ADD_DISTRIB ) : thm = |- !m n p. m * (n + p) = m * n + m * p
val ( RIGHT_ADD_DISTRIB ) : thm = |- !m n p. (m + n) * p = m * p + n * p
val ( MULT_ASSOC ) : thm = |- !m n p. m * n * p = (m * n) * p
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..7..14..35..62..solved at 73
val ( MULT_AC ) : thm =
  |- m * n = n * m /\ (m * n) * p = m * n * p /\ m * n * p = n * m * p
val ( MULT_EQ_0 ) : thm = |- !m n. m * n = 0 <=> m = 0 \/ n = 0
val ( EQ_MULT_LCANCEL ) : thm = |- !m n p. m * n = m * p <=> m = 0 \/ n = p
val ( EQ_MULT_RCANCEL ) : thm = |- !m n p. m * p = n * p <=> m = n \/ p = 0
val ( MULT_2 ) : thm = |- !n. 2 * n = n + n
val ( MULT_EQ_1 ) : thm = |- !m n. m * n = 1 <=> m = 1 /\ n = 1
val ( EXP ) : thm = |- (!m. m EXP 0 = 1) /\ (!m n. m EXP SUC n = m * m EXP n)
val ( EXP_EQ_0 ) : thm = |- !m n. m EXP n = 0 <=> m = 0 /\ ~(n = 0)
val ( EXP_EQ_1 ) : thm = |- !x n. x EXP n = 1 <=> x = 1 \/ n = 0
val ( EXP_ZERO ) : thm = |- !n. 0 EXP n = (if n = 0 then 1 else 0)
val ( EXP_ADD ) : thm = |- !m n p. m EXP (n + p) = m EXP n * m EXP p
val ( EXP_ONE ) : thm = |- !n. 1 EXP n = 1
val ( EXP_1 ) : thm = |- !n. n EXP 1 = n
val ( EXP_2 ) : thm = |- !n. n EXP 2 = n * n
val ( MULT_EXP ) : thm = |- !p m n. (m * n) EXP p = m EXP p * n EXP p
val ( EXP_MULT ) : thm = |- !m n p. m EXP (n * p) = m EXP n EXP p
val ( LE ) : thm =
  |- (!m. m <= 0 <=> m = 0) /\ (!m n. m <= SUC n <=> m = SUC n \/ m <= n)
val ( LT ) : thm =
  |- (!m. m < 0 <=> F) /\ (!m n. m < SUC n <=> m = n \/ m < n)
val ( GE ) : thm = |- !n m. m >= n <=> n <= m
val ( GT ) : thm = |- !n m. m > n <=> n < m
val ( LE_SUC_LT ) : thm = |- !m n. SUC m <= n <=> m < n
val ( LT_SUC_LE ) : thm = |- !m n. m < SUC n <=> m <= n
val ( LE_SUC ) : thm = |- !m n. SUC m <= SUC n <=> m <= n
val ( LT_SUC ) : thm = |- !m n. SUC m < SUC n <=> m < n
val ( LE_0 ) : thm = |- !n. 0 <= n
val ( LT_0 ) : thm = |- !n. 0 < SUC n
val ( LE_REFL ) : thm = |- !n. n <= n
val ( LT_REFL ) : thm = |- !n. ~(n < n)
val ( LE_ANTISYM ) : thm = |- !m n. m <= n /\ n <= m <=> m = n
val ( LT_ANTISYM ) : thm = |- !m n. ~(m < n /\ n < m)
val ( LET_ANTISYM ) : thm = |- !m n. ~(m <= n /\ n < m)
val ( LTE_ANTISYM ) : thm = |- !m n. ~(m < n /\ n <= m)
val ( LE_TRANS ) : thm = |- !m n p. m <= n /\ n <= p ==> m <= p
val ( LT_TRANS ) : thm = |- !m n p. m < n /\ n < p ==> m < p
val ( LET_TRANS ) : thm = |- !m n p. m <= n /\ n < p ==> m < p
val ( LTE_TRANS ) : thm = |- !m n p. m < n /\ n <= p ==> m < p
val ( LE_CASES ) : thm = |- !m n. m <= n \/ n <= m
val ( LT_CASES ) : thm = |- !m n. m < n \/ n < m \/ m = n
val ( LET_CASES ) : thm = |- !m n. m <= n \/ n < m
val ( LTE_CASES ) : thm = |- !m n. m < n \/ n <= m
val ( LE_LT ) : thm = |- !m n. m <= n <=> m < n \/ m = n
val ( LT_LE ) : thm = |- !m n. m < n <=> m <= n /\ ~(m = n)
val ( NOT_LE ) : thm = |- !m n. ~(m <= n) <=> n < m
val ( NOT_LT ) : thm = |- !m n. ~(m < n) <=> n <= m
val ( LT_IMP_LE ) : thm = |- !m n. m < n ==> m <= n
val ( EQ_IMP_LE ) : thm = |- !m n. m = n ==> m <= n
val ( LT_NZ ) : thm = |- !n. 0 < n <=> ~(n = 0)
val ( LE_1 ) : thm =
  |- (!n. ~(n = 0) ==> 0 < n) /\
     (!n. ~(n = 0) ==> 1 <= n) /\
     (!n. 0 < n ==> ~(n = 0)) /\
     (!n. 0 < n ==> 1 <= n) /\
     (!n. 1 <= n ==> 0 < n) /\
     (!n. 1 <= n ==> ~(n = 0))
val ( LE_EXISTS ) : thm = |- !m n. m <= n <=> (?d. n = m + d)
val ( LT_EXISTS ) : thm = |- !m n. m < n <=> (?d. n = m + SUC d)
val ( LE_ADD ) : thm = |- !m n. m <= m + n
val ( LE_ADDR ) : thm = |- !m n. n <= m + n
val ( LT_ADD ) : thm = |- !m n. m < m + n <=> 0 < n
val ( LT_ADDR ) : thm = |- !m n. n < m + n <=> 0 < m
val ( LE_ADD_LCANCEL ) : thm = |- !m n p. m + n <= m + p <=> n <= p
val ( LE_ADD_RCANCEL ) : thm = |- !m n p. m + p <= n + p <=> m <= n
val ( LT_ADD_LCANCEL ) : thm = |- !m n p. m + n < m + p <=> n < p
val ( LT_ADD_RCANCEL ) : thm = |- !m n p. m + p < n + p <=> m < n
val ( LE_ADD2 ) : thm = |- !m n p q. m <= p /\ n <= q ==> m + n <= p + q
val ( LET_ADD2 ) : thm = |- !m n p q. m <= p /\ n < q ==> m + n < p + q
val ( LTE_ADD2 ) : thm = |- !m n p q. m < p /\ n <= q ==> m + n < p + q
val ( LT_ADD2 ) : thm = |- !m n p q. m < p /\ n < q ==> m + n < p + q
val ( LT_MULT ) : thm = |- !m n. 0 < m * n <=> 0 < m /\ 0 < n
val ( LE_MULT2 ) : thm = |- !m n p q. m <= n /\ p <= q ==> m * p <= n * q
val ( LT_LMULT ) : thm = |- !m n p. ~(m = 0) /\ n < p ==> m * n < m * p
val ( LE_MULT_LCANCEL ) : thm = |- !m n p. m * n <= m * p <=> m = 0 \/ n <= p
val ( LE_MULT_RCANCEL ) : thm = |- !m n p. m * p <= n * p <=> m <= n \/ p = 0
val ( LT_MULT_LCANCEL ) : thm =
  |- !m n p. m * n < m * p <=> ~(m = 0) /\ n < p
val ( LT_MULT_RCANCEL ) : thm =
  |- !m n p. m * p < n * p <=> m < n /\ ~(p = 0)
0..0..1..2..6..11..19..32..45..60..solved at 74
0..0..solved at 2
val ( EQ_SUC ) : thm = |- !m n. SUC m = SUC n <=> m = n
val ( LT_MULT2 ) : thm = |- !m n p q. m < n /\ p < q ==> m * p < n * q
val ( LE_SQUARE_REFL ) : thm = |- !n. n <= n * n
0..0..1..5..13..27..solved at 33
val ( WLOG_LE ) : thm =
  |- (!m n. P m n <=> P n m) /\ (!m n. m <= n ==> P m n) ==> (!m n. P m n)
0..0..1..5..11..22..49..95..171..305..solved at 319
val ( WLOG_LT ) : thm =
  |- (!m. P m m) /\ (!m n. P m n <=> P n m) /\ (!m n. m < n ==> P m n)
     ==> (!m y. P m y)
0..0..3..13..37..solved at 48
0..0..3..solved at 8
0..0..2..8..solved at 23
val num_WF : thm = |- !P. (!n. (!m. m < n ==> P m) ==> P n) ==> (!n. P n)
0..0..solved at 2
0..0..0..1..3..5..solved at 10
val num_WOP : thm = |- !P. (?n. P n) <=> (?n. P n /\ (!m. m < n ==> ~P m))
val num_MAX : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <= M) <=>
         (?m. P m /\ (!x. P x ==> x <= m))
val ( EVEN ) : thm = |- (EVEN 0 <=> T) /\ (!n. EVEN (SUC n) <=> ~EVEN n)
val ( ODD ) : thm = |- (ODD 0 <=> F) /\ (!n. ODD (SUC n) <=> ~ODD n)
val ( NOT_EVEN ) : thm = |- !n. ~EVEN n <=> ODD n
val ( NOT_ODD ) : thm = |- !n. ~ODD n <=> EVEN n
val ( EVEN_OR_ODD ) : thm = |- !n. EVEN n \/ ODD n
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( EVEN_AND_ODD ) : thm = |- !n. ~(EVEN n /\ ODD n)
val ( EVEN_ADD ) : thm = |- !m n. EVEN (m + n) <=> EVEN m <=> EVEN n
val ( EVEN_MULT ) : thm = |- !m n. EVEN (m * n) <=> EVEN m \/ EVEN n
Searching with limit 0
Searching with limit 1
val ( EVEN_EXP ) : thm = |- !m n. EVEN (m EXP n) <=> EVEN m /\ ~(n = 0)
Searching with limit 0
Searching with limit 1
Searching with limit 2
Searching with limit 3
Searching with limit 4
val ( ODD_ADD ) : thm = |- !m n. ODD (m + n) <=> ~(ODD m <=> ODD n)
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( ODD_MULT ) : thm = |- !m n. ODD (m * n) <=> ODD m /\ ODD n
Searching with limit 0
Searching with limit 1
val ( ODD_EXP ) : thm = |- !m n. ODD (m EXP n) <=> ODD m \/ n = 0
val ( EVEN_DOUBLE ) : thm = |- !n. EVEN (2 * n)
val ( ODD_DOUBLE ) : thm = |- !n. ODD (SUC (2 * n))
val ( EVEN_EXISTS_LEMMA ) : thm =
  |- !n. (EVEN n ==> (?m. n = 2 * m)) /\ (~EVEN n ==> (?m. n = SUC (2 * m)))
val ( EVEN_EXISTS ) : thm = |- !n. EVEN n <=> (?m. n = 2 * m)
val ( ODD_EXISTS ) : thm = |- !n. ODD n <=> (?m. n = SUC (2 * m))
0..0..1..4..solved at 10
0..0..2..8..31..79..254..629..1685..solved at 3183
0..0..solved at 2
val ( EVEN_ODD_DECOMPOSITION ) : thm =
  |- !n. (?k m. ODD m /\ n = 2 EXP k * m) <=> ~(n = 0)
val ( SUB ) : thm = |- (!m. m - 0 = m) /\ (!m n. m - SUC n = PRE (m - n))
val ( SUB_0 ) : thm = |- !m. 0 - m = 0 /\ m - 0 = m
val ( SUB_PRESUC ) : thm = |- !m n. PRE (SUC m - n) = m - n
val ( SUB_SUC ) : thm = |- !m n. SUC m - SUC n = m - n
val ( SUB_REFL ) : thm = |- !n. n - n = 0
val ( ADD_SUB ) : thm = |- !m n. (m + n) - n = m
val ( ADD_SUB2 ) : thm = |- !m n. (m + n) - m = n
val ( SUB_EQ_0 ) : thm = |- !m n. m - n = 0 <=> m <= n
val ( ADD_SUBR2 ) : thm = |- !m n. m - (m + n) = 0
val ( ADD_SUBR ) : thm = |- !m n. n - (m + n) = 0
val ( SUB_ADD ) : thm = |- !m n. n <= m ==> m - n + n = m
val ( SUB_ADD_LCANCEL ) : thm = |- !m n p. (m + n) - (m + p) = n - p
val ( SUB_ADD_RCANCEL ) : thm = |- !m n p. (m + p) - (n + p) = m - n
val ( LEFT_SUB_DISTRIB ) : thm = |- !m n p. m * (n - p) = m * n - m * p
val ( RIGHT_SUB_DISTRIB ) : thm = |- !m n p. (m - n) * p = m * p - n * p
val ( SUC_SUB1 ) : thm = |- !n. SUC n - 1 = n
0..0..solved at 3
0..0..solved at 3
0..0..1..4..13..29..74..solved at 99
0..0..1..4..19..49..130..solved at 165
0..0..3..10..29..63..170..solved at 283
0..0..solved at 2
0..0..solved at 5
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 7
0..0..2..4..solved at 10
0..0..solved at 2
0..0..solved at 2
0..0..4..8..solved at 17
0..0..2..4..solved at 11
0..0..solved at 2
0..0..solved at 3
0..0..6..12..solved at 24
val ( EVEN_SUB ) : thm =
  |- !m n. EVEN (m - n) <=> m <= n \/ (EVEN m <=> EVEN n)
val ( ODD_SUB ) : thm = |- !m n. ODD (m - n) <=> n < m /\ ~(ODD m <=> ODD n)
val ( FACT ) : thm = |- FACT 0 = 1 /\ (!n. FACT (SUC n) = SUC n * FACT n)
val ( FACT_LT ) : thm = |- !n. 0 < FACT n
val ( FACT_LE ) : thm = |- !n. 1 <= FACT n
val ( FACT_NZ ) : thm = |- !n. ~(FACT n = 0)
val ( FACT_MONO ) : thm = |- !m n. m <= n ==> FACT m <= FACT n
val ( EXP_LT_0 ) : thm = |- !n x. 0 < x EXP n <=> ~(x = 0) \/ n = 0
val ( LT_EXP ) : thm =
  |- !x m n.
         x EXP m < x EXP n <=> 2 <= x /\ m < n \/ x = 0 /\ ~(m = 0) /\ n = 0
val ( LE_EXP ) : thm =
  |- !x m n.
         x EXP m <= x EXP n <=>
         (if x = 0 then m = 0 ==> n = 0 else x = 1 \/ m <= n)
val ( EQ_EXP ) : thm =
  |- !x m n.
         x EXP m = x EXP n <=>
         (if x = 0 then m = 0 <=> n = 0 else x = 1 \/ m = n)
val ( EXP_MONO_LE_IMP ) : thm = |- !x y n. x <= y ==> x EXP n <= y EXP n
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val ( EXP_MONO_LT_IMP ) : thm =
  |- !x y n. x < y /\ ~(n = 0) ==> x EXP n < y EXP n
0..0..2..7..16..32..solved at 45
val ( EXP_MONO_LE ) : thm = |- !x y n. x EXP n <= y EXP n <=> x <= y \/ n = 0
val ( EXP_MONO_LT ) : thm =
  |- !x y n. x EXP n < y EXP n <=> x < y /\ ~(n = 0)
val ( EXP_MONO_EQ ) : thm = |- !x y n. x EXP n = y EXP n <=> x = y \/ n = 0
val ( DIVMOD_EXIST ) : thm =
  |- !m n. ~(n = 0) ==> (?q r. m = q * n + r /\ r < n)
val ( DIVMOD_EXIST_0 ) : thm =
  |- !m n. ?q r. if n = 0 then q = 0 /\ r = m else m = q * n + r /\ r < n
val ( DIVISION_0 ) : thm =
  |- !m n.
         if n = 0
         then m DIV n = 0 /\ m MOD n = m
         else m = m DIV n * n + m MOD n /\ m MOD n < n
0..0..2..solved at 5
0..0..2..solved at 5
val ( DIVISION ) : thm =
  |- !m n. ~(n = 0) ==> m = m DIV n * n + m MOD n /\ m MOD n < n
val ( DIVMOD_UNIQ_LEMMA ) : thm =
  |- !m n q1 r1 q2 r2.
         (m = q1 * n + r1 /\ r1 < n) /\ m = q2 * n + r2 /\ r2 < n
         ==> q1 = q2 /\ r1 = r2
val ( DIVMOD_UNIQ ) : thm =
  |- !m n q r. m = q * n + r /\ r < n ==> m DIV n = q /\ m MOD n = r
val ( MOD_UNIQ ) : thm = |- !m n q r. m = q * n + r /\ r < n ==> m MOD n = r
val ( DIV_UNIQ ) : thm = |- !m n q r. m = q * n + r /\ r < n ==> m DIV n = q
val ( DIV_MULT ) : thm = |- !m n. ~(m = 0) ==> (m * n) DIV m = n
val ( MOD_MULT ) : thm = |- !m n. ~(m = 0) ==> (m * n) MOD m = 0
val ( MOD_LT ) : thm = |- !m n. m < n ==> m MOD n = m
val ( MOD_EQ ) : thm = |- !m n p q. m = n + q * p ==> m MOD p = n MOD p
val ( DIV_LE ) : thm = |- !m n. ~(n = 0) ==> m DIV n <= m
val ( DIV_MUL_LE ) : thm = |- !m n. n * m DIV n <= m
val ( DIV_0 ) : thm = |- !n. ~(n = 0) ==> 0 DIV n = 0
val ( MOD_0 ) : thm = |- !n. ~(n = 0) ==> 0 MOD n = 0
val ( DIV_1 ) : thm = |- !n. n DIV 1 = n
val ( MOD_1 ) : thm = |- !n. n MOD 1 = 0
val ( DIV_LT ) : thm = |- !m n. m < n ==> m DIV n = 0
val ( MOD_MOD ) : thm =
  |- !m n p. ~(n * p = 0) ==> m MOD (n * p) MOD n = m MOD n
val ( MOD_MOD_REFL ) : thm = |- !m n. ~(n = 0) ==> m MOD n MOD n = m MOD n
val ( DIV_MULT2 ) : thm =
  |- !m n p. ~(m * p = 0) ==> (m * n) DIV (m * p) = n DIV p
val ( MOD_MULT2 ) : thm =
  |- !m n p. ~(m * p = 0) ==> (m * n) MOD (m * p) = m * n MOD p
0..0..2..solved at 5
val ( MOD_EXISTS ) : thm =
  |- !m n. (?q. m = n * q) <=> (if n = 0 then m = 0 else m MOD n = 0)
0..0..2..6..13..45..solved at 52
0..0..2..solved at 5
val ( LE_RDIV_EQ ) : thm =
  |- !a b n. ~(a = 0) ==> (n <= b DIV a <=> a * n <= b)
val ( LE_LDIV_EQ ) : thm =
  |- !a b n. ~(a = 0) ==> (b DIV a <= n <=> b < a * (n + 1))
0..0..2..6..18..42..solved at 52
val ( LE_LDIV ) : thm = |- !a b n. ~(a = 0) /\ b <= a * n ==> b DIV a <= n
0..0..1..solved at 4
0..0..2..4..solved at 8
val ( DIV_MONO ) : thm = |- !m n p. ~(p = 0) /\ m <= n ==> m DIV p <= n DIV p
0..0..1..3..5..10..19..31..52..solved at 74
0..0..2..4..10..24..solved at 34
val ( DIV_MONO_LT ) : thm =
  |- !m n p. ~(p = 0) /\ m + p <= n ==> m DIV p < n DIV p
val ( DIV_EQ_0 ) : thm = |- !m n. ~(n = 0) ==> (m DIV n = 0 <=> m < n)
0..0..solved at 2
0..0..solved at 2
0..0..2..7..solved at 11
val ( MOD_EQ_0 ) : thm =
  |- !m n. ~(n = 0) ==> (m MOD n = 0 <=> (?q. m = q * n))
val ( EVEN_MOD ) : thm = |- !n. EVEN n <=> n MOD 2 = 0
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..1..2..solved at 6
val ( ODD_MOD ) : thm = |- !n. ODD n <=> n MOD 2 = 1
val ( MOD_MULT_RMOD ) : thm =
  |- !m n p. ~(n = 0) ==> (m * p MOD n) MOD n = (m * p) MOD n
val ( MOD_MULT_LMOD ) : thm =
  |- !m n p. ~(n = 0) ==> (m MOD n * p) MOD n = (m * p) MOD n
val ( MOD_MULT_MOD2 ) : thm =
  |- !m n p. ~(n = 0) ==> (m MOD n * p MOD n) MOD n = (m * p) MOD n
val ( MOD_EXP_MOD ) : thm =
  |- !m n p. ~(n = 0) ==> (m MOD n) EXP p MOD n = m EXP p MOD n
val ( MOD_MULT_ADD ) : thm = |- !m n p. (m * n + p) MOD n = p MOD n
val ( MOD_ADD_MOD ) : thm =
  |- !a b n. ~(n = 0) ==> (a MOD n + b MOD n) MOD n = (a + b) MOD n
val ( DIV_ADD_MOD ) : thm =
  |- !a b n.
         ~(n = 0)
         ==> ((a + b) MOD n = a MOD n + b MOD n <=>
              (a + b) DIV n = a DIV n + b DIV n)
val ( DIV_REFL ) : thm = |- !n. ~(n = 0) ==> n DIV n = 1
val ( MOD_LE ) : thm = |- !m n. ~(n = 0) ==> m MOD n <= m
0..0..2..solved at 6
0..0..2..5..11..22..40..solved at 53
val ( DIV_MONO2 ) : thm =
  |- !m n p. ~(p = 0) /\ p <= m ==> n DIV m <= n DIV p
0..0..1..solved at 4
0..0..3..6..14..32..57..102..188..solved at 204
val ( DIV_LE_EXCLUSION ) : thm =
  |- !a b c d. ~(b = 0) /\ b * c < (a + 1) * d ==> c DIV d <= a DIV b
0..0..3..6..22..41..72..122..175..248..386..solved at 407
val ( DIV_EQ_EXCLUSION ) : thm =
  |- b * c < (a + 1) * d /\ a * d < (c + 1) * b ==> a DIV b = c DIV d
val ( MULT_DIV_LE ) : thm =
  |- !m n p. ~(p = 0) ==> m * n DIV p <= (m * n) DIV p
0..0..1..2..6..11..19..32..45..60..solved at 73
val ( DIV_DIV ) : thm =
  |- !m n p. ~(n * p = 0) ==> m DIV n DIV p = m DIV (n * p)
0..0..1..2..6..11..19..32..45..60..solved at 73
0..0..1..3..6..15..34..67..132..266..solved at 510
0..0..1..3..6..13..29..59..110..solved at 162
0..0..1..3..6..15..34..68..130..solved at 182
0..0..1..3..6..15..34..67..132..266..solved at 510
val ( DIV_MOD ) : thm =
  |- !m n p. ~(n * p = 0) ==> (m DIV n) MOD p = (m MOD (n * p)) DIV n
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val ( PRE_ELIM_THM ) : thm =
  |- P (PRE n) <=> (!m. n = SUC m \/ m = 0 /\ n = 0 ==> P m)
0..0..solved at 2
0..0..2..solved at 7
0..0..2..5..solved at 17
0..0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..0..1..solved at 9
0..0..solved at 2
0..0..solved at 2
val ( PRE_ELIM_THM' ) : thm =
  |- P (PRE n) <=> (?m. (n = SUC m \/ m = 0 /\ n = 0) /\ P m)
0..0..1..solved at 5
0..0..1..5..16..32..solved at 40
0..0..1..5..18..37..solved at 48
0..0..solved at 2
0..0..1..solved at 4
val ( SUB_ELIM_THM ) : thm =
  |- P (a - b) <=> (!d. a = b + d \/ a < b /\ d = 0 ==> P d)
0..0..solved at 2
0..0..2..solved at 7
0..0..2..5..solved at 17
0..0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..0..1..solved at 9
0..0..solved at 2
0..0..solved at 2
val ( SUB_ELIM_THM' ) : thm =
  |- P (a - b) <=> (?d. (a = b + d \/ a < b /\ d = 0) /\ P d)
0..0..2..5..14..66..287..1310..solved at 1325
0..0..solved at 3
0..0..2..5..16..72..302..solved at 311
0..0..1..2..3..7..12..17..23..29..35..solved at 84
0..0..1..2..solved at 6
val ( DIVMOD_ELIM_THM ) : thm =
  |- P (m DIV n) (m MOD n) <=>
     (!q r. n = 0 /\ q = 0 /\ r = m \/ m = q * n + r /\ r < n ==> P q r)
0..0..solved at 2
0..0..2..4..7..solved at 21
0..0..2..4..solved at 10
0..0..0..0..1..solved at 7
0..0..solved at 2
0..0..solved at 2
0..0..0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
val ( DIVMOD_ELIM_THM' ) : thm =
  |- P (m DIV n) (m MOD n) <=>
     (?q r. (n = 0 /\ q = 0 /\ r = m \/ m = q * n + r /\ r < n) /\ P q r)
val ( NUM_CANCEL_CONV ) : term -> thm = <fun>
val ( LE_IMP ) : thm -> thm = <fun>
val ( MAX ) : thm = |- !m n. MAX m n = (if m <= n then n else m)
val ( MIN ) : thm = |- !m n. MIN m n = (if m <= n then m else n)
- : unit = ()
val minimal : thm = |- !P. (minimal) P = (@n. P n /\ (!m. m < n ==> ~P m))
val ( MINIMAL ) : thm =
  |- !P. (?n. P n) <=> P ((minimal) P) /\ (!m. m < (minimal) P ==> ~P m)
0..0..solved at 2
0..0..1..2..solved at 6
val ( TRANSITIVE_STEPWISE_LT_EQ ) : thm =
  |- !R. (!x y z. R x y /\ R y z ==> R x z)
         ==> ((!m n. m < n ==> R m n) <=> (!n. R n (SUC n)))
val ( TRANSITIVE_STEPWISE_LT ) : thm =
  |- !R. (!x y z. R x y /\ R y z ==> R x z) /\ (!n. R n (SUC n))
         ==> (!m n. m < n ==> R m n)
0..0..solved at 2
0..0..1..2..solved at 6
val ( TRANSITIVE_STEPWISE_LE_EQ ) : thm =
  |- !R. (!x. R x x) /\ (!x y z. R x y /\ R y z ==> R x z)
         ==> ((!m n. m <= n ==> R m n) <=> (!n. R n (SUC n)))
val ( TRANSITIVE_STEPWISE_LE ) : thm =
  |- !R. (!x. R x x) /\
         (!x y z. R x y /\ R y z ==> R x z) /\
         (!n. R n (SUC n))
         ==> (!m n. m <= n ==> R m n)
- : unit = ()
- : unit = ()
val ( WF ) : thm =
  |- !(<<). WF (<<) <=>
            (!P. (?x. P x) ==> (?x. P x /\ (!y. y << x ==> ~P y)))
0..0..solved at 2
0..0..solved at 2
0..0..0..0..2..5..8..25..57..89..solved at 97
0..0..0..1..5..10..solved at 15
0..0..0..0..2..5..8..25..57..89..solved at 97
val ( WF_EQ ) : thm =
  |- WF (<<) <=> (!P. (?x. P x) <=> (?x. P x /\ (!y. y << x ==> ~P y)))
0..0..solved at 2
0..0..2..10..25..solved at 35
0..0..0..1..4..7..solved at 12
0..0..solved at 2
val ( WF_IND ) : thm =
  |- WF (<<) <=> (!P. (!x. (!y. y << x ==> P y) ==> P x) ==> (!x. P x))
0..0..0..3..6..9..solved at 16
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..3..solved at 7
0..0..solved at 2
0..0..0..solved at 3
val ( WF_DCHAIN ) : thm = |- WF (<<) <=> ~(?s. !n. s (SUC n) << s n)
val ( WF_UREC ) : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
              ==> (!f g. (!x. f x = H f x) /\ (!x. g x = H g x) ==> f = g))
0..0..solved at 3
0..0..2..4..8..solved at 13
0..0..solved at 3
0..0..2..4..8..solved at 13
0..0..solved at 3
0..0..solved at 2
0..0..2..10..25..solved at 35
0..0..solved at 2
val ( WF_UREC_WF ) : thm =
  |- (!H. (!f g x. (!z. z << x ==> (f z <=> g z)) ==> (H f x <=> H g x))
          ==> (!f g. (!x. f x <=> H f x) /\ (!x. g x <=> H g x) ==> f = g))
     ==> WF (<<)
0..0..1..3..11..solved at 20
0..0..1..2..4..12..24..45..78..125..solved at 140
0..0..0..2..7..solved at 12
0..0..1..3..13..29..63..128..226..388..642..977..1459..2097..3319..solved at 3649
val ( WF_REC_INVARIANT ) : thm =
  |- WF (<<)
     ==> (!H S.
              (!f g x.
                   (!z. z << x ==> f z = g z /\ S z (f z))
                   ==> H f x = H g x /\ S x (H f x))
              ==> (?f. !x. f x = H f x))
val ( WF_REC ) : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
              ==> (?f. !x. f x = H f x))
0..0..solved at 2
0..0..solved at 2
0..0..0..solved at 3
0..0..solved at 2
val ( WF_REC_WF ) : thm =
  |- (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
          ==> (?f. !x. f x = H f x))
     ==> WF (<<)
0..0..1..4..15..41..98..211..420..solved at 656
0..0..1..2..5..9..17..33..55..97..162..262..411..solved at 543
val ( WF_EREC ) : thm =
  |- WF (<<)
     ==> (!H. (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x)
              ==> (?!f. !x. f x = H f x))
- : unit = ()
0..0..0..1..4..7..solved at 16
val ( WF_SUBSET ) : thm =
  |- (!x y. x << y ==> x <<< y) /\ WF (<<<) ==> WF (<<)
0..0..2..8..24..54..solved at 69
0..0..1..solved at 6
val ( WF_MEASURE_GEN ) : thm = |- !m. WF (<<) ==> WF (\x x'. m x << m x')
0..0..0..solved at 4
0..0..0..solved at 3
val ( WF_LEX_DEPENDENT ) : thm =
  |- !R S.
         WF R /\ (!a. WF (S a))
         ==> WF (\(r1,s1) (r2,s2). R r1 r2 \/ r1 = r2 /\ S r1 s1 s2)
val ( WF_LEX ) : thm =
  |- !R S.
         WF R /\ WF S
         ==> WF (\(r1,s1) (r2,s2). R r1 r2 \/ r1 = r2 /\ S s1 s2)
val ( WF_POINTWISE ) : thm =
  |- WF (<<) /\ WF (<<<) ==> WF (\(x1,y1) (x2,y2). x1 << x2 /\ y1 <<< y2)
val ( WF_num ) : thm = |- WF (<)
val ( WF_REC_num ) : thm =
  |- !H. (!f g n. (!m. m < n ==> f m = g m) ==> H f n = H g n)
         ==> (?f. !n. f n = H f n)
Warning: inventing type variables
val ( MEASURE ) : thm = |- !m. MEASURE m = (\x y. m x < m y)
val ( WF_MEASURE ) : thm = |- !m. WF (MEASURE m)
Warning: inventing type variables
0..0..2..8..solved at 12
0..0..2..8..solved at 13
val ( MEASURE_LE ) : thm =
  |- (!y. MEASURE m y a ==> MEASURE m y b) <=> m a <= m b
0..0..solved at 2
0..0..0..solved at 3
val ( WF_REFL ) : thm = |- !x. WF (<<) ==> ~(x << x)
val ( WF_FALSE ) : thm = |- WF (\x y. F)
0..0..solved at 2
0..0..3..7..20..54..150..solved at 180
0..0..solved at 2
0..0..2..6..solved at 13
0..0..1..3..solved at 7
0..0..1..3..solved at 8
0..0..2..6..solved at 14
0..0..1..3..solved at 8
0..0..2..4..solved at 11
0..0..5..12..39..solved at 71
0..0..4..10..30..solved at 55
0..0..5..13..38..solved at 66
0..0..4..10..31..solved at 57
0..0..3..6..19..35..60..118..solved at 270
val ( WF_REC_TAIL ) : thm =
  |- !P g h. ?f. !x. f x = (if P x then f (g x) else h x)
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..5..15..51..120..259..solved at 434
0..0..1..5..15..51..120..259..solved at 394
0..0..1..4..13..31..solved at 37
0..0..1..2..solved at 6
0..0..1..5..15..51..120..259..solved at 394
0..0..1..5..15..51..120..259..solved at 434
0..0..1..4..12..28..58..118..solved at 128
0..0..2..9..28..85..206..492..solved at 618
0..0..2..9..28..94..222..491..1165..solved at 1499
0..0..2..9..28..94..223..491..1149..solved at 1472
0..0..2..10..28..82..204..solved at 236
0..0..1..4..11..43..116..246..648..1354..solved at 1611
0..0..solved at 2
0..0..1..5..15..51..120..259..solved at 434
0..0..1..5..15..51..120..259..solved at 394
0..0..1..4..13..31..solved at 37
0..0..2..7..24..55..104..223..440..827..1504..solved at 1616
0..0..2..7..24..65..133..290..574..solved at 904
0..0..2..7..24..65..134..294..583..solved at 913
0..0..2..8..25..52..110..solved at 145
0..0..1..2..7..13..26..50..83..132..216..308..447..705..1020..1530..2268..3184..4455..6310..solved at 8365
0..0..1..3..9..17..43..86..154..300..472..714..1138..1664..2466..4129..6181..solved at 6305
0..0..2..7..20..49..89..185..solved at 215
0..0..1..2..7..17..34..70..132..223..396..solved at 427
0..0..1..2..6..12..23..46..74..119..197..285..418..630..886..solved at 1210
0..0..2..8..24..solved at 32
0..0..2..7..24..61..134..280..548..1144..solved at 1169
0..0..3..solved at 7
val ( WF_REC_TAIL_GENERAL ) : thm =
  |- !P G H.
         WF (<<) /\
         (!f g x.
              (!z. z << x ==> f z = g z)
              ==> (P f x <=> P g x) /\ G f x = G g x /\ H f x = H g x) /\
         (!f g x. (!z. z << x ==> f z = g z) ==> H f x = H g x) /\
         (!f x y. P f x /\ y << G f x ==> y << x)
         ==> (?f. !x. f x = (if P f x then f (G f x) else H f x))
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..solved at 4
Warning: inventing type variables
0..0..0..solved at 3
0..0..solved at 2
val ( WF_INDUCT_TAC ) : term -> (string * thm) list * term -> goalstate =
  <fun>
- : unit = ()
val ( DENUMERAL ) : thm -> thm = <fun>
val ( ARITH_ZERO ) : thm = |- NUMERAL 0 = 0 /\ BIT0 _0 = _0
val ( ARITH_SUC ) : thm =
  |- (!n. SUC (NUMERAL n) = NUMERAL (SUC n)) /\
     SUC _0 = BIT1 _0 /\
     (!n. SUC (BIT0 n) = BIT1 n) /\
     (!n. SUC (BIT1 n) = BIT0 (SUC n))
val ( ARITH_PRE ) : thm =
  |- (!n. PRE (NUMERAL n) = NUMERAL (PRE n)) /\
     PRE _0 = _0 /\
     (!n. PRE (BIT0 n) = (if n = _0 then _0 else BIT1 (PRE n))) /\
     (!n. PRE (BIT1 n) = BIT0 n)
val ( ARITH_ADD ) : thm =
  |- (!m n. NUMERAL m + NUMERAL n = NUMERAL (m + n)) /\
     _0 + _0 = _0 /\
     (!n. _0 + BIT0 n = BIT0 n) /\
     (!n. _0 + BIT1 n = BIT1 n) /\
     (!n. BIT0 n + _0 = BIT0 n) /\
     (!n. BIT1 n + _0 = BIT1 n) /\
     (!m n. BIT0 m + BIT0 n = BIT0 (m + n)) /\
     (!m n. BIT0 m + BIT1 n = BIT1 (m + n)) /\
     (!m n. BIT1 m + BIT0 n = BIT1 (m + n)) /\
     (!m n. BIT1 m + BIT1 n = BIT0 (SUC (m + n)))
val ( ARITH_MULT ) : thm =
  |- (!m n. NUMERAL m * NUMERAL n = NUMERAL (m * n)) /\
     _0 * _0 = _0 /\
     (!n. _0 * BIT0 n = _0) /\
     (!n. _0 * BIT1 n = _0) /\
     (!n. BIT0 n * _0 = _0) /\
     (!n. BIT1 n * _0 = _0) /\
     (!m n. BIT0 m * BIT0 n = BIT0 (BIT0 (m * n))) /\
     (!m n. BIT0 m * BIT1 n = BIT0 m + BIT0 (BIT0 (m * n))) /\
     (!m n. BIT1 m * BIT0 n = BIT0 n + BIT0 (BIT0 (m * n))) /\
     (!m n. BIT1 m * BIT1 n = BIT1 m + BIT0 n + BIT0 (BIT0 (m * n)))
val ( ARITH_EXP ) : thm =
  |- (!m n. NUMERAL m EXP NUMERAL n = NUMERAL (m EXP n)) /\
     _0 EXP _0 = BIT1 _0 /\
     (!m. BIT0 m EXP _0 = BIT1 _0) /\
     (!m. BIT1 m EXP _0 = BIT1 _0) /\
     (!n. _0 EXP BIT0 n = _0 EXP n * _0 EXP n) /\
     (!m n. BIT0 m EXP BIT0 n = BIT0 m EXP n * BIT0 m EXP n) /\
     (!m n. BIT1 m EXP BIT0 n = BIT1 m EXP n * BIT1 m EXP n) /\
     (!n. _0 EXP BIT1 n = _0) /\
     (!m n. BIT0 m EXP BIT1 n = BIT0 m * BIT0 m EXP n * BIT0 m EXP n) /\
     (!m n. BIT1 m EXP BIT1 n = BIT1 m * BIT1 m EXP n * BIT1 m EXP n)
val ( ARITH_EVEN ) : thm =
  |- (!n. EVEN (NUMERAL n) <=> EVEN n) /\
     (EVEN _0 <=> T) /\
     (!n. EVEN (BIT0 n) <=> T) /\
     (!n. EVEN (BIT1 n) <=> F)
val ( ARITH_ODD ) : thm =
  |- (!n. ODD (NUMERAL n) <=> ODD n) /\
     (ODD _0 <=> F) /\
     (!n. ODD (BIT0 n) <=> F) /\
     (!n. ODD (BIT1 n) <=> T)
val ( ARITH_LE ) : thm =
  |- (!m n. NUMERAL m <= NUMERAL n <=> m <= n) /\
     (_0 <= _0 <=> T) /\
     (!n. BIT0 n <= _0 <=> n <= _0) /\
     (!n. BIT1 n <= _0 <=> F) /\
     (!n. _0 <= BIT0 n <=> T) /\
     (!n. _0 <= BIT1 n <=> T) /\
     (!m n. BIT0 m <= BIT0 n <=> m <= n) /\
     (!m n. BIT0 m <= BIT1 n <=> m <= n) /\
     (!m n. BIT1 m <= BIT0 n <=> m < n) /\
     (!m n. BIT1 m <= BIT1 n <=> m <= n)
val ( ARITH_LT ) : thm =
  |- (!m n. NUMERAL m < NUMERAL n <=> m < n) /\
     (_0 < _0 <=> F) /\
     (!n. BIT0 n < _0 <=> F) /\
     (!n. BIT1 n < _0 <=> F) /\
     (!n. _0 < BIT0 n <=> _0 < n) /\
     (!n. _0 < BIT1 n <=> T) /\
     (!m n. BIT0 m < BIT0 n <=> m < n) /\
     (!m n. BIT0 m < BIT1 n <=> m <= n) /\
     (!m n. BIT1 m < BIT0 n <=> m < n) /\
     (!m n. BIT1 m < BIT1 n <=> m < n)
val ( ARITH_GE ) : thm =
  |- (!m n. NUMERAL n >= NUMERAL m <=> n >= m) /\
     _0 >= _0 /\
     (!n. _0 >= BIT0 n <=> _0 >= n) /\
     (!n. ~(_0 >= BIT1 n)) /\
     (!n. BIT0 n >= _0) /\
     (!n. BIT1 n >= _0) /\
     (!m n. BIT0 n >= BIT0 m <=> n >= m) /\
     (!m n. BIT1 n >= BIT0 m <=> n >= m) /\
     (!m n. BIT0 n >= BIT1 m <=> n > m) /\
     (!m n. BIT1 n >= BIT1 m <=> n >= m)
val ( ARITH_GT ) : thm =
  |- (!m n. NUMERAL n > NUMERAL m <=> n > m) /\
     ~(_0 > _0) /\
     (!n. ~(_0 > BIT0 n)) /\
     (!n. ~(_0 > BIT1 n)) /\
     (!n. BIT0 n > _0 <=> n > _0) /\
     (!n. BIT1 n > _0) /\
     (!m n. BIT0 n > BIT0 m <=> n > m) /\
     (!m n. BIT1 n > BIT0 m <=> n >= m) /\
     (!m n. BIT0 n > BIT1 m <=> n > m) /\
     (!m n. BIT1 n > BIT1 m <=> n > m)
val ( ARITH_EQ ) : thm =
  |- (!m n. NUMERAL m = NUMERAL n <=> m = n) /\
     (_0 = _0 <=> T) /\
     (!n. BIT0 n = _0 <=> n = _0) /\
     (!n. BIT1 n = _0 <=> F) /\
     (!n. _0 = BIT0 n <=> _0 = n) /\
     (!n. _0 = BIT1 n <=> F) /\
     (!m n. BIT0 m = BIT0 n <=> m = n) /\
     (!m n. BIT0 m = BIT1 n <=> F) /\
     (!m n. BIT1 m = BIT0 n <=> F) /\
     (!m n. BIT1 m = BIT1 n <=> m = n)
val ( ARITH_SUB ) : thm =
  |- (!m n. NUMERAL m - NUMERAL n = NUMERAL (m - n)) /\
     _0 - _0 = _0 /\
     (!n. _0 - BIT0 n = _0) /\
     (!n. _0 - BIT1 n = _0) /\
     (!n. BIT0 n - _0 = BIT0 n) /\
     (!n. BIT1 n - _0 = BIT1 n) /\
     (!m n. BIT0 m - BIT0 n = BIT0 (m - n)) /\
     (!m n. BIT0 m - BIT1 n = PRE (BIT0 (m - n))) /\
     (!m n. BIT1 m - BIT0 n = (if n <= m then BIT1 (m - n) else _0)) /\
     (!m n. BIT1 m - BIT1 n = BIT0 (m - n))
val ( ARITH ) : thm =
  |- (NUMERAL 0 = 0 /\ BIT0 _0 = _0) /\
     ((!n. SUC (NUMERAL n) = NUMERAL (SUC n)) /\
      SUC _0 = BIT1 _0 /\
      (!n. SUC (BIT0 n) = BIT1 n) /\
      (!n. SUC (BIT1 n) = BIT0 (SUC n))) /\
     ((!n. PRE (NUMERAL n) = NUMERAL (PRE n)) /\
      PRE _0 = _0 /\
      (!n. PRE (BIT0 n) = (if n = _0 then _0 else BIT1 (PRE n))) /\
      (!n. PRE (BIT1 n) = BIT0 n)) /\
     ((!m n. NUMERAL m + NUMERAL n = NUMERAL (m + n)) /\
      _0 + _0 = _0 /\
      (!n. _0 + BIT0 n = BIT0 n) /\
      (!n. _0 + BIT1 n = BIT1 n) /\
      (!n. BIT0 n + _0 = BIT0 n) /\
      (!n. BIT1 n + _0 = BIT1 n) /\
      (!m n. BIT0 m + BIT0 n = BIT0 (m + n)) /\
      (!m n. BIT0 m + BIT1 n = BIT1 (m + n)) /\
      (!m n. BIT1 m + BIT0 n = BIT1 (m + n)) /\
      (!m n. BIT1 m + BIT1 n = BIT0 (SUC (m + n)))) /\
     ((!m n. NUMERAL m * NUMERAL n = NUMERAL (m * n)) /\
      _0 * _0 = _0 /\
      (!n. _0 * BIT0 n = _0) /\
      (!n. _0 * BIT1 n = _0) /\
      (!n. BIT0 n * _0 = _0) /\
      (!n. BIT1 n * _0 = _0) /\
      (!m n. BIT0 m * BIT0 n = BIT0 (BIT0 (m * n))) /\
      (!m n. BIT0 m * BIT1 n = BIT0 m + BIT0 (BIT0 (m * n))) /\
      (!m n. BIT1 m * BIT0 n = BIT0 n + BIT0 (BIT0 (m * n))) /\
      (!m n. BIT1 m * BIT1 n = BIT1 m + BIT0 n + BIT0 (BIT0 (m * n)))) /\
     ((!m n. NUMERAL m EXP NUMERAL n = NUMERAL (m EXP n)) /\
      _0 EXP _0 = BIT1 _0 /\
      (!m. BIT0 m EXP _0 = BIT1 _0) /\
      (!m. BIT1 m EXP _0 = BIT1 _0) /\
      (!n. _0 EXP BIT0 n = _0 EXP n * _0 EXP n) /\
      (!m n. BIT0 m EXP BIT0 n = BIT0 m EXP n * BIT0 m EXP n) /\
      (!m n. BIT1 m EXP BIT0 n = BIT1 m EXP n * BIT1 m EXP n) /\
      (!n. _0 EXP BIT1 n = _0) /\
      (!m n. BIT0 m EXP BIT1 n = BIT0 m * BIT0 m EXP n * BIT0 m EXP n) /\
      (!m n. BIT1 m EXP BIT1 n = BIT1 m * BIT1 m EXP n * BIT1 m EXP n)) /\
     ((!n. EVEN (NUMERAL n) <=> EVEN n) /\
      (EVEN _0 <=> T) /\
      (!n. EVEN (BIT0 n) <=> T) /\
      (!n. EVEN (BIT1 n) <=> F)) /\
     ((!n. ODD (NUMERAL n) <=> ODD n) /\
      (ODD _0 <=> F) /\
      (!n. ODD (BIT0 n) <=> F) /\
      (!n. ODD (BIT1 n) <=> T)) /\
     ((!m n. NUMERAL m = NUMERAL n <=> m = n) /\
      (_0 = _0 <=> T) /\
      (!n. BIT0 n = _0 <=> n = _0) /\
      (!n. BIT1 n = _0 <=> F) /\
      (!n. _0 = BIT0 n <=> _0 = n) /\
      (!n. _0 = BIT1 n <=> F) /\
      (!m n. BIT0 m = BIT0 n <=> m = n) /\
      (!m n. BIT0 m = BIT1 n <=> F) /\
      (!m n. BIT1 m = BIT0 n <=> F) /\
      (!m n. BIT1 m = BIT1 n <=> m = n)) /\
     ((!m n. NUMERAL m <= NUMERAL n <=> m <= n) /\
      (_0 <= _0 <=> T) /\
      (!n. BIT0 n <= _0 <=> n <= _0) /\
      (!n. BIT1 n <= _0 <=> F) /\
      (!n. _0 <= BIT0 n <=> T) /\
      (!n. _0 <= BIT1 n <=> T) /\
      (!m n. BIT0 m <= BIT0 n <=> m <= n) /\
      (!m n. BIT0 m <= BIT1 n <=> m <= n) /\
      (!m n. BIT1 m <= BIT0 n <=> m < n) /\
      (!m n. BIT1 m <= BIT1 n <=> m <= n)) /\
     ((!m n. NUMERAL m < NUMERAL n <=> m < n) /\
      (_0 < _0 <=> F) /\
      (!n. BIT0 n < _0 <=> F) /\
      (!n. BIT1 n < _0 <=> F) /\
      (!n. _0 < BIT0 n <=> _0 < n) /\
      (!n. _0 < BIT1 n <=> T) /\
      (!m n. BIT0 m < BIT0 n <=> m < n) /\
      (!m n. BIT0 m < BIT1 n <=> m <= n) /\
      (!m n. BIT1 m < BIT0 n <=> m < n) /\
      (!m n. BIT1 m < BIT1 n <=> m < n)) /\
     ((!m n. NUMERAL n >= NUMERAL m <=> n >= m) /\
      _0 >= _0 /\
      (!n. _0 >= BIT0 n <=> _0 >= n) /\
      (!n. ~(_0 >= BIT1 n)) /\
      (!n. BIT0 n >= _0) /\
      (!n. BIT1 n >= _0) /\
      (!m n. BIT0 n >= BIT0 m <=> n >= m) /\
      (!m n. BIT1 n >= BIT0 m <=> n >= m) /\
      (!m n. BIT0 n >= BIT1 m <=> n > m) /\
      (!m n. BIT1 n >= BIT1 m <=> n >= m)) /\
     ((!m n. NUMERAL n > NUMERAL m <=> n > m) /\
      ~(_0 > _0) /\
      (!n. ~(_0 > BIT0 n)) /\
      (!n. ~(_0 > BIT1 n)) /\
      (!n. BIT0 n > _0 <=> n > _0) /\
      (!n. BIT1 n > _0) /\
      (!m n. BIT0 n > BIT0 m <=> n > m) /\
      (!m n. BIT1 n > BIT0 m <=> n >= m) /\
      (!m n. BIT0 n > BIT1 m <=> n > m) /\
      (!m n. BIT1 n > BIT1 m <=> n > m)) /\
     (!m n. NUMERAL m - NUMERAL n = NUMERAL (m - n)) /\
     _0 - _0 = _0 /\
     (!n. _0 - BIT0 n = _0) /\
     (!n. _0 - BIT1 n = _0) /\
     (!n. BIT0 n - _0 = BIT0 n) /\
     (!n. BIT1 n - _0 = BIT1 n) /\
     (!m n. BIT0 m - BIT0 n = BIT0 (m - n)) /\
     (!m n. BIT0 m - BIT1 n = PRE (BIT0 (m - n))) /\
     (!m n. BIT1 m - BIT0 n = (if n <= m then BIT1 (m - n) else _0)) /\
     (!m n. BIT1 m - BIT1 n = BIT0 (m - n))
val ( NUM_EQ_CONV ) : conv = <fun>
val ( NUM_LE_CONV ) : conv = <fun>
val ( NUM_LT_CONV ) : conv = <fun>
val ( NUM_GE_CONV ) : conv = <fun>
val ( NUM_GT_CONV ) : conv = <fun>
val ( NUM_EVEN_CONV ) : conv = <fun>
val ( NUM_ODD_CONV ) : conv = <fun>
File "/home/student/OCaml/hol_light (gzip)/calc_num.ml", line 222, characters 8-29:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/calc_num.ml", line 229, characters 8-56:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/calc_num.ml", line 239, characters 8-56:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( NUM_SUC_CONV ) : term -> thm = <fun>
val ( NUM_ADD_CONV ) : term -> thm = <fun>
val ( NUM_MULT_CONV ) : conv = <fun>
val ( NUM_EXP_CONV ) : term -> thm = <fun>
val ( NUM_PRE_CONV ) : term -> thm = <fun>
val ( NUM_SUB_CONV ) : term -> thm = <fun>
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val ( NUM_DIV_CONV ) : term -> thm = <fun>
val ( NUM_MOD_CONV ) : term -> thm = <fun>
val ( NUM_FACT_CONV ) : term -> thm = <fun>
val ( NUM_MAX_CONV ) : conv = <fun>
val ( NUM_MIN_CONV ) : conv = <fun>
val ( NUM_REL_CONV ) : term -> thm = <fun>
val ( NUM_RED_CONV ) : term -> thm = <fun>
val ( NUM_REDUCE_CONV ) : conv = <fun>
val ( NUM_REDUCE_TAC ) : tactic = <fun>
val num_CONV : term -> thm = <fun>
0..0..1..solved at 4
0..0..1..solved at 5
0..0..solved at 2
0..0..1..solved at 4
val ( EXPAND_CASES_CONV ) : conv = <fun>
- : unit = ()
File "/home/student/OCaml/hol_light (gzip)/normalizer.ml", line 94, characters 5-371:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
0..0..solved at 2
0..0..1..2..solved at 9
0..0..1..2..9..20..73..154..solved at 284
0..0..1..2..solved at 8
0..0..solved at 2
0..0..1..2..solved at 8
0..0..1..2..9..20..73..154..solved at 229
0..0..1..2..8..18..65..140..472..992..solved at 2047
0..0..0..1..2..3..4..5..6..solved at 20
0..0..1..2..solved at 6
0..0..solved at 2
0..0..solved at 2
val ( SEMIRING_NORMALIZERS_CONV ) :
  thm ->
  thm ->
  (term -> bool) * (term -> thm) * (term -> thm) * (term -> thm) ->
  (term -> term -> bool) ->
  (term -> thm) * (term -> thm) * (term -> thm) * (term -> thm) *
  (term -> thm) * (term -> thm) = <fun>
val ( NUM_NORMALIZE_CONV ) : term -> thm = <fun>
- : unit = ()
type history =
    Start of int
  | Mmul of (num * int list) * history
  | Add of history * history
File "/home/student/OCaml/hol_light (gzip)/grobner.ml", line 519, characters 14-28:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(_, [])
val ( RING_AND_IDEAL_CONV ) :
  (term -> num) * (num -> term) * conv * term * term * term * term * 
  term * term * term * thm * thm * (term -> thm) ->
  (term -> thm) * (term list -> term -> term list) = <fun>
val ( RING ) :
  (term -> num) * (num -> term) * conv * term * term * term * term * 
  term * term * term * thm * thm * (term -> thm) -> term -> thm = <fun>
val ideal_cofactors :
  (term -> num) * (num -> term) * conv * term * term * term * term * 
  term * term * term * thm * thm * (term -> thm) ->
  term list -> term -> term list = <fun>
val ( NUM_SIMPLIFY_CONV ) : conv = <fun>
0..0..2..4..10..20..52..96..204..356..638..1042..1916..3036..solved at 4498
0..0..1..2..7..16..42..78..161..285..685..solved at 954
0..0..1..2..7..16..42..78..160..281..solved at 672
0..0..2..4..11..21..59..116..239..426..800..1336..solved at 1840
0..0..1..2..7..16..45..86..174..312..724..solved at 772
0..0..1..2..7..16..44..84..168..solved at 185
0..0..2..4..11..21..59..116..239..426..solved at 540
0..0..1..2..7..18..46..solved at 77
0..0..1..2..7..18..47..92..185..solved at 281
0..0..2..4..12..22..solved at 41
0..0..1..2..7..solved at 21
0..0..1..2..7..solved at 18
val ( NUM_RING ) : term -> thm = <fun>
- : unit = ()
val ( INJ_INVERSE2 ) : thm =
  |- !P. (!x1 y1 x2 y2. P x1 y1 = P x2 y2 <=> x1 = x2 /\ y1 = y2)
         ==> (?X Y. !x y. X (P x y) = x /\ Y (P x y) = y)
val ( NUMPAIR ) : thm = |- !x y. NUMPAIR x y = 2 EXP x * (2 * y + 1)
val ( NUMPAIR_INJ_LEMMA ) : thm =
  |- !x1 y1 x2 y2. NUMPAIR x1 y1 = NUMPAIR x2 y2 ==> x1 = x2
val ( NUMPAIR_INJ ) : thm =
  |- !x1 y1 x2 y2. NUMPAIR x1 y1 = NUMPAIR x2 y2 <=> x1 = x2 /\ y1 = y2
val ( NUMPAIR_DEST ) : thm =
  |- !x y. NUMFST (NUMPAIR x y) = x /\ NUMSND (NUMPAIR x y) = y
val ( NUMSUM ) : thm =
  |- !b x. NUMSUM b x = (if b then SUC (2 * x) else 2 * x)
val ( NUMSUM_INJ ) : thm =
  |- !b1 x1 b2 x2. NUMSUM b1 x1 = NUMSUM b2 x2 <=> (b1 <=> b2) /\ x1 = x2
val ( NUMSUM_DEST ) : thm =
  |- !x y. (NUMLEFT (NUMSUM x y) <=> x) /\ NUMRIGHT (NUMSUM x y) = y
val ( INJN ) : thm = |- !m. INJN m = (\n a. n = m)
val ( INJN_INJ ) : thm = |- !n1 n2. INJN n1 = INJN n2 <=> n1 = n2
val ( INJA ) : thm = |- !a. INJA a = (\n b. b = a)
val ( INJA_INJ ) : thm = |- !a1 a2. INJA a1 = INJA a2 <=> a1 = a2
val ( INJF ) : thm = |- !f. INJF f = (\n. f (NUMFST n) (NUMSND n))
val ( INJF_INJ ) : thm = |- !f1 f2. INJF f1 = INJF f2 <=> f1 = f2
val ( INJP ) : thm =
  |- !f1 f2.
         INJP f1 f2 =
         (\n a. if NUMLEFT n then f1 (NUMRIGHT n) a else f2 (NUMRIGHT n) a)
val ( INJP_INJ ) : thm =
  |- !f1 f1' f2 f2'. INJP f1 f2 = INJP f1' f2' <=> f1 = f1' /\ f2 = f2'
val ( ZCONSTR ) : thm =
  |- !c i r. ZCONSTR c i r = INJP (INJN (SUC c)) (INJP (INJA i) (INJF r))
val ( ZBOT ) : thm = |- ZBOT = INJP (INJN 0) (@z. T)
val ( ZCONSTR_ZBOT ) : thm = |- !c i r. ~(ZCONSTR c i r = ZBOT)
val ( ZRECSPACE_RULES ) : thm =
  |- ZRECSPACE ZBOT /\
     (!c i r. (!n. ZRECSPACE (r n)) ==> ZRECSPACE (ZCONSTR c i r))
val ( ZRECSPACE_INDUCT ) : thm =
  |- !ZRECSPACE'. ZRECSPACE' ZBOT /\
                  (!c i r.
                       (!n. ZRECSPACE' (r n)) ==> ZRECSPACE' (ZCONSTR c i r))
                  ==> (!a. ZRECSPACE a ==> ZRECSPACE' a)
val ( ZRECSPACE_CASES ) : thm =
  |- !a. ZRECSPACE a <=>
         a = ZBOT \/ (?c i r. a = ZCONSTR c i r /\ (!n. ZRECSPACE (r n)))
val recspace_tydef : thm * thm =
  (|- _mk_rec (_dest_rec a) = a,
   |- ZRECSPACE r <=> _dest_rec (_mk_rec r) = r)
val ( BOTTOM ) : thm = |- BOTTOM = _mk_rec ZBOT
val ( CONSTR ) : thm =
  |- !c i r. CONSTR c i r = _mk_rec (ZCONSTR c i (\n. _dest_rec (r n)))
val ( MK_REC_INJ ) : thm =
  |- !x y. _mk_rec x = _mk_rec y ==> ZRECSPACE x /\ ZRECSPACE y ==> x = y
val ( DEST_REC_INJ ) : thm = |- !x y. _dest_rec x = _dest_rec y <=> x = y
val ( CONSTR_BOT ) : thm = |- !c i r. ~(CONSTR c i r = BOTTOM)
val ( CONSTR_INJ ) : thm =
  |- !c1 i1 r1 c2 i2 r2.
         CONSTR c1 i1 r1 = CONSTR c2 i2 r2 <=> c1 = c2 /\ i1 = i2 /\ r1 = r2
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( CONSTR_IND ) : thm =
  |- !P. P BOTTOM /\ (!c i r. (!n. P (r n)) ==> P (CONSTR c i r))
         ==> (!x. P x)
val ( CONSTR_REC ) : thm =
  |- !Fn. ?f. !c i r. f (CONSTR c i r) = Fn c i r (\n. f (r n))
val ( FCONS ) : thm =
  |- (!a f. FCONS a f 0 = a) /\ (!a f n. FCONS a f (SUC n) = f n)
val ( FCONS_UNDO ) : thm = |- !f. f = FCONS (f 0) (f o SUC)
val ( FNIL ) : thm = |- !n. FNIL n = (@x. T)
val define_type_raw :
  (hol_type * (string * hol_type list) list) list -> thm * thm = <fun>
val parse_inductive_type_specification :
  string -> (hol_type * (string * hol_type list) list) list = <fun>
val sum_INDUCT : thm =
  |- !P. (!a. P (INL a)) /\ (!a. P (INR a)) ==> (!x. P x)
val sum_RECURSION : thm =
  |- !INL' INR'. ?fn. (!a. fn (INL a) = INL' a) /\ (!a. fn (INR a) = INR' a)
val ( OUTL ) : thm = |- OUTL (INL x) = x
val ( OUTR ) : thm = |- OUTR (INR y) = y
File "/home/student/OCaml/hol_light (gzip)/ind-types.ml", line 795, characters 12-23:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(_, [])
File "/home/student/OCaml/hol_light (gzip)/ind-types.ml", line 806, characters 12-23:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(_, [])
val define_type_raw :
  (hol_type * (string * hol_type list) list) list -> thm * thm = <fun>
val option_INDUCT : thm = |- !P. P NONE /\ (!a. P (SOME a)) ==> (!x. P x)
val option_RECURSION : thm =
  |- !NONE' SOME'. ?fn. fn NONE = NONE' /\ (!a. fn (SOME a) = SOME' a)
val list_INDUCT : thm =
  |- !P. P [] /\ (!a0 a1. P a1 ==> P (CONS a0 a1)) ==> (!x. P x)
val list_RECURSION : thm =
  |- !NIL' CONS'.
         ?fn. fn [] = NIL' /\ (!a0 a1. fn (CONS a0 a1) = CONS' a0 a1 (fn a1))
val prove_constructors_injective : thm -> thm = <fun>
val prove_constructors_distinct : thm -> thm = <fun>
val prove_cases_thm : thm -> thm = <fun>
- : unit = ()
val basic_rectype_net : '_a net ref = {contents = Netnode ([], [])}
val distinctness_store : (string * thm) list ref =
  {contents = [("bool", |- (T <=> F) <=> F)]}
val injectivity_store : '_a list ref = {contents = []}
val extend_rectype_net : string * ('a * 'b * thm) -> unit = <fun>
- : unit = ()
val distinctness : string -> thm = <fun>
val injectivity : string -> thm = <fun>
val cases : string -> thm = <fun>
val ( ISO ) : thm =
  |- !g f. ISO f g <=> (!x. f (g x) = x) /\ (!y. g (f y) = y)
val ( ISO_REFL ) : thm = |- ISO (\x. x) (\x. x)
0..0..1..2..6..13..30..solved at 70
0..0..1..2..6..13..30..solved at 70
val ( ISO_FUN ) : thm =
  |- ISO f f' /\ ISO g g' ==> ISO (\h a'. g (h (f' a'))) (\h a. g' (h (f a)))
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..6..11..solved at 22
0..0..solved at 2
0..0..solved at 2
0..0..1..2..solved at 6
val ( ISO_USAGE ) : thm =
  |- ISO f g
     ==> (!P. (!x. P x) <=> (!x. P (g x))) /\
         (!P. (?x. P x) <=> (?x. P (g x))) /\
         (!a b. a = g b <=> f a = b)
Warning: inventing type variables
val define_type_raw :
  (hol_type * (string * hol_type list) list) list -> thm * thm = <fun>
val the_inductive_types : (string * (thm * thm)) list ref =
  {contents =
    [("list = NIL | CONS A list",
      (|- !P. P [] /\ (!a0 a1. P a1 ==> P (CONS a0 a1)) ==> (!x. P x),
       |- !NIL' CONS'.
              ?fn. fn [] = NIL' /\
                   (!a0 a1. fn (CONS a0 a1) = CONS' a0 a1 (fn a1))));
     ("option = NONE | SOME A",
      (|- !P. P NONE /\ (!a. P (SOME a)) ==> (!x. P x),
       |- !NONE' SOME'. ?fn. fn NONE = NONE' /\ (!a. fn (SOME a) = SOME' a)));
     ("sum = INL A | INR B",
      (|- !P. (!a. P (INL a)) /\ (!a. P (INR a)) ==> (!x. P x),
       |- !INL' INR'.
              ?fn. (!a. fn (INL a) = INL' a) /\ (!a. fn (INR a) = INR' a)))]}
val define_type : string -> thm * thm = <fun>
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..solved at 5
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
Warning: inventing type variables
Warning: inventing type variables
Warning: inventing type variables
val ( UNWIND_CONV ) : conv = <fun>
val ( MATCH_CONV ) : conv = <fun>
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..solved at 2
0..0..solved at 2
val ( FORALL_UNWIND_CONV ) : conv = <fun>
- : unit = ()
val ( LIST_INDUCT_TAC ) : tactic = <fun>
val ( HD ) : thm = |- HD (CONS h t) = h
val ( TL ) : thm = |- TL (CONS h t) = t
val ( APPEND ) : thm =
  |- (!l. APPEND [] l = l) /\
     (!h t l. APPEND (CONS h t) l = CONS h (APPEND t l))
val ( REVERSE ) : thm =
  |- REVERSE [] = [] /\ REVERSE (CONS x l) = APPEND (REVERSE l) [x]
val ( LENGTH ) : thm =
  |- LENGTH [] = 0 /\ (!h t. LENGTH (CONS h t) = SUC (LENGTH t))
val ( MAP ) : thm =
  |- (!f. MAP f [] = []) /\ (!f h t. MAP f (CONS h t) = CONS (f h) (MAP f t))
val ( LAST ) : thm = |- LAST (CONS h t) = (if t = [] then h else LAST t)
Warning: inventing type variables
val ( REPLICATE ) : thm =
  |- REPLICATE 0 x = [] /\ REPLICATE (SUC n) x = CONS x (REPLICATE n x)
Warning: inventing type variables
val ( NULL ) : thm = |- (NULL [] <=> T) /\ (NULL (CONS h t) <=> F)
Warning: inventing type variables
val ( ALL ) : thm =
  |- (ALL P [] <=> T) /\ (ALL P (CONS h t) <=> P h /\ ALL P t)
Warning: inventing type variables
val ( EX ) : thm = |- (EX P [] <=> F) /\ (EX P (CONS h t) <=> P h \/ EX P t)
Warning: inventing type variables
val ( ITLIST ) : thm =
  |- ITLIST f [] b = b /\ ITLIST f (CONS h t) b = f h (ITLIST f t b)
Warning: inventing type variables
val ( MEM ) : thm =
  |- (MEM x [] <=> F) /\ (MEM x (CONS h t) <=> x = h \/ MEM x t)
Warning: inventing type variables
val ( ALL2_DEF ) : thm =
  |- (ALL2 P [] l2 <=> l2 = []) /\
     (ALL2 P (CONS h1 t1) l2 <=>
      (if l2 = [] then F else P h1 (HD l2) /\ ALL2 P t1 (TL l2)))
Warning: inventing type variables
val ( ALL2 ) : thm =
  |- (ALL2 P [] [] <=> T) /\
     (ALL2 P (CONS h1 t1) [] <=> F) /\
     (ALL2 P [] (CONS h2 t2) <=> F) /\
     (ALL2 P (CONS h1 t1) (CONS h2 t2) <=> P h1 h2 /\ ALL2 P t1 t2)
Warning: inventing type variables
val ( MAP2_DEF ) : thm =
  |- MAP2 f [] l = [] /\
     MAP2 f (CONS h1 t1) l = CONS (f h1 (HD l)) (MAP2 f t1 (TL l))
Warning: inventing type variables
val ( MAP2 ) : thm =
  |- MAP2 f [] [] = [] /\
     MAP2 f (CONS h1 t1) (CONS h2 t2) = CONS (f h1 h2) (MAP2 f t1 t2)
Warning: inventing type variables
val ( EL ) : thm = |- EL 0 l = HD l /\ EL (SUC n) l = EL n (TL l)
Warning: inventing type variables
val ( FILTER ) : thm =
  |- FILTER P [] = [] /\
     FILTER P (CONS h t) = (if P h then CONS h (FILTER P t) else FILTER P t)
Warning: inventing type variables
val ( ASSOC ) : thm =
  |- ASSOC a (CONS h t) = (if FST h = a then SND h else ASSOC a t)
Warning: inventing type variables
val ( ITLIST2_DEF ) : thm =
  |- ITLIST2 f [] l2 b = b /\
     ITLIST2 f (CONS h1 t1) l2 b = f h1 (HD l2) (ITLIST2 f t1 (TL l2) b)
Warning: inventing type variables
val ( ITLIST2 ) : thm =
  |- ITLIST2 f [] [] b = b /\
     ITLIST2 f (CONS h1 t1) (CONS h2 t2) b = f h1 h2 (ITLIST2 f t1 t2 b)
Warning: inventing type variables
val ( ZIP_DEF ) : thm =
  |- ZIP [] l2 = [] /\ ZIP (CONS h1 t1) l2 = CONS (h1,HD l2) (ZIP t1 (TL l2))
Warning: inventing type variables
val ( ZIP ) : thm =
  |- ZIP [] [] = [] /\
     ZIP (CONS h1 t1) (CONS h2 t2) = CONS (h1,h2) (ZIP t1 t2)
val ( NOT_CONS_NIL ) : thm = |- !h t. ~(CONS h t = [])
val ( LAST_CLAUSES ) : thm =
  |- LAST [h] = h /\ LAST (CONS h (CONS k t)) = LAST (CONS k t)
val ( APPEND_NIL ) : thm = |- !l. APPEND l [] = l
val ( APPEND_ASSOC ) : thm =
  |- !l m n. APPEND l (APPEND m n) = APPEND (APPEND l m) n
val ( REVERSE_APPEND ) : thm =
  |- !l m. REVERSE (APPEND l m) = APPEND (REVERSE m) (REVERSE l)
val ( REVERSE_REVERSE ) : thm = |- !l. REVERSE (REVERSE l) = l
val ( CONS_11 ) : thm =
  |- !h1 h2 t1 t2. CONS h1 t1 = CONS h2 t2 <=> h1 = h2 /\ t1 = t2
0..0..solved at 2
0..0..solved at 2
val list_CASES : thm = |- !l. l = [] \/ (?h t. l = CONS h t)
val ( LENGTH_APPEND ) : thm =
  |- !l m. LENGTH (APPEND l m) = LENGTH l + LENGTH m
val ( MAP_APPEND ) : thm =
  |- !f l1 l2. MAP f (APPEND l1 l2) = APPEND (MAP f l1) (MAP f l2)
val ( LENGTH_MAP ) : thm = |- !l f. LENGTH (MAP f l) = LENGTH l
val ( LENGTH_EQ_NIL ) : thm = |- !l. LENGTH l = 0 <=> l = []
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..solved at 2
val ( LENGTH_EQ_CONS ) : thm =
  |- !l n. LENGTH l = SUC n <=> (?h t. l = CONS h t /\ LENGTH t = n)
val ( MAP_o ) : thm = |- !f g l. MAP (g o f) l = MAP g (MAP f l)
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..6..12..solved at 26
val ( MAP_EQ ) : thm = |- !f g l. ALL (\x. f x = g x) l ==> MAP f l = MAP g l
Warning: inventing type variables
0..0..2..4..solved at 9
0..0..2..4..solved at 9
0..0..solved at 3
0..0..solved at 3
0..0..1..2..solved at 7
0..0..solved at 2
val ( ALL_IMP ) : thm =
  |- !P Q l. (!x. MEM x l /\ P x ==> Q x) /\ ALL P l ==> ALL Q l
Warning: inventing type variables
val ( NOT_EX ) : thm = |- !P l. ~EX P l <=> ALL (\x. ~P x) l
Warning: inventing type variables
val ( NOT_ALL ) : thm = |- !P l. ~ALL P l <=> EX (\x. ~P x) l
Warning: inventing type variables
val ( ALL_MAP ) : thm = |- !P f l. ALL P (MAP f l) <=> ALL (P o f) l
Warning: inventing type variables
val ( ALL_T ) : thm = |- !l. ALL (\x. T) l
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 6
0..0..1..solved at 4
val ( MAP_EQ_ALL2 ) : thm =
  |- !l m. ALL2 (\x y. f x = f y) l m ==> MAP f l = MAP f m
Warning: inventing type variables
val ( ALL2_MAP ) : thm =
  |- !P f l. ALL2 P (MAP f l) l <=> ALL (\a. P (f a) a) l
Warning: inventing type variables
val ( MAP_EQ_DEGEN ) : thm = |- !l f. ALL (\x. f x = x) l ==> MAP f l = l
Warning: inventing type variables
val ( ALL2_AND_RIGHT ) : thm =
  |- !l m P Q. ALL2 (\x y. P x /\ Q x y) l m <=> ALL P l /\ ALL2 Q l m
Warning: inventing type variables
val ( ITLIST_APPEND ) : thm =
  |- !f a l1 l2. ITLIST f (APPEND l1 l2) a = ITLIST f l1 (ITLIST f l2 a)
Warning: inventing type variables
val ( ITLIST_EXTRA ) : thm =
  |- !l. ITLIST f (APPEND l [a]) b = ITLIST f l (f a b)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( ALL_MP ) : thm =
  |- !P Q l. ALL (\x. P x ==> Q x) l /\ ALL P l ==> ALL Q l
Warning: inventing type variables
val ( AND_ALL ) : thm = |- !l. ALL P l /\ ALL Q l <=> ALL (\x. P x /\ Q x) l
Warning: inventing type variables
0..0..3..6..solved at 10
0..0..3..6..solved at 13
0..0..solved at 2
0..0..3..6..solved at 10
0..0..solved at 2
0..0..solved at 2
val ( EX_IMP ) : thm =
  |- !P Q l. (!x. MEM x l /\ P x ==> Q x) /\ EX P l ==> EX Q l
Warning: inventing type variables
0..0..1..solved at 5
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..3..solved at 7
0..0..3..solved at 7
0..0..solved at 2
0..0..solved at 4
val ( ALL_MEM ) : thm = |- !P l. (!x. MEM x l ==> P x) <=> ALL P l
Warning: inventing type variables
val ( LENGTH_REPLICATE ) : thm = |- !n x. LENGTH (REPLICATE n x) = n
Warning: inventing type variables
val ( EX_MAP ) : thm = |- !P f l. EX P (MAP f l) <=> EX (P o f) l
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 5
0..0..solved at 3
0..0..solved at 4
val ( EXISTS_EX ) : thm = |- !P l. (?x. EX (P x) l) <=> EX (\s. ?x. P x s) l
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 2
0..0..solved at 3
val ( FORALL_ALL ) : thm =
  |- !P l. (!x. ALL (P x) l) <=> ALL (\s. !x. P x s) l
Warning: inventing type variables
val ( MEM_APPEND ) : thm =
  |- !x l1 l2. MEM x (APPEND l1 l2) <=> MEM x l1 \/ MEM x l2
Warning: inventing type variables
0..0..0..solved at 4
0..0..0..solved at 3
0..0..solved at 2
0..0..1..solved at 6
val ( MEM_MAP ) : thm =
  |- !f y l. MEM y (MAP f l) <=> (?x. MEM x l /\ y = f x)
Warning: inventing type variables
val ( FILTER_APPEND ) : thm =
  |- !P l1 l2. FILTER P (APPEND l1 l2) = APPEND (FILTER P l1) (FILTER P l2)
Warning: inventing type variables
val ( FILTER_MAP ) : thm =
  |- !P f l. FILTER P (MAP f l) = MAP f (FILTER (P o f) l)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( MEM_FILTER ) : thm = |- !P l x. MEM x (FILTER P l) <=> P x /\ MEM x l
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..0..solved at 4
0..0..0..solved at 3
0..0..solved at 3
0..0..3..solved at 9
0..0..1..solved at 7
0..0..solved at 2
val ( EX_MEM ) : thm = |- !P l. (?x. P x /\ MEM x l) <=> EX P l
Warning: inventing type variables
val ( MAP_FST_ZIP ) : thm =
  |- !l1 l2. LENGTH l1 = LENGTH l2 ==> MAP FST (ZIP l1 l2) = l1
Warning: inventing type variables
val ( MAP_SND_ZIP ) : thm =
  |- !l1 l2. LENGTH l1 = LENGTH l2 ==> MAP SND (ZIP l1 l2) = l2
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( MEM_ASSOC ) : thm = |- !l x. MEM (x,ASSOC x l) l <=> MEM x (MAP FST l)
Warning: inventing type variables
val ( ALL_APPEND ) : thm =
  |- !P l1 l2. ALL P (APPEND l1 l2) <=> ALL P l1 /\ ALL P l2
Warning: inventing type variables
val ( MEM_EL ) : thm = |- !l n. n < LENGTH l ==> MEM (EL n l) l
0..0..2..4..10..20..40..solved at 67
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
val ( MEM_EXISTS_EL ) : thm =
  |- !l x. MEM x l <=> (?i. i < LENGTH l /\ x = EL i l)
Warning: inventing type variables
val ( ALL2_MAP2 ) : thm =
  |- !l m. ALL2 P (MAP f l) (MAP g m) <=> ALL2 (\x y. P (f x) (g y)) l m
Warning: inventing type variables
val ( AND_ALL2 ) : thm =
  |- !P Q l m. ALL2 P l m /\ ALL2 Q l m <=> ALL2 (\x y. P x y /\ Q x y) l m
Warning: inventing type variables
val ( ALL2_ALL ) : thm = |- !P l. ALL2 P l l <=> ALL (\x. P x x) l
Warning: inventing type variables
val ( APPEND_EQ_NIL ) : thm = |- !l m. APPEND l m = [] <=> l = [] /\ m = []
Warning: inventing type variables
val ( LENGTH_MAP2 ) : thm =
  |- !f l m. LENGTH l = LENGTH m ==> LENGTH (MAP2 f l m) = LENGTH m
val mk_cons : term -> term -> term = <fun>
val mk_list : term list * hol_type -> term = <fun>
val mk_flist : term list -> term = <fun>
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
val ( MONO_ALL ) : thm = |- (!x. P x ==> Q x) ==> ALL P l ==> ALL Q l
0..0..2..solved at 5
0..0..2..solved at 5
val ( MONO_ALL2 ) : thm =
  |- (!x y. P x y ==> Q x y) ==> ALL2 P l l' ==> ALL2 Q l l'
- : unit = ()
val ( LIST_CONV ) : conv -> conv = <fun>
val char_INDUCT : thm =
  |- !P. (!a0 a1 a2 a3 a4 a5 a6 a7. P (ASCII a0 a1 a2 a3 a4 a5 a6 a7))
         ==> (!x. P x)
val char_RECURSION : thm =
  |- !f. ?fn. !a0 a1 a2 a3 a4 a5 a6 a7.
                  fn (ASCII a0 a1 a2 a3 a4 a5 a6 a7) =
                  f a0 a1 a2 a3 a4 a5 a6 a7
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val prioritize_num : unit -> unit = <fun>
val dist : thm = |- !n m. dist (m,n) = m - n + n - m
val ( DIST_REFL ) : thm = |- !n. dist (n,n) = 0
val ( DIST_LZERO ) : thm = |- !n. dist (0,n) = n
val ( DIST_RZERO ) : thm = |- !n. dist (n,0) = n
val ( DIST_SYM ) : thm = |- !m n. dist (m,n) = dist (n,m)
val ( DIST_LADD ) : thm = |- !m p n. dist (m + n,m + p) = dist (n,p)
val ( DIST_RADD ) : thm = |- !m p n. dist (m + p,n + p) = dist (m,n)
val ( DIST_LADD_0 ) : thm = |- !m n. dist (m + n,m) = n
val ( DIST_RADD_0 ) : thm = |- !m n. dist (m,m + n) = n
val ( DIST_LMUL ) : thm = |- !m n p. m * dist (n,p) = dist (m * n,m * p)
val ( DIST_RMUL ) : thm = |- !m n p. dist (m,n) * p = dist (m * p,n * p)
val ( DIST_EQ_0 ) : thm = |- !m n. dist (m,n) = 0 <=> m = n
val ( DIST_ELIM_THM ) : thm =
  |- P (dist (x,y)) <=> (!d. (x = y + d ==> P d) /\ (y = x + d ==> P d))
File "/home/student/OCaml/hol_light (gzip)/realax.ml", line 143, characters 6-47:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( DIST_LE_CASES ) : thm =
  |- !m n p. dist (m,n) <= p <=> m <= n + p /\ n <= m + p
val ( DIST_ADDBOUND ) : thm = |- !m n. dist (m,n) <= m + n
val ( DIST_TRIANGLE ) : thm =
  |- !m n p. dist (m,p) <= dist (m,n) + dist (n,p)
val ( DIST_ADD2 ) : thm =
  |- !m n p q. dist (m + n,p + q) <= dist (m,p) + dist (n,q)
val ( DIST_ADD2_REV ) : thm =
  |- !m n p q. dist (m,p) <= dist (m + n,p + q) + dist (n,q)
val ( DIST_TRIANGLE_LE ) : thm =
  |- !m n p q. dist (m,n) + dist (n,p) <= q ==> dist (m,p) <= q
val ( DIST_TRIANGLES_LE ) : thm =
  |- !m n p q r s.
         dist (m,n) <= r /\ dist (p,q) <= s
         ==> dist (m,p) <= dist (n,q) + r + s
val ( BOUNDS_LINEAR ) : thm = |- !A B C. (!n. A * n <= B * n + C) <=> A <= B
val ( BOUNDS_LINEAR_0 ) : thm = |- !A B. (!n. A * n <= B) <=> A = 0
val ( BOUNDS_DIVIDED ) : thm =
  |- !P. (?B. !n. P n <= B) <=> (?A B. !n. n * P n <= A * n + B)
val ( BOUNDS_NOTZERO ) : thm =
  |- !P A B.
         P 0 0 = 0 /\ (!m n. P m n <= A * (m + n) + B)
         ==> (?B. !m n. P m n <= B * (m + n))
val ( BOUNDS_IGNORE ) : thm =
  |- !P Q. (?B. !i. P i <= Q i + B) <=> (?B N. !i. N <= i ==> P i <= Q i + B)
val is_nadd : thm =
  |- !x. is_nadd x <=> (?B. !m n. dist (m * x n,n * x m) <= B * (m + n))
val is_nadd_0 : thm = |- is_nadd (\n. 0)
val nadd_abs : thm = |- mk_nadd (dest_nadd a) = a
val nadd_rep : thm = |- is_nadd r <=> dest_nadd (mk_nadd r) = r
- : unit = ()
- : unit = ()
val ( NADD_CAUCHY ) : thm =
  |- !x. ?B. !m n. dist (m * fn x n,n * fn x m) <= B * (m + n)
val ( NADD_BOUND ) : thm = |- !x. ?A B. !n. fn x n <= A * n + B
val ( NADD_MULTIPLICATIVE ) : thm =
  |- !x. ?B. !m n. dist (fn x (m * n),m * fn x n) <= B * m + B
val ( NADD_ADDITIVE ) : thm =
  |- !x. ?B. !m n. dist (fn x (m + n),fn x m + fn x n) <= B
val ( NADD_SUC ) : thm = |- !x. ?B. !n. dist (fn x (SUC n),fn x n) <= B
val ( NADD_DIST_LEMMA ) : thm =
  |- !x. ?B. !m n. dist (fn x (m + n),fn x m) <= B * n
val ( NADD_DIST ) : thm =
  |- !x. ?B. !m n. dist (fn x m,fn x n) <= B * dist (m,n)
val ( NADD_ALTMUL ) : thm =
  |- !x y. ?A B. !n. dist (n * fn x (fn y n),fn x n * fn y n) <= A * n + B
- : unit = ()
val nadd_eq : thm = |- !x y. x === y <=> (?B. !n. dist (fn x n,fn y n) <= B)
val ( NADD_EQ_REFL ) : thm = |- !x. x === x
val ( NADD_EQ_SYM ) : thm = |- !x y. x === y <=> y === x
val ( NADD_EQ_TRANS ) : thm = |- !x y z. x === y /\ y === z ==> x === z
- : unit = ()
val nadd_of_num : thm = |- !k. & k = afn (\n. k * n)
val ( NADD_OF_NUM ) : thm = |- !k. fn (& k) = (\n. k * n)
val ( NADD_OF_NUM_WELLDEF ) : thm = |- !m n. m = n ==> & m === & n
val ( NADD_OF_NUM_EQ ) : thm = |- !m n. & m === & n <=> m = n
- : unit = ()
val nadd_le : thm = |- !x y. x <<= y <=> (?B. !n. fn x n <= fn y n + B)
val ( NADD_LE_WELLDEF_LEMMA ) : thm =
  |- !x x' y y'. x === x' /\ y === y' /\ x <<= y ==> x' <<= y'
val ( NADD_LE_WELLDEF ) : thm =
  |- !x x' y y'. x === x' /\ y === y' ==> (x <<= y <=> x' <<= y')
val ( NADD_LE_REFL ) : thm = |- !x. x <<= x
val ( NADD_LE_TRANS ) : thm = |- !x y z. x <<= y /\ y <<= z ==> x <<= z
val ( NADD_LE_ANTISYM ) : thm = |- !x y. x <<= y /\ y <<= x <=> x === y
val ( NADD_LE_TOTAL_LEMMA ) : thm =
  |- !x y. ~(x <<= y) ==> (!B. ?n. ~(n = 0) /\ fn y n + B < fn x n)
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( NADD_LE_TOTAL ) : thm = |- !x y. x <<= y \/ y <<= x
val ( NADD_ARCH ) : thm = |- !x. ?n. x <<= & n
val ( NADD_OF_NUM_LE ) : thm = |- !m n. & m <<= & n <=> m <= n
- : unit = ()
val nadd_add : thm = |- !x y. x ++ y = afn (\n. fn x n + fn y n)
val ( NADD_ADD ) : thm = |- !x y. fn (x ++ y) = (\n. fn x n + fn y n)
val ( NADD_ADD_WELLDEF ) : thm =
  |- !x x' y y'. x === x' /\ y === y' ==> x ++ y === x' ++ y'
val ( NADD_ADD_SYM ) : thm = |- !x y. x ++ y === y ++ x
val ( NADD_ADD_ASSOC ) : thm = |- !x y z. x ++ y ++ z === (x ++ y) ++ z
val ( NADD_ADD_LID ) : thm = |- !x. & 0 ++ x === x
val ( NADD_ADD_LCANCEL ) : thm = |- !x y z. x ++ y === x ++ z ==> y === z
val ( NADD_LE_ADD ) : thm = |- !x y. x <<= x ++ y
val ( NADD_LE_EXISTS ) : thm = |- !x y. x <<= y ==> (?d. y === x ++ d)
val ( NADD_OF_NUM_ADD ) : thm = |- !m n. & m ++ & n === & (m + n)
- : unit = ()
val nadd_mul : thm = |- !x y. x ** y = afn (\n. fn x (fn y n))
val ( NADD_MUL ) : thm = |- !x y. fn (x ** y) = (\n. fn x (fn y n))
val ( NADD_MUL_SYM ) : thm = |- !x y. x ** y === y ** x
val ( NADD_MUL_ASSOC ) : thm = |- !x y z. x ** y ** z === (x ** y) ** z
val ( NADD_MUL_LID ) : thm = |- !x. & 1 ** x === x
val ( NADD_LDISTRIB ) : thm = |- !x y z. x ** (y ++ z) === x ** y ++ x ** z
val ( NADD_MUL_WELLDEF_LEMMA ) : thm =
  |- !x y y'. y === y' ==> x ** y === x ** y'
val ( NADD_MUL_WELLDEF ) : thm =
  |- !x x' y y'. x === x' /\ y === y' ==> x ** y === x' ** y'
val ( NADD_OF_NUM_MUL ) : thm = |- !m n. & m ** & n === & (m * n)
val ( NADD_LE_0 ) : thm = |- !x. & 0 <<= x
val ( NADD_EQ_IMP_LE ) : thm = |- !x y. x === y ==> x <<= y
val ( NADD_LE_LMUL ) : thm = |- !x y z. y <<= z ==> x ** y <<= x ** z
0..0..1..2..3..10..solved at 16
val ( NADD_LE_RMUL ) : thm = |- !x y z. x <<= y ==> x ** z <<= y ** z
val ( NADD_LE_RADD ) : thm = |- !x y z. x ++ z <<= y ++ z <=> x <<= y
0..0..1..3..6..12..solved at 21
0..0..1..3..6..16..solved at 33
val ( NADD_LE_LADD ) : thm = |- !x y z. x ++ y <<= x ++ z <=> y <<= z
0..0..1..4..10..23..48..94..solved at 172
val ( NADD_RDISTRIB ) : thm = |- !x y z. (x ++ y) ** z === x ** z ++ y ** z
val ( NADD_ARCH_MULT ) : thm =
  |- !x k. ~(x === & 0) ==> (?N. & k <<= & N ** x)
0..0..1..4..8..solved at 13
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..3..solved at 8
0..0..1..2..5..19..42..solved at 59
val ( NADD_ARCH_ZERO ) : thm = |- !x k. (!n. & n ** x <<= k) ==> x === & 0
0..0..1..3..6..16..37..70..121..205..325..solved at 432
0..0..1..2..solved at 6
val ( NADD_ARCH_LEMMA ) : thm =
  |- !x y z. (!n. & n ** x <<= & n ** y ++ z) ==> x <<= y
Searching with limit 0
Searching with limit 1
Searching with limit 2
val ( NADD_COMPLETE ) : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <<= M)
         ==> (?M. (!x. P x ==> x <<= M) /\
                  (!M'. (!x. P x ==> x <<= M') ==> M <<= M'))
val ( NADD_UBOUND ) : thm = |- !x. ?B N. !n. N <= n ==> fn x n <= B * n
val ( NADD_NONZERO ) : thm =
  |- !x. ~(x === & 0) ==> (?N. !n. N <= n ==> ~(fn x n = 0))
val ( NADD_LBOUND ) : thm =
  |- !x. ~(x === & 0) ==> (?A N. !n. N <= n ==> n <= A * fn x n)
val nadd_rinv : thm = |- !x. nadd_rinv x = (\n. (n * n) DIV fn x n)
val ( NADD_MUL_LINV_LEMMA0 ) : thm =
  |- !x. ~(x === & 0) ==> (?A B. !n. nadd_rinv x n <= A * n + B)
val ( NADD_MUL_LINV_LEMMA1 ) : thm =
  |- !x n. ~(fn x n = 0) ==> dist (fn x n * nadd_rinv x n,n * n) <= fn x n
val ( NADD_MUL_LINV_LEMMA2 ) : thm =
  |- !x. ~(x === & 0)
         ==> (?N. !n. N <= n
                      ==> dist (fn x n * nadd_rinv x n,n * n) <= fn x n)
val ( NADD_MUL_LINV_LEMMA3 ) : thm =
  |- !x. ~(x === & 0)
         ==> (?N. !m n.
                      N <= n
                      ==> dist
                          (m * fn x m * fn x n * nadd_rinv x n,
                           m * fn x m * n * n) <=
                          m * fn x m * fn x n)
val ( NADD_MUL_LINV_LEMMA4 ) : thm =
  |- !x. ~(x === & 0)
         ==> (?N. !m n.
                      N <= m /\ N <= n
                      ==> (fn x m * fn x n) *
                          dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          (m * n) * dist (m * fn x n,n * fn x m) +
                          (fn x m * fn x n) * (m + n))
val ( NADD_MUL_LINV_LEMMA5 ) : thm =
  |- !x. ~(x === & 0)
         ==> (?B N.
                  !m n.
                      N <= m /\ N <= n
                      ==> (fn x m * fn x n) *
                          dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          B * (m * n) * (m + n))
val ( NADD_MUL_LINV_LEMMA6 ) : thm =
  |- !x. ~(x === & 0)
         ==> (?B N.
                  !m n.
                      N <= m /\ N <= n
                      ==> (m * n) *
                          dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          B * (m * n) * (m + n))
val ( NADD_MUL_LINV_LEMMA7 ) : thm =
  |- !x. ~(x === & 0)
         ==> (?B N.
                  !m n.
                      N <= m /\ N <= n
                      ==> dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                          B * (m + n))
val ( NADD_MUL_LINV_LEMMA7a ) : thm =
  |- !x. ~(x === & 0)
         ==> (!N. ?A B.
                      !m n.
                          m <= N
                          ==> dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                              A * n + B)
val ( NADD_MUL_LINV_LEMMA8 ) : thm =
  |- !x. ~(x === & 0)
         ==> (?B. !m n.
                      dist (m * nadd_rinv x n,n * nadd_rinv x m) <=
                      B * (m + n))
val nadd_inv : thm =
  |- !x. nadd_inv x = (if x === & 0 then & 0 else afn (nadd_rinv x))
- : unit = ()
val ( NADD_INV ) : thm =
  |- !x. fn (inv x) = (if x === & 0 then \n. 0 else nadd_rinv x)
val ( NADD_MUL_LINV ) : thm = |- !x. ~(x === & 0) ==> inv x ** x === & 1
val ( NADD_INV_0 ) : thm = |- inv (& 0) === & 0
0..0..1..4..8..solved at 17
0..0..1..4..solved at 10
0..0..3..6..solved at 10
0..0..3..8..15..solved at 20
0..0..3..12..23..40..63..solved at 72
0..0..3..6..18..34..61..94..145..206..solved at 249
0..0..3..14..36..111..307..901..solved at 935
val ( NADD_INV_WELLDEF ) : thm = |- !x y. x === y ==> inv x === inv y
val hreal_tybij : thm * thm =
  (|- mk_hreal (dest_hreal a) = a,
   |- (?x. r = (===) x) <=> dest_hreal (mk_hreal r) = r)
- : unit = ()
- : unit = ()
File "/home/student/OCaml/hol_light (gzip)/realax.ml", line 1261, characters 4-148:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val hreal_of_num : thm = |- & m = mk_hreal (\u. nadd_of_num m === u)
val hreal_of_num_th : thm = |- mk_hreal ((===) (nadd_of_num m)) = & m
val hreal_add : thm =
  |- x + y =
     mk_hreal (\u. ?x y. x ++ y === u /\ dest_hreal x x /\ dest_hreal y y)
val hreal_add_th : thm =
  |- mk_hreal ((===) (x ++ y)) = mk_hreal ((===) x) + mk_hreal ((===) y)
val hreal_mul : thm =
  |- x * y =
     mk_hreal (\u. ?x y. x ** y === u /\ dest_hreal x x /\ dest_hreal y y)
val hreal_mul_th : thm =
  |- mk_hreal ((===) (x ** y)) = mk_hreal ((===) x) * mk_hreal ((===) y)
val hreal_le : thm =
  |- x <= y <=>
     (@u. ?x y. (x <<= y <=> u) /\ dest_hreal x x /\ dest_hreal y y)
val hreal_le_th : thm =
  |- x <<= y <=> mk_hreal ((===) x) <= mk_hreal ((===) y)
val hreal_inv : thm =
  |- inv x = mk_hreal (\u. ?x. nadd_inv x === u /\ dest_hreal x x)
val hreal_inv_th : thm =
  |- mk_hreal ((===) (nadd_inv x)) = inv (mk_hreal ((===) x))
val ( HREAL_COMPLETE ) : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <= M)
         ==> (?M. (!x. P x ==> x <= M) /\
                  (!M'. (!x. P x ==> x <= M') ==> M <= M'))
File "/home/student/OCaml/hol_light (gzip)/realax.ml", line 1281, characters 4-364:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( HREAL_OF_NUM_EQ ) : thm = |- !m n. & m = & n <=> m = n
val ( HREAL_OF_NUM_LE ) : thm = |- !m n. & m <= & n <=> m <= n
val ( HREAL_OF_NUM_ADD ) : thm = |- !m n. & m + & n = & (m + n)
val ( HREAL_OF_NUM_MUL ) : thm = |- !m n. & m * & n = & (m * n)
val ( HREAL_LE_REFL ) : thm = |- !x. x <= x
val ( HREAL_LE_TRANS ) : thm = |- !x y z. x <= y /\ y <= z ==> x <= z
val ( HREAL_LE_ANTISYM ) : thm = |- !x y. x <= y /\ y <= x <=> x = y
val ( HREAL_LE_TOTAL ) : thm = |- !x y. x <= y \/ y <= x
val ( HREAL_LE_ADD ) : thm = |- !x y. x <= x + y
val ( HREAL_LE_EXISTS ) : thm = |- !x y. x <= y ==> (?d. y = x + d)
val ( HREAL_ARCH ) : thm = |- !x. ?n. x <= & n
val ( HREAL_ADD_SYM ) : thm = |- !x y. x + y = y + x
val ( HREAL_ADD_ASSOC ) : thm = |- !x y z. x + y + z = (x + y) + z
val ( HREAL_ADD_LID ) : thm = |- !x. & 0 + x = x
val ( HREAL_ADD_LCANCEL ) : thm = |- !x y z. x + y = x + z ==> y = z
val ( HREAL_MUL_SYM ) : thm = |- !x y. x * y = y * x
val ( HREAL_MUL_ASSOC ) : thm = |- !x y z. x * y * z = (x * y) * z
val ( HREAL_MUL_LID ) : thm = |- !x. & 1 * x = x
val ( HREAL_ADD_LDISTRIB ) : thm = |- !x y z. x * (y + z) = x * y + x * z
val ( HREAL_MUL_LINV ) : thm = |- !x. ~(x = & 0) ==> inv x * x = & 1
val ( HREAL_INV_0 ) : thm = |- inv (& 0) = & 0
val ( HREAL_LE_EXISTS_DEF ) : thm = |- !m n. m <= n <=> (?d. n = m + d)
val ( HREAL_EQ_ADD_LCANCEL ) : thm = |- !m n p. m + n = m + p <=> n = p
val ( HREAL_EQ_ADD_RCANCEL ) : thm = |- !m n p. m + p = n + p <=> m = n
val ( HREAL_LE_ADD_LCANCEL ) : thm = |- !m n p. m + n <= m + p <=> n <= p
val ( HREAL_LE_ADD_RCANCEL ) : thm = |- !m n p. m + p <= n + p <=> m <= n
val ( HREAL_ADD_RID ) : thm = |- !n. n + & 0 = n
val ( HREAL_ADD_RDISTRIB ) : thm = |- !m n p. (m + n) * p = m * p + n * p
val ( HREAL_MUL_LZERO ) : thm = |- !m. & 0 * m = & 0
val ( HREAL_MUL_RZERO ) : thm = |- !m. m * & 0 = & 0
val ( HREAL_ADD_AC ) : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
val ( HREAL_LE_ADD2 ) : thm =
  |- !a b c d. a <= b /\ c <= d ==> a + c <= b + d
val ( HREAL_LE_MUL_RCANCEL_IMP ) : thm = |- !a b c. a <= b ==> a * c <= b * c
val treal_of_num : thm = |- !n. treal_of_num n = & n,& 0
val treal_neg : thm = |- !y x. treal_neg (x,y) = y,x
val treal_add : thm =
  |- !x1 x2 y1 y2. (x1,y1) treal_add (x2,y2) = x1 + x2,y1 + y2
val treal_mul : thm =
  |- !x1 y2 y1 x2.
         (x1,y1) treal_mul (x2,y2) = x1 * x2 + y1 * y2,x1 * y2 + y1 * x2
val treal_le : thm =
  |- !x1 y2 x2 y1. x1,y1 treal_le x2,y2 <=> x1 + y2 <= x2 + y1
val treal_inv : thm =
  |- !y x.
         treal_inv (x,y) =
         (if x = y
          then & 0,& 0
          else if y <= x
               then inv (@d. x = y + d),& 0
               else & 0,inv (@d. y = x + d))
val treal_eq : thm =
  |- !x1 y2 x2 y1. x1,y1 treal_eq x2,y2 <=> x1 + y2 = x2 + y1
val ( TREAL_EQ_REFL ) : thm = |- !x. x treal_eq x
val ( TREAL_EQ_SYM ) : thm = |- !x y. x treal_eq y <=> y treal_eq x
val ( TREAL_EQ_TRANS ) : thm =
  |- !x y z. x treal_eq y /\ y treal_eq z ==> x treal_eq z
val ( TREAL_EQ_AP ) : thm = |- !x y. x = y ==> x treal_eq y
val ( TREAL_OF_NUM_EQ ) : thm =
  |- !m n. treal_of_num m treal_eq treal_of_num n <=> m = n
val ( TREAL_OF_NUM_LE ) : thm =
  |- !m n. treal_of_num m treal_le treal_of_num n <=> m <= n
val ( TREAL_OF_NUM_ADD ) : thm =
  |- !m n.
         treal_of_num m treal_add treal_of_num n treal_eq
         treal_of_num (m + n)
val ( TREAL_OF_NUM_MUL ) : thm =
  |- !m n.
         treal_of_num m treal_mul treal_of_num n treal_eq
         treal_of_num (m * n)
val ( TREAL_ADD_SYM_EQ ) : thm = |- !x y. x treal_add y = y treal_add x
val ( TREAL_MUL_SYM_EQ ) : thm = |- !x y. x treal_mul y = y treal_mul x
val ( TREAL_ADD_SYM ) : thm = |- !x y. x treal_add y treal_eq y treal_add x
val ( TREAL_ADD_ASSOC ) : thm =
  |- !x y z. x treal_add y treal_add z treal_eq (x treal_add y) treal_add z
val ( TREAL_ADD_LID ) : thm = |- !x. treal_of_num 0 treal_add x treal_eq x
val ( TREAL_ADD_LINV ) : thm =
  |- !x. treal_neg x treal_add x treal_eq treal_of_num 0
val ( TREAL_MUL_SYM ) : thm = |- !x y. x treal_mul y treal_eq y treal_mul x
val ( TREAL_MUL_ASSOC ) : thm =
  |- !x y z. x treal_mul y treal_mul z treal_eq (x treal_mul y) treal_mul z
val ( TREAL_MUL_LID ) : thm = |- !x. treal_of_num 1 treal_mul x treal_eq x
val ( TREAL_ADD_LDISTRIB ) : thm =
  |- !x y z.
         x treal_mul (y treal_add z) treal_eq
         x treal_mul y treal_add x treal_mul z
val ( TREAL_LE_REFL ) : thm = |- !x. x treal_le x
val ( TREAL_LE_ANTISYM ) : thm =
  |- !x y. x treal_le y /\ y treal_le x <=> x treal_eq y
val ( TREAL_LE_TRANS ) : thm =
  |- !x y z. x treal_le y /\ y treal_le z ==> x treal_le z
val ( TREAL_LE_TOTAL ) : thm = |- !x y. x treal_le y \/ y treal_le x
val ( TREAL_LE_LADD_IMP ) : thm =
  |- !x y z. y treal_le z ==> x treal_add y treal_le x treal_add z
val ( TREAL_LE_MUL ) : thm =
  |- !x y.
         treal_of_num 0 treal_le x /\ treal_of_num 0 treal_le y
         ==> treal_of_num 0 treal_le x treal_mul y
val ( TREAL_INV_0 ) : thm =
  |- treal_inv (treal_of_num 0) treal_eq treal_of_num 0
val ( TREAL_MUL_LINV ) : thm =
  |- !x. ~(x treal_eq treal_of_num 0)
         ==> treal_inv x treal_mul x treal_eq treal_of_num 1
val ( TREAL_OF_NUM_WELLDEF ) : thm =
  |- !m n. m = n ==> treal_of_num m treal_eq treal_of_num n
val ( TREAL_NEG_WELLDEF ) : thm =
  |- !x1 x2. x1 treal_eq x2 ==> treal_neg x1 treal_eq treal_neg x2
val ( TREAL_ADD_WELLDEFR ) : thm =
  |- !x1 x2 y. x1 treal_eq x2 ==> x1 treal_add y treal_eq x2 treal_add y
val ( TREAL_ADD_WELLDEF ) : thm =
  |- !x1 x2 y1 y2.
         x1 treal_eq x2 /\ y1 treal_eq y2
         ==> x1 treal_add y1 treal_eq x2 treal_add y2
val ( TREAL_MUL_WELLDEFR ) : thm =
  |- !x1 x2 y. x1 treal_eq x2 ==> x1 treal_mul y treal_eq x2 treal_mul y
val ( TREAL_MUL_WELLDEF ) : thm =
  |- !x1 x2 y1 y2.
         x1 treal_eq x2 /\ y1 treal_eq y2
         ==> x1 treal_mul y1 treal_eq x2 treal_mul y2
val ( TREAL_EQ_IMP_LE ) : thm = |- !x y. x treal_eq y ==> x treal_le y
val ( TREAL_LE_WELLDEF ) : thm =
  |- !x1 x2 y1 y2.
         x1 treal_eq x2 /\ y1 treal_eq y2
         ==> (x1 treal_le y1 <=> x2 treal_le y2)
val ( TREAL_INV_WELLDEF ) : thm =
  |- !x y. x treal_eq y ==> treal_inv x treal_eq treal_inv y
val real_tybij : thm * thm =
  (|- mk_real (dest_real a) = a,
   |- (?x. r = (treal_eq) x) <=> dest_real (mk_real r) = r)
File "/home/student/OCaml/hol_light (gzip)/realax.ml", line 1697, characters 4-165:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val real_of_num : thm =
  |- real_of_numm = mk_real (\u. treal_of_num m treal_eq u)
val real_of_num_th : thm =
  |- mk_real ((treal_eq) (treal_of_num m)) = real_of_numm
val real_neg : thm =
  |- real_neg x1 =
     mk_real (\u. ?x1. treal_neg x1 treal_eq u /\ dest_real x1 x1)
val real_neg_th : thm =
  |- mk_real ((treal_eq) (treal_neg x1)) = real_neg (mk_real ((treal_eq) x1))
val real_add : thm =
  |- real_add x1 y1 =
     mk_real
     (\u. ?x1 y1.
              x1 treal_add y1 treal_eq u /\
              dest_real x1 x1 /\
              dest_real y1 y1)
val real_add_th : thm =
  |- mk_real ((treal_eq) (x1 treal_add y1)) =
     real_add (mk_real ((treal_eq) x1)) (mk_real ((treal_eq) y1))
val real_mul : thm =
  |- real_mul x1 y1 =
     mk_real
     (\u. ?x1 y1.
              x1 treal_mul y1 treal_eq u /\
              dest_real x1 x1 /\
              dest_real y1 y1)
val real_mul_th : thm =
  |- mk_real ((treal_eq) (x1 treal_mul y1)) =
     real_mul (mk_real ((treal_eq) x1)) (mk_real ((treal_eq) y1))
val real_le : thm =
  |- real_le x1 y1 <=>
     (@u. ?x1 y1.
              (x1 treal_le y1 <=> u) /\ dest_real x1 x1 /\ dest_real y1 y1)
val real_le_th : thm =
  |- x1 treal_le y1 <=>
     real_le (mk_real ((treal_eq) x1)) (mk_real ((treal_eq) y1))
val real_inv : thm =
  |- real_inv x = mk_real (\u. ?x. treal_inv x treal_eq u /\ dest_real x x)
val real_inv_th : thm =
  |- mk_real ((treal_eq) (treal_inv x)) = real_inv (mk_real ((treal_eq) x))
File "/home/student/OCaml/hol_light (gzip)/realax.ml", line 1709, characters 4-341:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( REAL_ADD_SYM ) : thm = |- !x y. real_add x y = real_add y x
val ( REAL_ADD_ASSOC ) : thm =
  |- !x y z. real_add x (real_add y z) = real_add (real_add x y) z
val ( REAL_ADD_LID ) : thm = |- !x. real_add (real_of_num0) x = x
val ( REAL_ADD_LINV ) : thm = |- !x. real_add (real_neg x) x = real_of_num0
val ( REAL_MUL_SYM ) : thm = |- !x y. real_mul x y = real_mul y x
val ( REAL_MUL_ASSOC ) : thm =
  |- !x y z. real_mul x (real_mul y z) = real_mul (real_mul x y) z
val ( REAL_MUL_LID ) : thm = |- !x. real_mul (real_of_num1) x = x
val ( REAL_ADD_LDISTRIB ) : thm =
  |- !x y z.
         real_mul x (real_add y z) = real_add (real_mul x y) (real_mul x z)
val ( REAL_LE_REFL ) : thm = |- !x. real_le x x
val ( REAL_LE_ANTISYM ) : thm = |- !x y. real_le x y /\ real_le y x <=> x = y
val ( REAL_LE_TRANS ) : thm =
  |- !x y z. real_le x y /\ real_le y z ==> real_le x z
val ( REAL_LE_TOTAL ) : thm = |- !x y. real_le x y \/ real_le y x
val ( REAL_LE_LADD_IMP ) : thm =
  |- !x y z. real_le y z ==> real_le (real_add x y) (real_add x z)
val ( REAL_LE_MUL ) : thm =
  |- !x y.
         real_le (real_of_num0) x /\ real_le (real_of_num0) y
         ==> real_le (real_of_num0) (real_mul x y)
val ( REAL_INV_0 ) : thm = |- real_inv (real_of_num0) = real_of_num0
val ( REAL_MUL_LINV ) : thm =
  |- !x. ~(x = real_of_num0) ==> real_mul (real_inv x) x = real_of_num1
val ( REAL_OF_NUM_EQ ) : thm = |- !m n. real_of_numm = real_of_numn <=> m = n
val ( REAL_OF_NUM_LE ) : thm =
  |- !m n. real_le (real_of_numm) (real_of_numn) <=> m <= n
val ( REAL_OF_NUM_ADD ) : thm =
  |- !m n. real_add (real_of_numm) (real_of_numn) = real_of_num(m + n)
val ( REAL_OF_NUM_MUL ) : thm =
  |- !m n. real_mul (real_of_numm) (real_of_numn) = real_of_num(m * n)
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val prioritize_real : unit -> unit = <fun>
val real_sub : thm = |- !x y. x - y = x + --y
val real_lt : thm = |- !y x. x < y <=> ~(y <= x)
val real_ge : thm = |- !y x. x >= y <=> y <= x
val real_gt : thm = |- !y x. x > y <=> y < x
val real_abs : thm = |- !x. abs x = (if &0 <= x then x else --x)
val real_pow : thm = |- x pow 0 = &1 /\ (!n. x pow SUC n = x * x pow n)
val real_div : thm = |- !x y. x / y = x * inv y
val real_max : thm = |- !n m. max m n = (if m <= n then n else m)
val real_min : thm = |- !m n. min m n = (if m <= n then m else n)
val ( REAL_HREAL_LEMMA1 ) : thm =
  |- ?r. (!x. &0 <= x <=> (?y. x = r y)) /\ (!y z. y <= z <=> r y <= r z)
val ( REAL_HREAL_LEMMA2 ) : thm =
  |- ?h r.
         (!x. h (r x) = x) /\
         (!x. &0 <= x ==> r (h x) = x) /\
         (!x. &0 <= r x) /\
         (!x y. x <= y <=> r x <= r y)
val ( REAL_COMPLETE_SOMEPOS ) : thm =
  |- !P. (?x. P x /\ &0 <= x) /\ (?M. !x. P x ==> x <= M)
         ==> (?M. (!x. P x ==> x <= M) /\
                  (!M'. (!x. P x ==> x <= M') ==> M <= M'))
val ( REAL_COMPLETE ) : thm =
  |- !P. (?x. P x) /\ (?M. !x. P x ==> x <= M)
         ==> (?M. (!x. P x ==> x <= M) /\
                  (!M'. (!x. P x ==> x <= M') ==> M <= M'))
- : unit = ()
- : unit = ()
- : unit = ()
val is_realintconst : term -> bool = <fun>
val dest_realintconst : term -> num = <fun>
val mk_realintconst : num -> term = <fun>
val is_ratconst : term -> bool = <fun>
val rat_of_term : term -> num = <fun>
val term_of_rat : num -> term = <fun>
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..2..7..14..35..62..solved at 73
val ( REAL_ADD_AC ) : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
0..0..1..2..solved at 6
val ( REAL_ADD_RINV ) : thm = |- !x. x + --x = &0
val ( REAL_EQ_ADD_LCANCEL ) : thm = |- !x y z. x + y = x + z <=> y = z
0..0..1..3..8..19..44..solved at 81
0..0..solved at 2
val ( REAL_EQ_ADD_RCANCEL ) : thm = |- !x y z. x + z = y + z <=> x = y
0..0..1..3..9..25..64..166..437..1159..3190..solved at 4411
val ( REAL_MUL_RZERO ) : thm = |- !x. x * &0 = &0
0..0..1..2..solved at 6
val ( REAL_MUL_LZERO ) : thm = |- !x. &0 * x = &0
0..0..1..3..8..19..44..112..275..694..solved at 932
val ( REAL_NEG_NEG ) : thm = |- !x. -- --x = x
0..0..1..3..8..19..40..85..174..348..696..1556..3482..solved at 6840
val ( REAL_MUL_RNEG ) : thm = |- !x y. x * --y = --(x * y)
0..0..1..2..6..12..28..solved at 55
val ( REAL_MUL_LNEG ) : thm = |- !x y. --x * y = --(x * y)
val ( REAL_NEG_ADD ) : thm = |- !x y. --(x + y) = --x + --y
0..0..1..2..solved at 6
val ( REAL_ADD_RID ) : thm = |- !x. x + &0 = x
0..0..1..2..solved at 6
val ( REAL_NEG_0 ) : thm = |- -- &0 = &0
val ( REAL_LE_LNEG ) : thm = |- !x y. --x <= y <=> &0 <= x + y
val ( REAL_LE_NEG2 ) : thm = |- !x y. --x <= --y <=> y <= x
val ( REAL_LE_RNEG ) : thm = |- !x y. x <= --y <=> x + y <= &0
val ( REAL_OF_NUM_POW ) : thm = |- !x n. &x pow n = &(x EXP n)
val ( REAL_POW_NEG ) : thm =
  |- !x n. --x pow n = (if EVEN n then x pow n else --(x pow n))
val ( REAL_ABS_NUM ) : thm = |- !n. abs (&n) = &n
0..0..1..2..6..11..19..36..53..76..121..solved at 164
0..0..3..solved at 9
val ( REAL_ABS_NEG ) : thm = |- !x. abs (--x) = abs x
File "/home/student/OCaml/hol_light (gzip)/calc_int.ml", line 185, characters 6-44:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/calc_int.ml", line 198, characters 6-44:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/calc_int.ml", line 210, characters 6-44:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/calc_int.ml", line 221, characters 6-44:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/calc_int.ml", line 232, characters 6-46:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( REAL_INT_LE_CONV ) : conv = <fun>
val ( REAL_INT_LT_CONV ) : conv = <fun>
val ( REAL_INT_GE_CONV ) : conv = <fun>
val ( REAL_INT_GT_CONV ) : conv = <fun>
val ( REAL_INT_EQ_CONV ) : conv = <fun>
val ( REAL_INT_NEG_CONV ) : conv = <fun>
val ( REAL_INT_MUL_CONV ) : conv = <fun>
File "/home/student/OCaml/hol_light (gzip)/calc_int.ml", line 282, characters 6-42:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( REAL_INT_ADD_CONV ) : conv = <fun>
val ( REAL_INT_SUB_CONV ) : conv = <fun>
val ( REAL_INT_POW_CONV ) : conv = <fun>
val ( REAL_INT_ABS_CONV ) : conv = <fun>
val ( REAL_INT_RED_CONV ) : term -> thm = <fun>
val ( REAL_INT_REDUCE_CONV ) : conv = <fun>
- : unit = ()
val ( REAL_LTE_TOTAL ) : thm = |- !x y. x < y \/ y <= x
val ( REAL_LET_TOTAL ) : thm = |- !x y. x <= y \/ y < x
0..0..1..7..solved at 12
val ( REAL_LT_IMP_LE ) : thm = |- !x y. x < y ==> x <= y
0..0..1..5..12..24..solved at 30
val ( REAL_LTE_TRANS ) : thm = |- !x y z. x < y /\ y <= z ==> x < z
0..0..1..5..12..23..solved at 30
val ( REAL_LET_TRANS ) : thm = |- !x y z. x <= y /\ y < z ==> x < z
0..0..1..2..5..solved at 10
val ( REAL_LT_TRANS ) : thm = |- !x y z. x < y /\ y < z ==> x < z
0..0..1..2..6..17..34..81..solved at 102
val ( REAL_LE_ADD ) : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x + y
0..0..0..solved at 3
val ( REAL_LTE_ANTISYM ) : thm = |- !x y. ~(x < y /\ y <= x)
val ( REAL_SUB_LE ) : thm = |- !x y. &0 <= x - y <=> y <= x
val ( REAL_NEG_SUB ) : thm = |- !x y. --(x - y) = y - x
0..0..1..2..solved at 6
0..0..2..solved at 7
0..0..1..solved at 4
val ( REAL_LE_LT ) : thm = |- !x y. x <= y <=> x < y \/ x = y
val ( REAL_SUB_LT ) : thm = |- !x y. &0 < x - y <=> y < x
val ( REAL_NOT_LT ) : thm = |- !x y. ~(x < y) <=> y <= x
val ( REAL_SUB_0 ) : thm = |- !x y. x - y = &0 <=> x = y
0..0..1..9..solved at 16
0..0..0..2..solved at 6
0..0..2..6..16..solved at 22
val ( REAL_LT_LE ) : thm = |- !x y. x < y <=> x <= y /\ ~(x = y)
val ( REAL_LT_REFL ) : thm = |- !x. ~(x < x)
0..0..1..2..5..15..28..59..solved at 68
val ( REAL_LTE_ADD ) : thm = |- !x y. &0 < x /\ &0 <= y ==> &0 < x + y
0..0..1..2..4..10..19..solved at 27
val ( REAL_LET_ADD ) : thm = |- !x y. &0 <= x /\ &0 < y ==> &0 < x + y
0..0..1..2..5..solved at 10
val ( REAL_LT_ADD ) : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x + y
val ( REAL_ENTIRE ) : thm = |- !x y. x * y = &0 <=> x = &0 \/ y = &0
val ( REAL_LE_NEGTOTAL ) : thm = |- !x. &0 <= x \/ &0 <= --x
val ( REAL_LE_SQUARE ) : thm = |- !x. &0 <= x * x
0..0..1..2..solved at 7
val ( REAL_MUL_RID ) : thm = |- !x. x * &1 = x
val ( REAL_POW_2 ) : thm = |- !x. x pow 2 = x * x
val ( REAL_POLY_CLAUSES ) : thm =
  |- (!x y z. x + y + z = (x + y) + z) /\
     (!x y. x + y = y + x) /\
     (!x. &0 + x = x) /\
     (!x y z. x * y * z = (x * y) * z) /\
     (!x y. x * y = y * x) /\
     (!x. &1 * x = x) /\
     (!x. &0 * x = &0) /\
     (!x y z. x * (y + z) = x * y + x * z) /\
     (!x. x pow 0 = &1) /\
     (!x n. x pow SUC n = x * x pow n)
val ( REAL_POLY_NEG_CLAUSES ) : thm =
  |- (!x. --x = -- &1 * x) /\ (!x y. x - y = x + -- &1 * y)
val ( REAL_POS ) : thm = |- !n. &0 <= &n
type positivstellensatz =
    Axiom_eq of int
  | Axiom_le of int
  | Axiom_lt of int
  | Rational_eq of num
  | Rational_le of num
  | Rational_lt of num
  | Square of term
  | Eqmul of term * positivstellensatz
  | Sum of positivstellensatz * positivstellensatz
  | Product of positivstellensatz * positivstellensatz
File "/home/student/OCaml/hol_light (gzip)/realarith.ml", line 247, characters 6-165:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..solved at 4
0..0..2..4..solved at 13
0..0..2..4..11..32..75..solved at 142
0..0..2..4..12..33..75..solved at 143
0..0..2..4..solved at 8
0..0..1..2..solved at 6
0..0..1..2..4..17..34..solved at 61
0..0..1..2..solved at 6
0..0..1..2..5..18..35..solved at 63
0..0..1..2..solved at 6
0..0..2..4..10..18..34..76..138..336..872..2366..solved at 5076
val ( GEN_REAL_ARITH ) :
  (num -> term) * conv * conv * conv * conv * conv * conv * conv * conv *
  conv *
  ((thm list * thm list * thm list -> positivstellensatz -> thm) ->
   thm list * thm list * thm list -> thm) ->
  term -> thm = <fun>
val ( REAL_LINEAR_PROVER ) :
  (thm list * thm list * thm list -> positivstellensatz -> '_a) ->
  thm list * thm list * thm list -> '_a = <fun>
val ( REAL_ARITH ) : term -> thm = <fun>
CPU time (user): 0.532033
val ( GEN_REAL_ARITH ) :
  (num -> term) * conv * conv * conv * conv * conv * conv * conv *
  ((thm list * thm list * thm list -> positivstellensatz -> thm) ->
   thm list * thm list * thm list -> thm) ->
  term -> thm = <fun>
val ( REAL_ARITH ) : term -> thm = <fun>
- : unit = ()
val ( REAL_OF_NUM_LT ) : thm = |- !m n. &m < &n <=> m < n
val ( REAL_OF_NUM_GE ) : thm = |- !m n. &m >= &n <=> m >= n
val ( REAL_OF_NUM_GT ) : thm = |- !m n. &m > &n <=> m > n
val ( REAL_OF_NUM_MAX ) : thm = |- !m n. max (&m) (&n) = &(MAX m n)
val ( REAL_OF_NUM_MIN ) : thm = |- !m n. min (&m) (&n) = &(MIN m n)
val ( REAL_OF_NUM_SUC ) : thm = |- !n. &n + &1 = &(SUC n)
0..0..1..2..7..14..37..72..174..325..solved at 392
val ( REAL_OF_NUM_SUB ) : thm = |- !m n. m <= n ==> &n - &m = &(n - m)
val ( REAL_MUL_AC ) : thm =
  |- m * n = n * m /\ (m * n) * p = m * n * p /\ m * n * p = n * m * p
0..0..1..2..6..11..21..34..52..73..solved at 103
val ( REAL_ADD_RDISTRIB ) : thm = |- !x y z. (x + y) * z = x * z + y * z
val ( REAL_LT_LADD_IMP ) : thm = |- !x y z. y < z ==> x + y < x + z
val ( REAL_LT_MUL ) : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x * y
val ( REAL_ARITH_TAC ) : tactic = <fun>
val ( REAL_EQ_ADD_LCANCEL_0 ) : thm = |- !x y. x + y = x <=> y = &0
val ( REAL_EQ_ADD_RCANCEL_0 ) : thm = |- !x y. x + y = y <=> x = &0
val ( REAL_LNEG_UNIQ ) : thm = |- !x y. x + y = &0 <=> x = --y
val ( REAL_RNEG_UNIQ ) : thm = |- !x y. x + y = &0 <=> y = --x
val ( REAL_NEG_LMUL ) : thm = |- !x y. --(x * y) = --x * y
val ( REAL_NEG_RMUL ) : thm = |- !x y. --(x * y) = x * --y
val ( REAL_NEGNEG ) : thm = |- !x. -- --x = x
val ( REAL_NEG_MUL2 ) : thm = |- !x y. --x * --y = x * y
val ( REAL_LT_LADD ) : thm = |- !x y z. x + y < x + z <=> y < z
val ( REAL_LT_RADD ) : thm = |- !x y z. x + z < y + z <=> x < y
val ( REAL_LT_ANTISYM ) : thm = |- !x y. ~(x < y /\ y < x)
val ( REAL_LT_GT ) : thm = |- !x y. x < y ==> ~(y < x)
val ( REAL_NOT_EQ ) : thm = |- !x y. ~(x = y) <=> x < y \/ y < x
val ( REAL_NOT_LE ) : thm = |- !x y. ~(x <= y) <=> y < x
val ( REAL_LET_ANTISYM ) : thm = |- !x y. ~(x <= y /\ y < x)
val ( REAL_NEG_LT0 ) : thm = |- !x. --x < &0 <=> &0 < x
val ( REAL_NEG_GT0 ) : thm = |- !x. &0 < --x <=> x < &0
val ( REAL_NEG_LE0 ) : thm = |- !x. --x <= &0 <=> &0 <= x
val ( REAL_NEG_GE0 ) : thm = |- !x. &0 <= --x <=> x <= &0
val ( REAL_LT_TOTAL ) : thm = |- !x y. x = y \/ x < y \/ y < x
val ( REAL_LT_NEGTOTAL ) : thm = |- !x. x = &0 \/ &0 < x \/ &0 < --x
val ( REAL_LE_01 ) : thm = |- &0 <= &1
val ( REAL_LT_01 ) : thm = |- &0 < &1
val ( REAL_LE_LADD ) : thm = |- !x y z. x + y <= x + z <=> y <= z
val ( REAL_LE_RADD ) : thm = |- !x y z. x + z <= y + z <=> x <= y
val ( REAL_LT_ADD2 ) : thm = |- !w x y z. w < x /\ y < z ==> w + y < x + z
val ( REAL_LE_ADD2 ) : thm = |- !w x y z. w <= x /\ y <= z ==> w + y <= x + z
val ( REAL_LT_LNEG ) : thm = |- !x y. --x < y <=> &0 < x + y
val ( REAL_LT_RNEG ) : thm = |- !x y. x < --y <=> x + y < &0
val ( REAL_LT_ADDNEG ) : thm = |- !x y z. y < x + --z <=> y + z < x
val ( REAL_LT_ADDNEG2 ) : thm = |- !x y z. x + --y < z <=> x < z + y
val ( REAL_LT_ADD1 ) : thm = |- !x y. x <= y ==> x < y + &1
val ( REAL_SUB_ADD ) : thm = |- !x y. x - y + y = x
val ( REAL_SUB_ADD2 ) : thm = |- !x y. y + x - y = x
val ( REAL_SUB_REFL ) : thm = |- !x. x - x = &0
val ( REAL_LE_DOUBLE ) : thm = |- !x. &0 <= x + x <=> &0 <= x
val ( REAL_LE_NEGL ) : thm = |- !x. --x <= x <=> &0 <= x
val ( REAL_LE_NEGR ) : thm = |- !x. x <= --x <=> x <= &0
val ( REAL_NEG_EQ_0 ) : thm = |- !x. --x = &0 <=> x = &0
val ( REAL_ADD_SUB ) : thm = |- !x y. (x + y) - x = y
val ( REAL_NEG_EQ ) : thm = |- !x y. --x = y <=> x = --y
val ( REAL_NEG_MINUS1 ) : thm = |- !x. --x = -- &1 * x
val ( REAL_LT_IMP_NE ) : thm = |- !x y. x < y ==> ~(x = y)
val ( REAL_LE_ADDR ) : thm = |- !x y. x <= x + y <=> &0 <= y
val ( REAL_LE_ADDL ) : thm = |- !x y. y <= x + y <=> &0 <= x
val ( REAL_LT_ADDR ) : thm = |- !x y. x < x + y <=> &0 < y
val ( REAL_LT_ADDL ) : thm = |- !x y. y < x + y <=> &0 < x
val ( REAL_SUB_SUB ) : thm = |- !x y. x - y - x = --y
val ( REAL_LT_ADD_SUB ) : thm = |- !x y z. x + y < z <=> x < z - y
val ( REAL_LT_SUB_RADD ) : thm = |- !x y z. x - y < z <=> x < z + y
val ( REAL_LT_SUB_LADD ) : thm = |- !x y z. x < y - z <=> x + z < y
val ( REAL_LE_SUB_LADD ) : thm = |- !x y z. x <= y - z <=> x + z <= y
val ( REAL_LE_SUB_RADD ) : thm = |- !x y z. x - y <= z <=> x <= z + y
val ( REAL_LT_NEG ) : thm = |- !x y. --x < --y <=> y < x
val ( REAL_LE_NEG ) : thm = |- !x y. --x <= --y <=> y <= x
val ( REAL_ADD2_SUB2 ) : thm = |- !a b c d. (a + b) - (c + d) = a - c + b - d
val ( REAL_SUB_LZERO ) : thm = |- !x. &0 - x = --x
val ( REAL_SUB_RZERO ) : thm = |- !x. x - &0 = x
val ( REAL_LET_ADD2 ) : thm = |- !w x y z. w <= x /\ y < z ==> w + y < x + z
val ( REAL_LTE_ADD2 ) : thm = |- !w x y z. w < x /\ y <= z ==> w + y < x + z
val ( REAL_SUB_LNEG ) : thm = |- !x y. --x - y = --(x + y)
val ( REAL_SUB_RNEG ) : thm = |- !x y. x - --y = x + y
val ( REAL_SUB_NEG2 ) : thm = |- !x y. --x - --y = y - x
val ( REAL_SUB_TRIANGLE ) : thm = |- !a b c. a - b + b - c = a - c
val ( REAL_EQ_SUB_LADD ) : thm = |- !x y z. x = y - z <=> x + z = y
val ( REAL_EQ_SUB_RADD ) : thm = |- !x y z. x - y = z <=> x = z + y
val ( REAL_SUB_SUB2 ) : thm = |- !x y. x - (x - y) = y
val ( REAL_ADD_SUB2 ) : thm = |- !x y. x - (x + y) = --y
val ( REAL_EQ_IMP_LE ) : thm = |- !x y. x = y ==> x <= y
val ( REAL_POS_NZ ) : thm = |- !x. &0 < x ==> ~(x = &0)
val ( REAL_DIFFSQ ) : thm = |- !x y. (x + y) * (x - y) = x * x - y * y
val ( REAL_EQ_NEG2 ) : thm = |- !x y. --x = --y <=> x = y
val ( REAL_LT_NEG2 ) : thm = |- !x y. --x < --y <=> y < x
val ( REAL_SUB_LDISTRIB ) : thm = |- !x y z. x * (y - z) = x * y - x * z
val ( REAL_SUB_RDISTRIB ) : thm = |- !x y z. (x - y) * z = x * z - y * z
val ( REAL_ABS_ZERO ) : thm = |- !x. abs x = &0 <=> x = &0
val ( REAL_ABS_0 ) : thm = |- abs (&0) = &0
val ( REAL_ABS_1 ) : thm = |- abs (&1) = &1
val ( REAL_ABS_TRIANGLE ) : thm = |- !x y. abs (x + y) <= abs x + abs y
val ( REAL_ABS_TRIANGLE_LE ) : thm =
  |- !x y z. abs x + abs (y - x) <= z ==> abs y <= z
val ( REAL_ABS_TRIANGLE_LT ) : thm =
  |- !x y z. abs x + abs (y - x) < z ==> abs y < z
val ( REAL_ABS_POS ) : thm = |- !x. &0 <= abs x
val ( REAL_ABS_SUB ) : thm = |- !x y. abs (x - y) = abs (y - x)
val ( REAL_ABS_NZ ) : thm = |- !x. ~(x = &0) <=> &0 < abs x
val ( REAL_ABS_ABS ) : thm = |- !x. abs (abs x) = abs x
val ( REAL_ABS_LE ) : thm = |- !x. x <= abs x
val ( REAL_ABS_REFL ) : thm = |- !x. abs x = x <=> &0 <= x
val ( REAL_ABS_BETWEEN ) : thm =
  |- !x y d. &0 < d /\ x - d < y /\ y < x + d <=> abs (y - x) < d
val ( REAL_ABS_BOUND ) : thm = |- !x y d. abs (x - y) < d ==> y < x + d
val ( REAL_ABS_STILLNZ ) : thm = |- !x y. abs (x - y) < abs y ==> ~(x = &0)
val ( REAL_ABS_CASES ) : thm = |- !x. x = &0 \/ &0 < abs x
val ( REAL_ABS_BETWEEN1 ) : thm =
  |- !x y z. x < z /\ abs (y - x) < z - x ==> y < z
val ( REAL_ABS_SIGN ) : thm = |- !x y. abs (x - y) < y ==> &0 < x
val ( REAL_ABS_SIGN2 ) : thm = |- !x y. abs (x - y) < --y ==> x < &0
val ( REAL_ABS_CIRCLE ) : thm =
  |- !x y h. abs h < abs y - abs x ==> abs (x + h) < abs y
val ( REAL_SUB_ABS ) : thm = |- !x y. abs x - abs y <= abs (x - y)
val ( REAL_ABS_SUB_ABS ) : thm = |- !x y. abs (abs x - abs y) <= abs (x - y)
val ( REAL_ABS_BETWEEN2 ) : thm =
  |- !x0 x y0 y.
         x0 < y0 /\
         &2 * abs (x - x0) < y0 - x0 /\
         &2 * abs (y - y0) < y0 - x0
         ==> x < y
val ( REAL_ABS_BOUNDS ) : thm = |- !x k. abs x <= k <=> --k <= x /\ x <= k
val ( REAL_BOUNDS_LE ) : thm = |- !x k. --k <= x /\ x <= k <=> abs x <= k
val ( REAL_BOUNDS_LT ) : thm = |- !x k. --k < x /\ x < k <=> abs x < k
val ( REAL_MIN_MAX ) : thm = |- !x y. min x y = --max (--x) (--y)
val ( REAL_MAX_MIN ) : thm = |- !x y. max x y = --min (--x) (--y)
val ( REAL_MAX_MAX ) : thm = |- !x y. x <= max x y /\ y <= max x y
val ( REAL_MIN_MIN ) : thm = |- !x y. min x y <= x /\ min x y <= y
val ( REAL_MAX_SYM ) : thm = |- !x y. max x y = max y x
val ( REAL_MIN_SYM ) : thm = |- !x y. min x y = min y x
val ( REAL_LE_MAX ) : thm = |- !x y z. z <= max x y <=> z <= x \/ z <= y
val ( REAL_LE_MIN ) : thm = |- !x y z. z <= min x y <=> z <= x /\ z <= y
val ( REAL_LT_MAX ) : thm = |- !x y z. z < max x y <=> z < x \/ z < y
val ( REAL_LT_MIN ) : thm = |- !x y z. z < min x y <=> z < x /\ z < y
val ( REAL_MAX_LE ) : thm = |- !x y z. max x y <= z <=> x <= z /\ y <= z
val ( REAL_MIN_LE ) : thm = |- !x y z. min x y <= z <=> x <= z \/ y <= z
val ( REAL_MAX_LT ) : thm = |- !x y z. max x y < z <=> x < z /\ y < z
val ( REAL_MIN_LT ) : thm = |- !x y z. min x y < z <=> x < z \/ y < z
val ( REAL_MAX_ASSOC ) : thm = |- !x y z. max x (max y z) = max (max x y) z
val ( REAL_MIN_ASSOC ) : thm = |- !x y z. min x (min y z) = min (min x y) z
val ( REAL_MAX_ACI ) : thm =
  |- max x y = max y x /\
     max (max x y) z = max x (max y z) /\
     max x (max y z) = max y (max x z) /\
     max x x = x /\
     max x (max x y) = max x y
val ( REAL_MIN_ACI ) : thm =
  |- min x y = min y x /\
     min (min x y) z = min x (min y z) /\
     min x (min y z) = min y (min x z) /\
     min x x = x /\
     min x (min x y) = min x y
val ( REAL_LE_IMP ) : thm -> thm = <fun>
val ( REAL_LET_IMP ) : thm -> thm = <fun>
val ( REAL_ABS_MUL ) : thm = |- !x y. abs (x * y) = abs x * abs y
val ( REAL_POW_LE ) : thm = |- !x n. &0 <= x ==> &0 <= x pow n
val ( REAL_POW_LT ) : thm = |- !x n. &0 < x ==> &0 < x pow n
val ( REAL_ABS_POW ) : thm = |- !x n. abs (x pow n) = abs x pow n
val ( REAL_LE_LMUL ) : thm = |- !x y z. &0 <= x /\ y <= z ==> x * y <= x * z
0..0..1..2..3..11..21..solved at 28
val ( REAL_LE_RMUL ) : thm = |- !x y z. x <= y /\ &0 <= z ==> x * z <= y * z
val ( REAL_LT_LMUL ) : thm = |- !x y z. &0 < x /\ y < z ==> x * y < x * z
0..0..1..2..3..11..21..solved at 28
val ( REAL_LT_RMUL ) : thm = |- !x y z. x < y /\ &0 < z ==> x * z < y * z
val ( REAL_EQ_MUL_LCANCEL ) : thm =
  |- !x y z. x * y = x * z <=> x = &0 \/ y = z
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
val ( REAL_EQ_MUL_RCANCEL ) : thm =
  |- !x y z. x * z = y * z <=> x = y \/ z = &0
val ( REAL_MUL_LINV_UNIQ ) : thm = |- !x y. x * y = &1 ==> inv y = x
val ( REAL_MUL_RINV_UNIQ ) : thm = |- !x y. x * y = &1 ==> inv x = y
val ( REAL_INV_INV ) : thm = |- !x. inv (inv x) = x
0..0..1..2..6..12..27..solved at 44
0..0..solved at 2
val ( REAL_EQ_INV2 ) : thm = |- !x y. inv x = inv y <=> x = y
val ( REAL_INV_EQ_0 ) : thm = |- !x. inv x = &0 <=> x = &0
val ( REAL_LT_INV ) : thm = |- !x. &0 < x ==> &0 < inv x
val ( REAL_LT_INV_EQ ) : thm = |- !x. &0 < inv x <=> &0 < x
val ( REAL_INV_NEG ) : thm = |- !x. inv (--x) = --inv x
0..0..solved at 3
0..0..2..4..8..17..30..solved at 47
0..0..solved at 3
0..0..2..4..8..solved at 15
val ( REAL_LE_INV_EQ ) : thm = |- !x. &0 <= inv x <=> &0 <= x
val ( REAL_LE_INV ) : thm = |- !x. &0 <= x ==> &0 <= inv x
val ( REAL_MUL_RINV ) : thm = |- !x. ~(x = &0) ==> x * inv x = &1
val ( REAL_INV_1 ) : thm = |- inv (&1) = &1
0..0..1..2..6..14..39..solved at 73
0..0..solved at 2
val ( REAL_INV_EQ_1 ) : thm = |- !x. inv x = &1 <=> x = &1
val ( REAL_DIV_1 ) : thm = |- !x. x / &1 = x
val ( REAL_DIV_REFL ) : thm = |- !x. ~(x = &0) ==> x / x = &1
val ( REAL_DIV_RMUL ) : thm = |- !x y. ~(y = &0) ==> x / y * y = x
val ( REAL_DIV_LMUL ) : thm = |- !x y. ~(y = &0) ==> y * x / y = x
val ( REAL_ABS_INV ) : thm = |- !x. abs (inv x) = inv (abs x)
val ( REAL_ABS_DIV ) : thm = |- !x y. abs (x / y) = abs x / abs y
val ( REAL_INV_MUL ) : thm = |- !x y. inv (x * y) = inv x * inv y
val ( REAL_INV_DIV ) : thm = |- !x y. inv (x / y) = y / x
val ( REAL_POW_MUL ) : thm = |- !x y n. (x * y) pow n = x pow n * y pow n
val ( REAL_POW_INV ) : thm = |- !x n. inv x pow n = inv (x pow n)
val ( REAL_INV_POW ) : thm = |- !x n. inv (x pow n) = inv x pow n
val ( REAL_POW_DIV ) : thm = |- !x y n. (x / y) pow n = x pow n / y pow n
val ( REAL_POW_ADD ) : thm = |- !x m n. x pow (m + n) = x pow m * x pow n
0..0..solved at 2
0..0..2..4..solved at 8
val ( REAL_POW_NZ ) : thm = |- !x n. ~(x = &0) ==> ~(x pow n = &0)
val ( REAL_POW_SUB ) : thm =
  |- !x m n. ~(x = &0) /\ m <= n ==> x pow (n - m) = x pow n / x pow m
val ( REAL_LT_IMP_NZ ) : thm = |- !x. &0 < x ==> ~(x = &0)
val ( REAL_LT_LCANCEL_IMP ) : thm =
  |- !x y z. &0 < x /\ x * y < x * z ==> y < z
val ( REAL_LT_RCANCEL_IMP ) : thm =
  |- !x y z. &0 < z /\ x * z < y * z ==> x < y
val ( REAL_LE_LCANCEL_IMP ) : thm =
  |- !x y z. &0 < x /\ x * y <= x * z ==> y <= z
val ( REAL_LE_RCANCEL_IMP ) : thm =
  |- !x y z. &0 < z /\ x * z <= y * z ==> x <= y
0..0..1..3..solved at 8
0..0..1..3..9..solved at 15
val ( REAL_LE_RMUL_EQ ) : thm =
  |- !x y z. &0 < z ==> (x * z <= y * z <=> x <= y)
0..0..1..2..5..11..20..solved at 29
0..0..1..2..5..15..29..solved at 49
val ( REAL_LE_LMUL_EQ ) : thm =
  |- !x y z. &0 < z ==> (z * x <= z * y <=> x <= y)
val ( REAL_LT_RMUL_EQ ) : thm =
  |- !x y z. &0 < z ==> (x * z < y * z <=> x < y)
val ( REAL_LT_LMUL_EQ ) : thm =
  |- !x y z. &0 < z ==> (z * x < z * y <=> x < y)
0..0..1..2..7..19..41..79..146..solved at 200
0..0..1..2..7..19..41..solved at 77
0..0..1..2..7..19..41..79..146..solved at 175
0..0..1..2..7..19..41..solved at 68
val ( REAL_LE_MUL_EQ ) : thm =
  |- (!x y. &0 < x ==> (&0 <= x * y <=> &0 <= y)) /\
     (!x y. &0 < y ==> (&0 <= x * y <=> &0 <= x))
0..0..1..2..9..23..64..133..315..solved at 511
0..0..1..2..9..23..64..solved at 116
0..0..1..2..9..23..64..133..315..solved at 415
0..0..1..2..9..23..64..solved at 116
val ( REAL_LT_MUL_EQ ) : thm =
  |- (!x y. &0 < x ==> (&0 < x * y <=> &0 < y)) /\
     (!x y. &0 < y ==> (&0 < x * y <=> &0 < x))
val ( REAL_MUL_POS_LT ) : thm =
  |- !x y. &0 < x * y <=> &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val ( REAL_MUL_POS_LE ) : thm =
  |- !x y.
         &0 <= x * y <=>
         x = &0 \/ y = &0 \/ &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val ( REAL_LE_RDIV_EQ ) : thm =
  |- !x y z. &0 < z ==> (x <= y / z <=> x * z <= y)
val ( REAL_LE_LDIV_EQ ) : thm =
  |- !x y z. &0 < z ==> (x / z <= y <=> x <= y * z)
val ( REAL_LT_RDIV_EQ ) : thm =
  |- !x y z. &0 < z ==> (x < y / z <=> x * z < y)
val ( REAL_LT_LDIV_EQ ) : thm =
  |- !x y z. &0 < z ==> (x / z < y <=> x < y * z)
val ( REAL_EQ_RDIV_EQ ) : thm =
  |- !x y z. &0 < z ==> (x = y / z <=> x * z = y)
val ( REAL_EQ_LDIV_EQ ) : thm =
  |- !x y z. &0 < z ==> (x / z = y <=> x = y * z)
val ( REAL_LT_DIV2_EQ ) : thm =
  |- !x y z. &0 < z ==> (x / z < y / z <=> x < y)
val ( REAL_LE_DIV2_EQ ) : thm =
  |- !x y z. &0 < z ==> (x / z <= y / z <=> x <= y)
val ( REAL_MUL_2 ) : thm = |- !x. &2 * x = x + x
val ( REAL_POW_EQ_0 ) : thm = |- !x n. x pow n = &0 <=> x = &0 /\ ~(n = 0)
val ( REAL_LE_MUL2 ) : thm =
  |- !w x y z. &0 <= w /\ w <= x /\ &0 <= y /\ y <= z ==> w * y <= x * z
val ( REAL_LT_MUL2 ) : thm =
  |- !w x y z. &0 <= w /\ w < x /\ &0 <= y /\ y < z ==> w * y < x * z
val ( REAL_LT_SQUARE ) : thm = |- !x. &0 < x * x <=> ~(x = &0)
val ( REAL_POW_1 ) : thm = |- !x. x pow 1 = x
val ( REAL_POW_ONE ) : thm = |- !n. &1 pow n = &1
val ( REAL_LT_INV2 ) : thm = |- !x y. &0 < x /\ x < y ==> inv y < inv x
val ( REAL_LE_INV2 ) : thm = |- !x y. &0 < x /\ x <= y ==> inv y <= inv x
val ( REAL_INV_LE_1 ) : thm = |- !x. &1 <= x ==> inv x <= &1
val ( REAL_INV_1_LE ) : thm = |- !x. &0 < x /\ x <= &1 ==> &1 <= inv x
val ( REAL_INV_LT_1 ) : thm = |- !x. &1 < x ==> inv x < &1
val ( REAL_INV_1_LT ) : thm = |- !x. &0 < x /\ x < &1 ==> &1 < inv x
val ( REAL_SUB_INV ) : thm =
  |- !x y. ~(x = &0) /\ ~(y = &0) ==> inv x - inv y = (y - x) / (x * y)
val ( REAL_DOWN ) : thm = |- !d. &0 < d ==> (?e. &0 < e /\ e < d)
val ( REAL_DOWN2 ) : thm =
  |- !d1 d2. &0 < d1 /\ &0 < d2 ==> (?e. &0 < e /\ e < d1 /\ e < d2)
val ( REAL_POW_LE2 ) : thm =
  |- !n x y. &0 <= x /\ x <= y ==> x pow n <= y pow n
val ( REAL_POW_LE_1 ) : thm = |- !n x. &1 <= x ==> &1 <= x pow n
val ( REAL_POW_1_LE ) : thm = |- !n x. &0 <= x /\ x <= &1 ==> x pow n <= &1
val ( REAL_POW_MONO ) : thm =
  |- !m n x. &1 <= x /\ m <= n ==> x pow m <= x pow n
val ( REAL_POW_LT2 ) : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ x < y ==> x pow n < y pow n
val ( REAL_POW_LT_1 ) : thm = |- !n x. ~(n = 0) /\ &1 < x ==> &1 < x pow n
val ( REAL_POW_1_LT ) : thm =
  |- !n x. ~(n = 0) /\ &0 <= x /\ x < &1 ==> x pow n < &1
val ( REAL_POW_MONO_LT ) : thm =
  |- !m n x. &1 < x /\ m < n ==> x pow m < x pow n
val ( REAL_POW_POW ) : thm = |- !x m n. x pow m pow n = x pow (m * n)
val ( REAL_EQ_RCANCEL_IMP ) : thm =
  |- !x y z. ~(z = &0) /\ x * z = y * z ==> x = y
val ( REAL_EQ_LCANCEL_IMP ) : thm =
  |- !x y z. ~(z = &0) /\ z * x = z * y ==> x = y
val ( REAL_LT_DIV ) : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x / y
val ( REAL_LE_DIV ) : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x / y
val ( REAL_DIV_POW2 ) : thm =
  |- !x m n.
         ~(x = &0)
         ==> x pow m / x pow n =
             (if n <= m then x pow (m - n) else inv (x pow (n - m)))
val ( REAL_DIV_POW2_ALT ) : thm =
  |- !x m n.
         ~(x = &0)
         ==> x pow m / x pow n =
             (if n < m then x pow (m - n) else inv (x pow (n - m)))
val ( REAL_LT_POW2 ) : thm = |- !n. &0 < &2 pow n
val ( REAL_LE_POW2 ) : thm = |- !n. &1 <= &2 pow n
val ( REAL_POW2_ABS ) : thm = |- !x. abs x pow 2 = x pow 2
0..0..2..9..solved at 14
0..0..2..9..20..40..87..solved at 94
val ( REAL_LE_SQUARE_ABS ) : thm =
  |- !x y. abs x <= abs y <=> x pow 2 <= y pow 2
val ( REAL_LT_SQUARE_ABS ) : thm =
  |- !x y. abs x < abs y <=> x pow 2 < y pow 2
val ( REAL_EQ_SQUARE_ABS ) : thm =
  |- !x y. abs x = abs y <=> x pow 2 = y pow 2
val ( REAL_SOS_EQ_0 ) : thm =
  |- !x y. x pow 2 + y pow 2 = &0 <=> x = &0 /\ y = &0
val ( REAL_POW_ZERO ) : thm = |- !n. &0 pow n = (if n = 0 then &1 else &0)
val ( REAL_POW_MONO_INV ) : thm =
  |- !m n x. &0 <= x /\ x <= &1 /\ n <= m ==> x pow m <= x pow n
0..0..2..8..18..34..73..solved at 91
val ( REAL_POW_LE2_REV ) : thm =
  |- !n x y. ~(n = 0) /\ &0 <= y /\ x pow n <= y pow n ==> x <= y
0..0..1..5..12..23..solved at 29
val ( REAL_POW_LT2_REV ) : thm =
  |- !n x y. &0 <= y /\ x pow n < y pow n ==> x < y
0..0..2..4..8..solved at 13
0..0..2..4..8..solved at 13
val ( REAL_POW_EQ ) : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ &0 <= y /\ x pow n = y pow n ==> x = y
val ( REAL_POW_EQ_ABS ) : thm =
  |- !n x y. ~(n = 0) /\ x pow n = y pow n ==> abs x = abs y
val ( REAL_POW_EQ_1_IMP ) : thm =
  |- !x n. ~(n = 0) /\ x pow n = &1 ==> abs x = &1
0..0..2..4..solved at 8
0..0..3..6..solved at 13
0..0..solved at 4
0..0..solved at 3
val ( REAL_POW_EQ_1 ) : thm =
  |- !x n. x pow n = &1 <=> abs x = &1 /\ (x < &0 ==> EVEN n) \/ n = 0
val ( REAL_POW_LT2_ODD ) : thm =
  |- !n x y. x < y /\ ODD n ==> x pow n < y pow n
val ( REAL_POW_LE2_ODD ) : thm =
  |- !n x y. x <= y /\ ODD n ==> x pow n <= y pow n
0..0..1..4..9..17..solved at 23
0..0..1..4..solved at 9
val ( REAL_POW_LT2_ODD_EQ ) : thm =
  |- !n x y. ODD n ==> (x pow n < y pow n <=> x < y)
0..0..1..5..10..18..solved at 24
0..0..1..5..solved at 10
val ( REAL_POW_LE2_ODD_EQ ) : thm =
  |- !n x y. ODD n ==> (x pow n <= y pow n <=> x <= y)
val ( REAL_POW_EQ_ODD_EQ ) : thm =
  |- !n x y. ODD n ==> (x pow n = y pow n <=> x = y)
0..0..1..2..solved at 6
val ( REAL_POW_EQ_ODD ) : thm =
  |- !n x y. ODD n /\ x pow n = y pow n ==> x = y
0..0..2..5..solved at 10
val ( REAL_POW_EQ_EQ ) : thm =
  |- !n x y.
         x pow n = y pow n <=>
         (if EVEN n then n = 0 \/ abs x = abs y else x = y)
0..0..1..5..13..27..solved at 33
val ( REAL_WLOG_LE ) : thm =
  |- (!x y. P x y <=> P y x) /\ (!x y. x <= y ==> P x y) ==> (!x y. P x y)
0..0..1..5..11..22..49..95..171..305..solved at 319
val ( REAL_WLOG_LT ) : thm =
  |- (!x. P x x) /\ (!x y. P x y <=> P y x) /\ (!x y. x < y ==> P x y)
     ==> (!x y. P x y)
- : unit = ()
val ( DECIMAL ) : thm = |- !x y. DECIMAL x y = &x / &y
val ( RAT_LEMMA1 ) : thm =
  |- ~(y1 = &0) /\ ~(y2 = &0)
     ==> x1 / y1 + x2 / y2 = (x1 * y2 + x2 * y1) * inv y1 * inv y2
val ( RAT_LEMMA2 ) : thm =
  |- &0 < y1 /\ &0 < y2
     ==> x1 / y1 + x2 / y2 = (x1 * y2 + x2 * y1) * inv y1 * inv y2
val ( RAT_LEMMA3 ) : thm =
  |- &0 < y1 /\ &0 < y2
     ==> x1 / y1 - x2 / y2 = (x1 * y2 - x2 * y1) * inv y1 * inv y2
val ( RAT_LEMMA4 ) : thm =
  |- &0 < y1 /\ &0 < y2 ==> (x1 / y1 <= x2 / y2 <=> x1 * y2 <= x2 * y1)
val ( RAT_LEMMA5 ) : thm =
  |- &0 < y1 /\ &0 < y2 ==> (x1 / y1 = x2 / y2 <=> x1 * y2 = x2 * y1)
val ( REAL_INT_RAT_CONV ) : conv = <fun>
val ( REAL_RAT_LE_CONV ) : conv = <fun>
val ( REAL_RAT_LT_CONV ) : conv = <fun>
val ( REAL_RAT_GE_CONV ) : conv = <fun>
val ( REAL_RAT_GT_CONV ) : conv = <fun>
val ( REAL_RAT_EQ_CONV ) : conv = <fun>
val ( REAL_RAT_NEG_CONV ) : term -> thm = <fun>
val ( REAL_RAT_ABS_CONV ) : conv = <fun>
val ( REAL_RAT_INV_CONV ) : conv = <fun>
val ( REAL_RAT_ADD_CONV ) : conv = <fun>
val ( REAL_RAT_SUB_CONV ) : conv = <fun>
val ( REAL_RAT_MUL_CONV ) : conv = <fun>
val ( REAL_RAT_DIV_CONV ) : term -> thm = <fun>
val ( REAL_RAT_POW_CONV ) : conv = <fun>
val ( REAL_RAT_MAX_CONV ) : conv = <fun>
val ( REAL_RAT_MIN_CONV ) : conv = <fun>
val ( REAL_RAT_RED_CONV ) : term -> thm = <fun>
val ( REAL_RAT_REDUCE_CONV ) : conv = <fun>
val ( REAL_POLY_NEG_CONV ) : term -> thm = <fun>
val ( REAL_POLY_ADD_CONV ) : term -> thm = <fun>
val ( REAL_POLY_SUB_CONV ) : term -> thm = <fun>
val ( REAL_POLY_MUL_CONV ) : term -> thm = <fun>
val ( REAL_POLY_POW_CONV ) : term -> thm = <fun>
val ( REAL_POLY_CONV ) : term -> thm = <fun>
val ( REAL_POLY_CONV ) : term -> thm = <fun>
0..0..3..solved at 6
0..0..1..4..12..53..156..809..solved at 3536
val ( REAL_RING ) : term -> thm = <fun>
val real_ideal_cofactors : term list -> term -> term list = <fun>
val ( REAL_IDEAL_CONV ) : term list -> term -> thm = <fun>
val ( GEN_REAL_ARITH ) :
  ((thm list * thm list * thm list -> positivstellensatz -> thm) ->
   thm list * thm list * thm list -> thm) ->
  term -> thm = <fun>
val ( REAL_ARITH ) : term -> thm = <fun>
val ( REAL_ARITH_TAC ) : tactic = <fun>
val ( ASM_REAL_ARITH_TAC ) : tactic = <fun>
val ( REAL_FIELD ) : term -> thm = <fun>
- : unit = ()
val is_int : thm = |- !x. is_int x <=> (?n. x = &n \/ x = -- &n)
val int_abstr : thm = |- int_of_real (real_of_int a) = a
val int_rep : thm = |- is_int r <=> real_of_int (int_of_real r) = r
val dest_int_rep : thm =
  |- !i. ?n. real_of_int i = &n \/ real_of_int i = -- &n
val int_eq : thm = |- !x y. x = y <=> real_of_int x = real_of_int y
- : unit = ()
val prioritize_int : unit -> unit = <fun>
val int_le : thm = |- !x y. x <= y <=> real_of_int x <= real_of_int y
val int_lt : thm = |- !x y. x < y <=> real_of_int x < real_of_int y
val int_ge : thm = |- !x y. x >= y <=> real_of_int x >= real_of_int y
val int_gt : thm = |- !x y. x > y <=> real_of_int x > real_of_int y
val int_of_num : thm = |- !n. &n = int_of_real (&n)
val int_of_num_th : thm = |- !n. real_of_int (&n) = &n
val int_neg : thm = |- !i. --i = int_of_real (--real_of_int i)
val int_neg_th : thm = |- !x. real_of_int (--x) = --real_of_int x
val int_add : thm =
  |- !x y. x + y = int_of_real (real_of_int x + real_of_int y)
val int_add_th : thm =
  |- !x y. real_of_int (x + y) = real_of_int x + real_of_int y
val int_sub : thm =
  |- !x y. x - y = int_of_real (real_of_int x - real_of_int y)
val int_sub_th : thm =
  |- !x y. real_of_int (x - y) = real_of_int x - real_of_int y
val int_mul : thm =
  |- !x y. x * y = int_of_real (real_of_int x * real_of_int y)
val int_mul_th : thm =
  |- !x y. real_of_int (x * y) = real_of_int x * real_of_int y
val int_abs : thm = |- !x. abs x = int_of_real (abs (real_of_int x))
val int_abs_th : thm = |- !x. real_of_int (abs x) = abs (real_of_int x)
val int_max : thm =
  |- !x y. max x y = int_of_real (max (real_of_int x) (real_of_int y))
val int_max_th : thm =
  |- !x y. real_of_int (max x y) = max (real_of_int x) (real_of_int y)
val int_min : thm =
  |- !x y. min x y = int_of_real (min (real_of_int x) (real_of_int y))
val int_min_th : thm =
  |- !x y. real_of_int (min x y) = min (real_of_int x) (real_of_int y)
val int_pow : thm = |- !x n. x pow n = int_of_real (real_of_int x pow n)
val int_pow_th : thm = |- !x n. real_of_int (x pow n) = real_of_int x pow n
val ( INT_IMAGE ) : thm = |- !x. (?n. x = &n) \/ (?n. x = -- &n)
val ( INT_LT_DISCRETE ) : thm = |- !x y. x < y <=> x + &1 <= y
val ( INT_GT_DISCRETE ) : thm = |- !x y. x > y <=> x >= y + &1
val is_intconst : term -> bool = <fun>
val dest_intconst : term -> num = <fun>
val mk_intconst : num -> term = <fun>
val ( INT_OF_REAL_THM ) : thm -> thm = <fun>
val ( INT_ABS_0 ) : thm = |- abs (&0) = &0
val ( INT_ABS_1 ) : thm = |- abs (&1) = &1
val ( INT_ABS_ABS ) : thm = |- !x. abs (abs x) = abs x
val ( INT_ABS_BETWEEN ) : thm =
  |- !x y d. &0 < d /\ x - d < y /\ y < x + d <=> abs (y - x) < d
val ( INT_ABS_BETWEEN1 ) : thm =
  |- !x y z. x < z /\ abs (y - x) < z - x ==> y < z
val ( INT_ABS_BETWEEN2 ) : thm =
  |- !x0 x y0 y.
         x0 < y0 /\
         &2 * abs (x - x0) < y0 - x0 /\
         &2 * abs (y - y0) < y0 - x0
         ==> x < y
val ( INT_ABS_BOUND ) : thm = |- !x y d. abs (x - y) < d ==> y < x + d
val ( INT_ABS_CASES ) : thm = |- !x. x = &0 \/ &0 < abs x
val ( INT_ABS_CIRCLE ) : thm =
  |- !x y h. abs h < abs y - abs x ==> abs (x + h) < abs y
val ( INT_ABS_LE ) : thm = |- !x. x <= abs x
val ( INT_ABS_MUL ) : thm = |- !x y. abs (x * y) = abs x * abs y
val ( INT_ABS_NEG ) : thm = |- !x. abs (--x) = abs x
val ( INT_ABS_NUM ) : thm = |- !n. abs (&n) = &n
val ( INT_ABS_NZ ) : thm = |- !x. ~(x = &0) <=> &0 < abs x
val ( INT_ABS_POS ) : thm = |- !x. &0 <= abs x
val ( INT_ABS_POW ) : thm = |- !x n. abs (x pow n) = abs x pow n
val ( INT_ABS_REFL ) : thm = |- !x. abs x = x <=> &0 <= x
val ( INT_ABS_SIGN ) : thm = |- !x y. abs (x - y) < y ==> &0 < x
val ( INT_ABS_SIGN2 ) : thm = |- !x y. abs (x - y) < --y ==> x < &0
val ( INT_ABS_STILLNZ ) : thm = |- !x y. abs (x - y) < abs y ==> ~(x = &0)
val ( INT_ABS_SUB ) : thm = |- !x y. abs (x - y) = abs (y - x)
val ( INT_ABS_SUB_ABS ) : thm = |- !x y. abs (abs x - abs y) <= abs (x - y)
val ( INT_ABS_TRIANGLE ) : thm = |- !x y. abs (x + y) <= abs x + abs y
val ( INT_ABS_ZERO ) : thm = |- !x. abs x = &0 <=> x = &0
val ( INT_ADD2_SUB2 ) : thm = |- !a b c d. (a + b) - (c + d) = a - c + b - d
val ( INT_ADD_AC ) : thm =
  |- m + n = n + m /\ (m + n) + p = m + n + p /\ m + n + p = n + m + p
val ( INT_ADD_ASSOC ) : thm = |- !x y z. x + y + z = (x + y) + z
val ( INT_ADD_LDISTRIB ) : thm = |- !x y z. x * (y + z) = x * y + x * z
val ( INT_ADD_LID ) : thm = |- !x. &0 + x = x
val ( INT_ADD_LINV ) : thm = |- !x. --x + x = &0
val ( INT_ADD_RDISTRIB ) : thm = |- !x y z. (x + y) * z = x * z + y * z
val ( INT_ADD_RID ) : thm = |- !x. x + &0 = x
val ( INT_ADD_RINV ) : thm = |- !x. x + --x = &0
val ( INT_ADD_SUB ) : thm = |- !x y. (x + y) - x = y
val ( INT_ADD_SUB2 ) : thm = |- !x y. x - (x + y) = --y
val ( INT_ADD_SYM ) : thm = |- !x y. x + y = y + x
val ( INT_BOUNDS_LE ) : thm = |- !x k. --k <= x /\ x <= k <=> abs x <= k
val ( INT_BOUNDS_LT ) : thm = |- !x k. --k < x /\ x < k <=> abs x < k
val ( INT_DIFFSQ ) : thm = |- !x y. (x + y) * (x - y) = x * x - y * y
val ( INT_ENTIRE ) : thm = |- !x y. x * y = &0 <=> x = &0 \/ y = &0
val ( INT_EQ_ADD_LCANCEL ) : thm = |- !x y z. x + y = x + z <=> y = z
val ( INT_EQ_ADD_LCANCEL_0 ) : thm = |- !x y. x + y = x <=> y = &0
val ( INT_EQ_ADD_RCANCEL ) : thm = |- !x y z. x + z = y + z <=> x = y
val ( INT_EQ_ADD_RCANCEL_0 ) : thm = |- !x y. x + y = y <=> x = &0
val ( INT_EQ_IMP_LE ) : thm = |- !x y. x = y ==> x <= y
val ( INT_EQ_MUL_LCANCEL ) : thm =
  |- !x y z. x * y = x * z <=> x = &0 \/ y = z
val ( INT_EQ_MUL_RCANCEL ) : thm =
  |- !x y z. x * z = y * z <=> x = y \/ z = &0
val ( INT_EQ_NEG2 ) : thm = |- !x y. --x = --y <=> x = y
val ( INT_EQ_SQUARE_ABS ) : thm =
  |- !x y. abs x = abs y <=> x pow 2 = y pow 2
val ( INT_EQ_SUB_LADD ) : thm = |- !x y z. x = y - z <=> x + z = y
val ( INT_EQ_SUB_RADD ) : thm = |- !x y z. x - y = z <=> x = z + y
val ( INT_LET_ADD ) : thm = |- !x y. &0 <= x /\ &0 < y ==> &0 < x + y
val ( INT_LET_ADD2 ) : thm = |- !w x y z. w <= x /\ y < z ==> w + y < x + z
val ( INT_LET_ANTISYM ) : thm = |- !x y. ~(x <= y /\ y < x)
val ( INT_LET_TOTAL ) : thm = |- !x y. x <= y \/ y < x
val ( INT_LET_TRANS ) : thm = |- !x y z. x <= y /\ y < z ==> x < z
val ( INT_LE_01 ) : thm = |- &0 <= &1
val ( INT_LE_ADD ) : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x + y
val ( INT_LE_ADD2 ) : thm = |- !w x y z. w <= x /\ y <= z ==> w + y <= x + z
val ( INT_LE_ADDL ) : thm = |- !x y. y <= x + y <=> &0 <= x
val ( INT_LE_ADDR ) : thm = |- !x y. x <= x + y <=> &0 <= y
val ( INT_LE_ANTISYM ) : thm = |- !x y. x <= y /\ y <= x <=> x = y
val ( INT_LE_DOUBLE ) : thm = |- !x. &0 <= x + x <=> &0 <= x
val ( INT_LE_LADD ) : thm = |- !x y z. x + y <= x + z <=> y <= z
val ( INT_LE_LADD_IMP ) : thm = |- !x y z. y <= z ==> x + y <= x + z
val ( INT_LE_LMUL ) : thm = |- !x y z. &0 <= x /\ y <= z ==> x * y <= x * z
val ( INT_LE_LNEG ) : thm = |- !x y. --x <= y <=> &0 <= x + y
val ( INT_LE_LT ) : thm = |- !x y. x <= y <=> x < y \/ x = y
val ( INT_LE_MAX ) : thm = |- !x y z. z <= max x y <=> z <= x \/ z <= y
val ( INT_LE_MIN ) : thm = |- !x y z. z <= min x y <=> z <= x /\ z <= y
val ( INT_LE_MUL ) : thm = |- !x y. &0 <= x /\ &0 <= y ==> &0 <= x * y
val ( INT_LE_MUL_EQ ) : thm =
  |- (!x y. &0 < x ==> (&0 <= x * y <=> &0 <= y)) /\
     (!x y. &0 < y ==> (&0 <= x * y <=> &0 <= x))
val ( INT_LE_NEG ) : thm = |- !x y. --x <= --y <=> y <= x
val ( INT_LE_NEG2 ) : thm = |- !x y. --x <= --y <=> y <= x
val ( INT_LE_NEGL ) : thm = |- !x. --x <= x <=> &0 <= x
val ( INT_LE_NEGR ) : thm = |- !x. x <= --x <=> x <= &0
val ( INT_LE_NEGTOTAL ) : thm = |- !x. &0 <= x \/ &0 <= --x
val ( INT_LE_POW2 ) : thm = |- !n. &1 <= &2 pow n
val ( INT_LE_RADD ) : thm = |- !x y z. x + z <= y + z <=> x <= y
val ( INT_LE_REFL ) : thm = |- !x. x <= x
val ( INT_LE_RMUL ) : thm = |- !x y z. x <= y /\ &0 <= z ==> x * z <= y * z
val ( INT_LE_RNEG ) : thm = |- !x y. x <= --y <=> x + y <= &0
val ( INT_LE_SQUARE ) : thm = |- !x. &0 <= x * x
val ( INT_LE_SQUARE_ABS ) : thm =
  |- !x y. abs x <= abs y <=> x pow 2 <= y pow 2
val ( INT_LE_SUB_LADD ) : thm = |- !x y z. x <= y - z <=> x + z <= y
val ( INT_LE_SUB_RADD ) : thm = |- !x y z. x - y <= z <=> x <= z + y
val ( INT_LE_TOTAL ) : thm = |- !x y. x <= y \/ y <= x
val ( INT_LE_TRANS ) : thm = |- !x y z. x <= y /\ y <= z ==> x <= z
val ( INT_LNEG_UNIQ ) : thm = |- !x y. x + y = &0 <=> x = --y
val ( INT_LTE_ADD ) : thm = |- !x y. &0 < x /\ &0 <= y ==> &0 < x + y
val ( INT_LTE_ADD2 ) : thm = |- !w x y z. w < x /\ y <= z ==> w + y < x + z
val ( INT_LTE_ANTISYM ) : thm = |- !x y. ~(x < y /\ y <= x)
val ( INT_LTE_TOTAL ) : thm = |- !x y. x < y \/ y <= x
val ( INT_LTE_TRANS ) : thm = |- !x y z. x < y /\ y <= z ==> x < z
val ( INT_LT_01 ) : thm = |- &0 < &1
val ( INT_LT_ADD ) : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x + y
val ( INT_LT_ADD1 ) : thm = |- !x y. x <= y ==> x < y + &1
val ( INT_LT_ADD2 ) : thm = |- !w x y z. w < x /\ y < z ==> w + y < x + z
val ( INT_LT_ADDL ) : thm = |- !x y. y < x + y <=> &0 < x
val ( INT_LT_ADDNEG ) : thm = |- !x y z. y < x + --z <=> y + z < x
val ( INT_LT_ADDNEG2 ) : thm = |- !x y z. x + --y < z <=> x < z + y
val ( INT_LT_ADDR ) : thm = |- !x y. x < x + y <=> &0 < y
val ( INT_LT_ADD_SUB ) : thm = |- !x y z. x + y < z <=> x < z - y
val ( INT_LT_ANTISYM ) : thm = |- !x y. ~(x < y /\ y < x)
val ( INT_LT_GT ) : thm = |- !x y. x < y ==> ~(y < x)
val ( INT_LT_IMP_LE ) : thm = |- !x y. x < y ==> x <= y
val ( INT_LT_IMP_NE ) : thm = |- !x y. x < y ==> ~(x = y)
val ( INT_LT_LADD ) : thm = |- !x y z. x + y < x + z <=> y < z
val ( INT_LT_LE ) : thm = |- !x y. x < y <=> x <= y /\ ~(x = y)
val ( INT_LT_LMUL_EQ ) : thm =
  |- !x y z. &0 < z ==> (z * x < z * y <=> x < y)
val ( INT_LT_MAX ) : thm = |- !x y z. z < max x y <=> z < x \/ z < y
val ( INT_LT_MIN ) : thm = |- !x y z. z < min x y <=> z < x /\ z < y
val ( INT_LT_MUL ) : thm = |- !x y. &0 < x /\ &0 < y ==> &0 < x * y
val ( INT_LT_MUL_EQ ) : thm =
  |- (!x y. &0 < x ==> (&0 < x * y <=> &0 < y)) /\
     (!x y. &0 < y ==> (&0 < x * y <=> &0 < x))
val ( INT_LT_NEG ) : thm = |- !x y. --x < --y <=> y < x
val ( INT_LT_NEG2 ) : thm = |- !x y. --x < --y <=> y < x
val ( INT_LT_NEGTOTAL ) : thm = |- !x. x = &0 \/ &0 < x \/ &0 < --x
val ( INT_LT_POW2 ) : thm = |- !n. &0 < &2 pow n
val ( INT_LT_RADD ) : thm = |- !x y z. x + z < y + z <=> x < y
val ( INT_LT_REFL ) : thm = |- !x. ~(x < x)
val ( INT_LT_RMUL_EQ ) : thm =
  |- !x y z. &0 < z ==> (x * z < y * z <=> x < y)
val ( INT_LT_SQUARE_ABS ) : thm =
  |- !x y. abs x < abs y <=> x pow 2 < y pow 2
val ( INT_LT_SUB_LADD ) : thm = |- !x y z. x < y - z <=> x + z < y
val ( INT_LT_SUB_RADD ) : thm = |- !x y z. x - y < z <=> x < z + y
val ( INT_LT_TOTAL ) : thm = |- !x y. x = y \/ x < y \/ y < x
val ( INT_LT_TRANS ) : thm = |- !x y z. x < y /\ y < z ==> x < z
val ( INT_MAX_ACI ) : thm =
  |- max x y = max y x /\
     max (max x y) z = max x (max y z) /\
     max x (max y z) = max y (max x z) /\
     max x x = x /\
     max x (max x y) = max x y
val ( INT_MAX_ASSOC ) : thm = |- !x y z. max x (max y z) = max (max x y) z
val ( INT_MAX_LE ) : thm = |- !x y z. max x y <= z <=> x <= z /\ y <= z
val ( INT_MAX_LT ) : thm = |- !x y z. max x y < z <=> x < z /\ y < z
val ( INT_MAX_MAX ) : thm = |- !x y. x <= max x y /\ y <= max x y
val ( INT_MAX_MIN ) : thm = |- !x y. max x y = --min (--x) (--y)
val ( INT_MAX_SYM ) : thm = |- !x y. max x y = max y x
val ( INT_MIN_ACI ) : thm =
  |- min x y = min y x /\
     min (min x y) z = min x (min y z) /\
     min x (min y z) = min y (min x z) /\
     min x x = x /\
     min x (min x y) = min x y
val ( INT_MIN_ASSOC ) : thm = |- !x y z. min x (min y z) = min (min x y) z
val ( INT_MIN_LE ) : thm = |- !x y z. min x y <= z <=> x <= z \/ y <= z
val ( INT_MIN_LT ) : thm = |- !x y z. min x y < z <=> x < z \/ y < z
val ( INT_MIN_MAX ) : thm = |- !x y. min x y = --max (--x) (--y)
val ( INT_MIN_MIN ) : thm = |- !x y. min x y <= x /\ min x y <= y
val ( INT_MIN_SYM ) : thm = |- !x y. min x y = min y x
val ( INT_MUL_AC ) : thm =
  |- m * n = n * m /\ (m * n) * p = m * n * p /\ m * n * p = n * m * p
val ( INT_MUL_ASSOC ) : thm = |- !x y z. x * y * z = (x * y) * z
val ( INT_MUL_LID ) : thm = |- !x. &1 * x = x
val ( INT_MUL_LNEG ) : thm = |- !x y. --x * y = --(x * y)
val ( INT_MUL_LZERO ) : thm = |- !x. &0 * x = &0
val ( INT_MUL_POS_LE ) : thm =
  |- !x y.
         &0 <= x * y <=>
         x = &0 \/ y = &0 \/ &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val ( INT_MUL_POS_LT ) : thm =
  |- !x y. &0 < x * y <=> &0 < x /\ &0 < y \/ x < &0 /\ y < &0
val ( INT_MUL_RID ) : thm = |- !x. x * &1 = x
val ( INT_MUL_RNEG ) : thm = |- !x y. x * --y = --(x * y)
val ( INT_MUL_RZERO ) : thm = |- !x. x * &0 = &0
val ( INT_MUL_SYM ) : thm = |- !x y. x * y = y * x
val ( INT_NEGNEG ) : thm = |- !x. -- --x = x
val ( INT_NEG_0 ) : thm = |- -- &0 = &0
val ( INT_NEG_ADD ) : thm = |- !x y. --(x + y) = --x + --y
val ( INT_NEG_EQ ) : thm = |- !x y. --x = y <=> x = --y
val ( INT_NEG_EQ_0 ) : thm = |- !x. --x = &0 <=> x = &0
val ( INT_NEG_GE0 ) : thm = |- !x. &0 <= --x <=> x <= &0
val ( INT_NEG_GT0 ) : thm = |- !x. &0 < --x <=> x < &0
val ( INT_NEG_LE0 ) : thm = |- !x. --x <= &0 <=> &0 <= x
val ( INT_NEG_LMUL ) : thm = |- !x y. --(x * y) = --x * y
val ( INT_NEG_LT0 ) : thm = |- !x. --x < &0 <=> &0 < x
val ( INT_NEG_MINUS1 ) : thm = |- !x. --x = -- &1 * x
val ( INT_NEG_MUL2 ) : thm = |- !x y. --x * --y = x * y
val ( INT_NEG_NEG ) : thm = |- !x. -- --x = x
val ( INT_NEG_RMUL ) : thm = |- !x y. --(x * y) = x * --y
val ( INT_NEG_SUB ) : thm = |- !x y. --(x - y) = y - x
val ( INT_NOT_EQ ) : thm = |- !x y. ~(x = y) <=> x < y \/ y < x
val ( INT_NOT_LE ) : thm = |- !x y. ~(x <= y) <=> y < x
val ( INT_NOT_LT ) : thm = |- !x y. ~(x < y) <=> y <= x
val ( INT_OF_NUM_ADD ) : thm = |- !m n. &m + &n = &(m + n)
val ( INT_OF_NUM_EQ ) : thm = |- !m n. &m = &n <=> m = n
val ( INT_OF_NUM_GE ) : thm = |- !m n. &m >= &n <=> m >= n
val ( INT_OF_NUM_GT ) : thm = |- !m n. &m > &n <=> m > n
val ( INT_OF_NUM_LE ) : thm = |- !m n. &m <= &n <=> m <= n
val ( INT_OF_NUM_LT ) : thm = |- !m n. &m < &n <=> m < n
val ( INT_OF_NUM_MAX ) : thm = |- !m n. max (&m) (&n) = &(MAX m n)
val ( INT_OF_NUM_MIN ) : thm = |- !m n. min (&m) (&n) = &(MIN m n)
val ( INT_OF_NUM_MUL ) : thm = |- !m n. &m * &n = &(m * n)
val ( INT_OF_NUM_POW ) : thm = |- !x n. &x pow n = &(x EXP n)
val ( INT_OF_NUM_SUB ) : thm = |- !m n. m <= n ==> &n - &m = &(n - m)
val ( INT_OF_NUM_SUC ) : thm = |- !n. &n + &1 = &(SUC n)
val ( INT_POS ) : thm = |- !n. &0 <= &n
val ( INT_POS_NZ ) : thm = |- !x. &0 < x ==> ~(x = &0)
val ( INT_POW2_ABS ) : thm = |- !x. abs x pow 2 = x pow 2
val ( INT_POW_1 ) : thm = |- !x. x pow 1 = x
val ( INT_POW_1_LE ) : thm = |- !n x. &0 <= x /\ x <= &1 ==> x pow n <= &1
val ( INT_POW_1_LT ) : thm =
  |- !n x. ~(n = 0) /\ &0 <= x /\ x < &1 ==> x pow n < &1
val ( INT_POW_2 ) : thm = |- !x. x pow 2 = x * x
val ( INT_POW_ADD ) : thm = |- !x m n. x pow (m + n) = x pow m * x pow n
val ( INT_POW_EQ ) : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ &0 <= y /\ x pow n = y pow n ==> x = y
val ( INT_POW_EQ_0 ) : thm = |- !x n. x pow n = &0 <=> x = &0 /\ ~(n = 0)
val ( INT_POW_EQ_ABS ) : thm =
  |- !n x y. ~(n = 0) /\ x pow n = y pow n ==> abs x = abs y
val ( INT_POW_LE ) : thm = |- !x n. &0 <= x ==> &0 <= x pow n
val ( INT_POW_LE2 ) : thm =
  |- !n x y. &0 <= x /\ x <= y ==> x pow n <= y pow n
val ( INT_POW_LE2_ODD ) : thm =
  |- !n x y. x <= y /\ ODD n ==> x pow n <= y pow n
val ( INT_POW_LE2_REV ) : thm =
  |- !n x y. ~(n = 0) /\ &0 <= y /\ x pow n <= y pow n ==> x <= y
val ( INT_POW_LE_1 ) : thm = |- !n x. &1 <= x ==> &1 <= x pow n
val ( INT_POW_LT ) : thm = |- !x n. &0 < x ==> &0 < x pow n
val ( INT_POW_LT2 ) : thm =
  |- !n x y. ~(n = 0) /\ &0 <= x /\ x < y ==> x pow n < y pow n
val ( INT_POW_LT2_REV ) : thm =
  |- !n x y. &0 <= y /\ x pow n < y pow n ==> x < y
val ( INT_POW_LT_1 ) : thm = |- !n x. ~(n = 0) /\ &1 < x ==> &1 < x pow n
val ( INT_POW_MONO ) : thm =
  |- !m n x. &1 <= x /\ m <= n ==> x pow m <= x pow n
val ( INT_POW_MONO_LT ) : thm =
  |- !m n x. &1 < x /\ m < n ==> x pow m < x pow n
val ( INT_POW_MUL ) : thm = |- !x y n. (x * y) pow n = x pow n * y pow n
val ( INT_POW_NEG ) : thm =
  |- !x n. --x pow n = (if EVEN n then x pow n else --(x pow n))
val ( INT_POW_NZ ) : thm = |- !x n. ~(x = &0) ==> ~(x pow n = &0)
val ( INT_POW_ONE ) : thm = |- !n. &1 pow n = &1
val ( INT_POW_POW ) : thm = |- !x m n. x pow m pow n = x pow (m * n)
val ( INT_POW_ZERO ) : thm = |- !n. &0 pow n = (if n = 0 then &1 else &0)
val ( INT_RNEG_UNIQ ) : thm = |- !x y. x + y = &0 <=> y = --x
val ( INT_SOS_EQ_0 ) : thm =
  |- !x y. x pow 2 + y pow 2 = &0 <=> x = &0 /\ y = &0
val ( INT_SUB_0 ) : thm = |- !x y. x - y = &0 <=> x = y
val ( INT_SUB_ABS ) : thm = |- !x y. abs x - abs y <= abs (x - y)
val ( INT_SUB_ADD ) : thm = |- !x y. x - y + y = x
val ( INT_SUB_ADD2 ) : thm = |- !x y. y + x - y = x
val ( INT_SUB_LDISTRIB ) : thm = |- !x y z. x * (y - z) = x * y - x * z
val ( INT_SUB_LE ) : thm = |- !x y. &0 <= x - y <=> y <= x
val ( INT_SUB_LNEG ) : thm = |- !x y. --x - y = --(x + y)
val ( INT_SUB_LT ) : thm = |- !x y. &0 < x - y <=> y < x
val ( INT_SUB_LZERO ) : thm = |- !x. &0 - x = --x
val ( INT_SUB_NEG2 ) : thm = |- !x y. --x - --y = y - x
val ( INT_SUB_RDISTRIB ) : thm = |- !x y z. (x - y) * z = x * z - y * z
val ( INT_SUB_REFL ) : thm = |- !x. x - x = &0
val ( INT_SUB_RNEG ) : thm = |- !x y. x - --y = x + y
val ( INT_SUB_RZERO ) : thm = |- !x. x - &0 = x
val ( INT_SUB_SUB ) : thm = |- !x y. x - y - x = --y
val ( INT_SUB_SUB2 ) : thm = |- !x y. x - (x - y) = y
val ( INT_SUB_TRIANGLE ) : thm = |- !a b c. a - b + b - c = a - c
val ( INT_FORALL_POS ) : thm = |- !P. (!n. P (&n)) <=> (!i. &0 <= i ==> P i)
0..0..0..solved at 3
0..0..0..solved at 3
val ( INT_EXISTS_POS ) : thm = |- !P. (?n. P (&n)) <=> (?i. &0 <= i /\ P i)
0..0..1..solved at 4
0..0..1..2..5..solved at 11
val ( INT_FORALL_ABS ) : thm = |- !P. (!n. P (&n)) <=> (!x. P (abs x))
val ( INT_EXISTS_ABS ) : thm = |- !P. (?n. P (&n)) <=> (?x. P (abs x))
val ( INT_ABS_MUL_1 ) : thm =
  |- !x y. abs (x * y) = &1 <=> abs x = &1 /\ abs y = &1
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
val ( INT_WOP ) : thm =
  |- (?x. &0 <= x /\ P x) <=>
     (?x. &0 <= x /\ P x /\ (!y. &0 <= y /\ P y ==> x <= y))
val ( INT_POW ) : thm = |- x pow 0 = &1 /\ (!n. x pow SUC n = x * x pow n)
val ( INT_ABS ) : thm = |- !x. abs x = (if &0 <= x then x else --x)
val ( INT_GE ) : thm = |- !x y. x >= y <=> y <= x
val ( INT_GT ) : thm = |- !x y. x > y <=> y < x
val ( INT_LT ) : thm = |- !x y. x < y <=> ~(y <= x)
val ( INT_ARITH ) : term -> thm = <fun>
val ( INT_ARITH_TAC ) : tactic = <fun>
val ( ASM_INT_ARITH_TAC ) : tactic = <fun>
val ( INT_SUB ) : thm = |- !x y. x - y = x + --y
val ( INT_MAX ) : thm = |- !x y. max x y = (if x <= y then y else x)
val ( INT_MIN ) : thm = |- !x y. min x y = (if x <= y then x else y)
0..0..solved at 2
0..0..1..5..solved at 9
0..0..1..2..5..8..solved at 14
0..0..2..5..11..23..42..71..111..171..262..solved at 304
0..0..2..solved at 6
val ( INT_ARCH ) : thm = |- !x d. ~(d = &0) ==> (?c. x < c * d)
val ( INT_DIVMOD_EXIST_0 ) : thm =
  |- !m n.
         ?q r.
             if n = &0
             then q = &0 /\ r = m
             else &0 <= r /\ r < abs n /\ m = q * n + r
- : unit = ()
- : unit = ()
val ( INT_DIVISION_0 ) : thm =
  |- !m n.
         if n = &0
         then m div n = &0 /\ m rem n = m
         else &0 <= m rem n /\ m rem n < abs n /\ m = m div n * n + m rem n
0..0..2..solved at 5
0..0..2..solved at 5
0..0..2..solved at 5
val ( INT_DIVISION ) : thm =
  |- !m n.
         ~(n = &0)
         ==> m = m div n * n + m rem n /\ &0 <= m rem n /\ m rem n < abs n
File "/home/student/OCaml/hol_light (gzip)/int.ml", line 694, characters 6-44:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/int.ml", line 707, characters 6-44:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/int.ml", line 719, characters 6-44:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/int.ml", line 730, characters 6-44:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/int.ml", line 741, characters 6-46:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( INT_LE_CONV ) : conv = <fun>
val ( INT_LT_CONV ) : conv = <fun>
val ( INT_GE_CONV ) : conv = <fun>
val ( INT_GT_CONV ) : conv = <fun>
val ( INT_EQ_CONV ) : conv = <fun>
val ( INT_NEG_CONV ) : conv = <fun>
val ( INT_MUL_CONV ) : conv = <fun>
File "/home/student/OCaml/hol_light (gzip)/int.ml", line 791, characters 6-42:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val ( INT_ADD_CONV ) : conv = <fun>
val ( INT_SUB_CONV ) : conv = <fun>
val ( INT_POW_CONV ) : conv = <fun>
val ( INT_ABS_CONV ) : conv = <fun>
val ( INT_MAX_CONV ) : conv = <fun>
val ( INT_MIN_CONV ) : conv = <fun>
val ( INT_POLY_CONV ) : term -> thm = <fun>
val ( INT_RING ) : term -> thm = <fun>
val int_ideal_cofactors : term list -> term -> term list = <fun>
4 basis elements and 1 critical pairs
5 basis elements and 0 critical pairs
Translating certificate to HOL inferences
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
3 basis elements and 2 critical pairs
4 basis elements and 3 critical pairs
5 basis elements and 0 critical pairs
Translating certificate to HOL inferences
val ( INT_DIVMOD_UNIQ ) : thm =
  |- !m n q r.
         m = q * n + r /\ &0 <= r /\ r < abs n ==> m div n = q /\ m rem n = r
0..0..1..2..5..solved at 13
0..0..1..2..5..solved at 13
val ( INT_DIV_CONV ) : term -> thm = <fun>
val ( INT_REM_CONV ) : term -> thm = <fun>
val ( INT_RED_CONV ) : term -> thm = <fun>
val ( INT_REDUCE_CONV ) : conv = <fun>
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val cong : thm = |- !rel x y. (x == y) rel <=> rel x y
val real_mod : thm =
  |- !x y n. real_mod n x y <=> (?q. is_int q /\ x - y = q * n)
- : unit = ()
- : unit = ()
- : unit = ()
val int_divides : thm = |- !b a. a divides b <=> (?x. b = a * x)
- : unit = ()
- : unit = ()
val int_mod : thm = |- !n x y. mod n x y <=> n divides x - y
val int_congruent : thm = |- !x y n. (x == y) (mod n) <=> (?d. x - y = n * d)
- : unit = ()
val int_coprime : thm = |- !a b. coprime (a,b) <=> (?x y. a * x + b * y = &1)
Warning: inventing type variables
val ( INTEGER_TAC ) : tactic = <fun>
val ( INTEGER_RULE ) : term -> thm = <fun>
val ( FORALL_UNCURRY ) : thm = |- !P. (!f. P f) <=> (!f. P (\a b. f (a,b)))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
val ( EXISTS_UNCURRY ) : thm = |- !P. (?f. P f) <=> (?f. P (\a b. f (a,b)))
0..0..1..4..11..25..54..solved at 82
0..0..1..4..solved at 12
val ( WF_INT_MEASURE ) : thm =
  |- !P m.
         (!x. &0 <= m x) /\ (!x. (!y. m y < m x ==> P y) ==> P x)
         ==> (!x. P x)
val ( WF_INT_MEASURE_2 ) : thm =
  |- !P m.
         (!x y. &0 <= m x y) /\
         (!x y. (!x' y'. m x' y' < m x y ==> P x' y') ==> P x y)
         ==> (!x y. P x y)
1 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
0..0..0..2..6..solved at 11
0..0..0..2..6..solved at 11
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
3 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
3 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
3 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
4 basis elements and 1 critical pairs
4 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
3 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
val ( INT_GCD_EXISTS ) : thm =
  |- !a b. ?d. d divides a /\ d divides b /\ (?x y. d = a * x + b * y)
2 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
2 basis elements and 0 critical pairs
1 basis elements and 0 critical pairs
Translating certificate to HOL inferences
0..0..0..0..0..solved at 5
0..0..0..0..0..2..7..12..27..solved at 38
val ( INT_GCD_EXISTS_POS ) : thm =
  |- !a b.
         ?d. &0 <= d /\
             d divides a /\
             d divides b /\
             (?x y. d = a * x + b * y)
- : unit = ()
val int_gcd : thm =
  |- !a b.
         &0 <= gcd (a,b) /\
         gcd (a,b) divides a /\
         gcd (a,b) divides b /\
         (?x y. gcd (a,b) = a * x + b * y)
val ( INTEGER_TAC ) : tactic = <fun>
val ( INTEGER_RULE ) : term -> thm = <fun>
val num_of_int : thm = |- !x. num_of_int x = (@n. &n = x)
val ( NUM_OF_INT_OF_NUM ) : thm = |- !n. num_of_int (&n) = n
0..0..solved at 2
val ( INT_OF_NUM_OF_INT ) : thm = |- !x. &0 <= x ==> &(num_of_int x) = x
0..0..1..solved at 4
0..0..1..2..3..solved at 8
val ( NUM_OF_INT ) : thm = |- !x. &0 <= x <=> &(num_of_int x) = x
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val num_divides : thm = |- !a b. a divides b <=> &a divides &b
val num_mod : thm = |- !n x y. mod n x y <=> mod &n (&x) (&y)
val num_congruent : thm = |- !x y n. (x == y) (mod n) <=> (&x == &y) (mod &n)
val num_coprime : thm = |- !a b. coprime (a,b) <=> coprime (&a,&b)
val num_gcd : thm = |- !a b. gcd (a,b) = num_of_int (gcd (&a,&b))
0..0..1..solved at 4
0..0..1..solved at 4
val ( NUM_TO_INT_CONV ) : conv = <fun>
val ( ARITH_RULE ) : term -> thm = <fun>
val ( ARITH_TAC ) : tactic = <fun>
val ( ASM_ARITH_TAC ) : tactic = <fun>
val ( NUM_GCD ) : thm = |- !a b. &(gcd (a,b)) = gcd (&a,&b)
0..0..0..solved at 3
0..0..0..solved at 3
val ( NUMBER_TAC ) : tactic = <fun>
val ( NUMBER_RULE ) : term -> thm = <fun>
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val ( IN ) : thm = |- !P x. x IN P <=> P x
val ( EXTENSION ) : thm = |- !s t. s = t <=> (!x. x IN s <=> x IN t)
val ( GSPEC ) : thm = |- !p. GSPEC p = p
Warning: inventing type variables
val ( SETSPEC ) : thm = |- !P v t. SETSPEC v P t <=> P /\ v = t
Warning: inventing type variables
0..0..solved at 2
0..0..0..solved at 3
0..0..solved at 2
0..0..0..solved at 3
val ( IN_ELIM_THM ) : thm =
  |- (!P x. x IN GSPEC (\v. P (SETSPEC v)) <=> P (\p t. p /\ x = t)) /\
     (!p x. x IN {y | p y} <=> p x) /\
     (!P x. GSPEC (\v. P (SETSPEC v)) x <=> P (\p t. p /\ x = t)) /\
     (!p x. {y | p y} x <=> p x) /\
     (!p x. x IN (\y. p y) <=> p x)
val ( EMPTY ) : thm = |- {} = (\x. F)
val ( INSERT_DEF ) : thm = |- !s x. x INSERT s = (\y. y IN s \/ y = x)
val ( UNIV ) : thm = |- (:A) = (\x. T)
val ( UNION ) : thm = |- !s t. s UNION t = {x | x IN s \/ x IN t}
val ( UNIONS ) : thm = |- !s. UNIONS s = {x | ?u. u IN s /\ x IN u}
val ( INTER ) : thm = |- !s t. s INTER t = {x | x IN s /\ x IN t}
val ( INTERS ) : thm = |- !s. INTERS s = {x | !u. u IN s ==> x IN u}
val ( DIFF ) : thm = |- !s t. s DIFF t = {x | x IN s /\ ~(x IN t)}
val ( INSERT ) : thm = |- x INSERT s = {y | y IN s \/ y = x}
val ( DELETE ) : thm = |- !s x. s DELETE x = {y | y IN s /\ ~(y = x)}
val ( SUBSET ) : thm = |- !s t. s SUBSET t <=> (!x. x IN s ==> x IN t)
val ( PSUBSET ) : thm = |- !s t. s PSUBSET t <=> s SUBSET t /\ ~(s = t)
val ( DISJOINT ) : thm = |- !s t. DISJOINT s t <=> s INTER t = {}
val ( SING ) : thm = |- !s. SING s <=> (?x. s = {x})
val ( FINITE_RULES ) : thm =
  |- FINITE {} /\ (!x s. FINITE s ==> FINITE (x INSERT s))
val ( FINITE_INDUCT ) : thm =
  |- !FINITE'. FINITE' {} /\ (!x s. FINITE' s ==> FINITE' (x INSERT s))
               ==> (!a. FINITE a ==> FINITE' a)
val ( FINITE_CASES ) : thm =
  |- !a. FINITE a <=> a = {} \/ (?x s. a = x INSERT s /\ FINITE s)
val ( INFINITE ) : thm = |- !s. INFINITE s <=> ~FINITE s
val ( IMAGE ) : thm = |- !s f. IMAGE f s = {y | ?x. x IN s /\ y = f x}
val ( INJ ) : thm =
  |- !t s f.
         INJ f s t <=>
         (!x. x IN s ==> f x IN t) /\
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
val ( SURJ ) : thm =
  |- !t s f.
         SURJ f s t <=>
         (!x. x IN s ==> f x IN t) /\
         (!x. x IN t ==> (?y. y IN s /\ f y = x))
val ( BIJ ) : thm = |- !f s t. BIJ f s t <=> INJ f s t /\ SURJ f s t
val ( CHOICE ) : thm = |- !s. CHOICE s = (@x. x IN s)
val ( REST ) : thm = |- !s. REST s = s DELETE CHOICE s
val ( NOT_IN_EMPTY ) : thm = |- !x. ~(x IN {})
val ( IN_UNIV ) : thm = |- !x. x IN (:A)
val ( IN_UNION ) : thm = |- !s t x. x IN s UNION t <=> x IN s \/ x IN t
val ( IN_UNIONS ) : thm = |- !s x. x IN UNIONS s <=> (?t. t IN s /\ x IN t)
val ( IN_INTER ) : thm = |- !s t x. x IN s INTER t <=> x IN s /\ x IN t
val ( IN_INTERS ) : thm = |- !s x. x IN INTERS s <=> (!t. t IN s ==> x IN t)
val ( IN_DIFF ) : thm = |- !s t x. x IN s DIFF t <=> x IN s /\ ~(x IN t)
val ( IN_INSERT ) : thm = |- !x y s. x IN y INSERT s <=> x = y \/ x IN s
val ( IN_DELETE ) : thm = |- !s x y. x IN s DELETE y <=> x IN s /\ ~(x = y)
val ( IN_SING ) : thm = |- !x y. x IN {y} <=> x = y
val ( IN_IMAGE ) : thm =
  |- !y s f. y IN IMAGE f s <=> (?x. y = f x /\ x IN s)
val ( IN_REST ) : thm = |- !x s. x IN REST s <=> x IN s /\ ~(x = CHOICE s)
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val ( FORALL_IN_INSERT ) : thm =
  |- !P a s. (!x. x IN a INSERT s ==> P x) <=> P a /\ (!x. x IN s ==> P x)
Warning: inventing type variables
0..0..solved at 2
0..0..1..solved at 5
0..0..0..solved at 4
0..0..0..solved at 3
val ( EXISTS_IN_INSERT ) : thm =
  |- !P a s. (?x. x IN a INSERT s /\ P x) <=> P a \/ (?x. x IN s /\ P x)
val ( CHOICE_DEF ) : thm = |- !s. ~(s = {}) ==> CHOICE s IN s
val ( SET_TAC ) : thm list -> tactic = <fun>
val ( SET_RULE ) : term -> thm = <fun>
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 4
val ( NOT_EQUAL_SETS ) : thm =
  |- !s t. ~(s = t) <=> (?x. x IN t <=> ~(x IN s))
0..0..solved at 2
0..0..solved at 2
val ( MEMBER_NOT_EMPTY ) : thm = |- !s. (?x. x IN s) <=> ~(s = {})
val ( UNIV_NOT_EMPTY ) : thm = |- ~((:A) = {})
val ( EMPTY_NOT_UNIV ) : thm = |- ~({} = (:A))
val ( EQ_UNIV ) : thm = |- (!x. x IN s) <=> s = (:A)
0..0..1..3..solved at 7
val ( SUBSET_TRANS ) : thm =
  |- !s t u. s SUBSET t /\ t SUBSET u ==> s SUBSET u
val ( SUBSET_REFL ) : thm = |- !s. s SUBSET s
0..0..1..solved at 4
0..0..1..solved at 4
val ( SUBSET_ANTISYM ) : thm = |- !s t. s SUBSET t /\ t SUBSET s ==> s = t
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 4
val ( SUBSET_ANTISYM_EQ ) : thm = |- !s t. s SUBSET t /\ t SUBSET s <=> s = t
val ( EMPTY_SUBSET ) : thm = |- !s. {} SUBSET s
val ( SUBSET_EMPTY ) : thm = |- !s. s SUBSET {} <=> s = {}
val ( SUBSET_UNIV ) : thm = |- !s. s SUBSET (:A)
val ( UNIV_SUBSET ) : thm = |- !s. (:A) SUBSET s <=> s = (:A)
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
val ( SING_SUBSET ) : thm = |- !s x. {x} SUBSET s <=> x IN s
0..0..3..solved at 8
0..0..2..solved at 6
0..0..3..solved at 10
0..0..2..solved at 7
0..0..3..solved at 8
0..0..2..solved at 6
0..0..3..8..solved at 12
0..0..2..6..solved at 10
val ( PSUBSET_TRANS ) : thm =
  |- !s t u. s PSUBSET t /\ t PSUBSET u ==> s PSUBSET u
0..0..2..solved at 7
0..0..1..solved at 4
0..0..2..5..solved at 9
0..0..1..3..solved at 7
val ( PSUBSET_SUBSET_TRANS ) : thm =
  |- !s t u. s PSUBSET t /\ t SUBSET u ==> s PSUBSET u
0..0..2..solved at 7
0..0..1..solved at 5
0..0..2..6..solved at 10
0..0..1..3..solved at 7
val ( SUBSET_PSUBSET_TRANS ) : thm =
  |- !s t u. s SUBSET t /\ t PSUBSET u ==> s PSUBSET u
val ( PSUBSET_IRREFL ) : thm = |- !s. ~(s PSUBSET s)
0..0..solved at 2
val ( NOT_PSUBSET_EMPTY ) : thm = |- !s. ~(s PSUBSET {})
0..0..solved at 2
val ( NOT_UNIV_PSUBSET ) : thm = |- !s. ~((:A) PSUBSET s)
0..0..solved at 2
0..0..solved at 2
val ( PSUBSET_UNIV ) : thm = |- !s. s PSUBSET (:A) <=> (?x. ~(x IN s))
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 5
0..0..1..solved at 4
0..0..2..solved at 5
0..0..1..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 5
0..0..1..solved at 4
val ( PSUBSET_ALT ) : thm =
  |- !s t. s PSUBSET t <=> s SUBSET t /\ (?a. a IN t /\ ~(a IN s))
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
val ( UNION_ASSOC ) : thm =
  |- !s t u. (s UNION t) UNION u = s UNION t UNION u
val ( UNION_IDEMPOT ) : thm = |- !s. s UNION s = s
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
val ( UNION_COMM ) : thm = |- !s t. s UNION t = t UNION s
0..0..solved at 3
0..0..solved at 2
val ( SUBSET_UNION ) : thm =
  |- (!s t. s SUBSET s UNION t) /\ (!s t. s SUBSET t UNION s)
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
val ( SUBSET_UNION_ABSORPTION ) : thm = |- !s t. s SUBSET t <=> s UNION t = t
val ( UNION_EMPTY ) : thm = |- (!s. {} UNION s = s) /\ (!s. s UNION {} = s)
val ( UNION_UNIV ) : thm =
  |- (!s. (:A) UNION s = (:A)) /\ (!s. s UNION (:A) = (:A))
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
val ( EMPTY_UNION ) : thm = |- !s t. s UNION t = {} <=> s = {} /\ t = {}
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..1..solved at 5
0..0..1..solved at 4
val ( UNION_SUBSET ) : thm =
  |- !s t u. s UNION t SUBSET u <=> s SUBSET u /\ t SUBSET u
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( INTER_ASSOC ) : thm =
  |- !s t u. (s INTER t) INTER u = s INTER t INTER u
val ( INTER_IDEMPOT ) : thm = |- !s. s INTER s = s
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( INTER_COMM ) : thm = |- !s t. s INTER t = t INTER s
0..0..solved at 2
0..0..solved at 2
val ( INTER_SUBSET ) : thm =
  |- (!s t. s INTER t SUBSET s) /\ (!s t. t INTER s SUBSET s)
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
val ( SUBSET_INTER_ABSORPTION ) : thm = |- !s t. s SUBSET t <=> s INTER t = s
val ( INTER_EMPTY ) : thm = |- (!s. {} INTER s = {}) /\ (!s. s INTER {} = {})
val ( INTER_UNIV ) : thm =
  |- (!s. (:A) INTER s = s) /\ (!s. s INTER (:A) = s)
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
val ( SUBSET_INTER ) : thm =
  |- !s t u. s SUBSET t INTER u <=> s SUBSET t /\ s SUBSET u
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( UNION_OVER_INTER ) : thm =
  |- !s t u. s INTER (t UNION u) = s INTER t UNION s INTER u
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( INTER_OVER_UNION ) : thm =
  |- !s t u. s UNION t INTER u = (s UNION t) INTER (s UNION u)
0..0..0..solved at 3
0..0..0..solved at 3
val ( IN_DISJOINT ) : thm = |- !s t. DISJOINT s t <=> ~(?x. x IN s /\ x IN t)
0..0..0..solved at 3
0..0..0..solved at 3
val ( DISJOINT_SYM ) : thm = |- !s t. DISJOINT s t <=> DISJOINT t s
val ( DISJOINT_EMPTY ) : thm = |- !s. DISJOINT {} s /\ DISJOINT s {}
val ( DISJOINT_EMPTY_REFL ) : thm = |- !s. s = {} <=> DISJOINT s s
0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..solved at 4
0..0..0..solved at 3
val ( DISJOINT_UNION ) : thm =
  |- !s t u. DISJOINT (s UNION t) u <=> DISJOINT s u /\ DISJOINT t u
val ( DIFF_EMPTY ) : thm = |- !s. s DIFF {} = s
val ( EMPTY_DIFF ) : thm = |- !s. {} DIFF s = {}
val ( DIFF_UNIV ) : thm = |- !s. s DIFF (:A) = {}
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( DIFF_DIFF ) : thm = |- !s t. s DIFF t DIFF t = s DIFF t
0..0..solved at 2
val ( DIFF_EQ_EMPTY ) : thm = |- !s. s DIFF s = {}
Warning: inventing type variables
0..0..solved at 3
val ( SUBSET_DIFF ) : thm = |- !s t. s DIFF t SUBSET s
val ( COMPONENT ) : thm = |- !x s. x IN x INSERT s
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val ( DECOMPOSITION ) : thm =
  |- !s x. x IN s <=> (?t. s = x INSERT t /\ ~(x IN t))
0..0..1..5..16..36..114..solved at 121
val ( SET_CASES ) : thm =
  |- !s. s = {} \/ (?x t. s = x INSERT t /\ ~(x IN t))
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
val ( ABSORPTION ) : thm = |- !x s. x IN s <=> x INSERT s = s
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
val ( INSERT_INSERT ) : thm = |- !x s. x INSERT x INSERT s = x INSERT s
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
val ( INSERT_COMM ) : thm =
  |- !x y s. x INSERT y INSERT s = y INSERT x INSERT s
val ( INSERT_UNIV ) : thm = |- !x. x INSERT (:A) = (:A)
0..0..solved at 3
val ( NOT_INSERT_EMPTY ) : thm = |- !x s. ~(x INSERT s = {})
0..0..solved at 3
val ( NOT_EMPTY_INSERT ) : thm = |- !x s. ~({} = x INSERT s)
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
val ( INSERT_UNION ) : thm =
  |- !x s t.
         x INSERT s UNION t =
         (if x IN t then s UNION t else x INSERT (s UNION t))
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
val ( INSERT_UNION_EQ ) : thm =
  |- !x s t. x INSERT s UNION t = x INSERT (s UNION t)
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( INSERT_INTER ) : thm =
  |- !x s t.
         x INSERT s INTER t =
         (if x IN t then x INSERT (s INTER t) else s INTER t)
0..0..0..solved at 3
0..0..0..solved at 4
0..0..solved at 2
0..0..1..solved at 5
val ( DISJOINT_INSERT ) : thm =
  |- !x s t. DISJOINT (x INSERT s) t <=> DISJOINT s t /\ ~(x IN t)
0..0..1..solved at 5
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val ( INSERT_SUBSET ) : thm =
  |- !x s t. x INSERT s SUBSET t <=> x IN t /\ s SUBSET t
0..0..2..4..12..21..solved at 31
0..0..3..solved at 6
val ( SUBSET_INSERT ) : thm =
  |- !x s. ~(x IN s) ==> (!t. s SUBSET x INSERT t <=> s SUBSET t)
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( INSERT_DIFF ) : thm =
  |- !s t x.
         x INSERT s DIFF t =
         (if x IN t then s DIFF t else x INSERT (s DIFF t))
Warning: inventing type variables
val ( INSERT_AC ) : thm =
  |- x INSERT y INSERT s = y INSERT x INSERT s /\
     x INSERT x INSERT s = x INSERT s
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( INTER_ACI ) : thm =
  |- p INTER q = q INTER p /\
     (p INTER q) INTER r = p INTER q INTER r /\
     p INTER q INTER r = q INTER p INTER r /\
     p INTER p = p /\
     p INTER p INTER q = p INTER q
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
val ( UNION_ACI ) : thm =
  |- p UNION q = q UNION p /\
     (p UNION q) UNION r = p UNION q UNION r /\
     p UNION q UNION r = q UNION p UNION r /\
     p UNION p = p /\
     p UNION p UNION q = p UNION q
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..0..solved at 3
val ( DELETE_NON_ELEMENT ) : thm = |- !x s. ~(x IN s) <=> s DELETE x = s
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( IN_DELETE_EQ ) : thm =
  |- !s x x'. (x IN s <=> x' IN s) <=> x IN s DELETE x' <=> x' IN s DELETE x
val ( EMPTY_DELETE ) : thm = |- !x. {} DELETE x = {}
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( DELETE_DELETE ) : thm = |- !x s. s DELETE x DELETE x = s DELETE x
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
val ( DELETE_COMM ) : thm =
  |- !x y s. s DELETE x DELETE y = s DELETE y DELETE x
0..0..solved at 3
val ( DELETE_SUBSET ) : thm = |- !x s. s DELETE x SUBSET s
0..0..0..solved at 3
0..0..1..solved at 4
0..0..2..solved at 5
0..0..solved at 2
val ( SUBSET_DELETE ) : thm =
  |- !x s t. s SUBSET t DELETE x <=> ~(x IN s) /\ s SUBSET t
0..0..2..4..solved at 8
0..0..2..4..solved at 8
val ( SUBSET_INSERT_DELETE ) : thm =
  |- !x s t. s SUBSET x INSERT t <=> s DELETE x SUBSET t
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val ( DIFF_INSERT ) : thm = |- !s t x. s DIFF x INSERT t = s DELETE x DIFF t
0..0..solved at 2
0..0..1..3..9..18..34..59..100..167..solved at 240
0..0..1..solved at 4
0..0..solved at 2
0..0..2..solved at 5
0..0..1..3..solved at 7
val ( PSUBSET_INSERT_SUBSET ) : thm =
  |- !s t. s PSUBSET t <=> (?x. ~(x IN s) /\ x INSERT s SUBSET t)
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 5
0..0..1..solved at 4
0..0..2..solved at 5
0..0..1..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 5
0..0..1..solved at 4
val ( PSUBSET_MEMBER ) : thm =
  |- !s t. s PSUBSET t <=> s SUBSET t /\ (?y. y IN t /\ ~(y IN s))
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( DELETE_INSERT ) : thm =
  |- !x y s.
         (x INSERT s) DELETE y =
         (if x = y then s DELETE y else x INSERT (s DELETE y))
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( INSERT_DELETE ) : thm = |- !x s. x IN s ==> x INSERT (s DELETE x) = s
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( DELETE_INTER ) : thm =
  |- !s t x. s DELETE x INTER t = (s INTER t) DELETE x
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val ( DISJOINT_DELETE_SYM ) : thm =
  |- !s t x. DISJOINT (s DELETE x) t <=> DISJOINT (t DELETE x) s
Warning: inventing type variables
val ( UNIONS_0 ) : thm = |- UNIONS {} = {}
Warning: inventing type variables
0..0..solved at 2
0..0..0..solved at 3
val ( UNIONS_1 ) : thm = |- UNIONS {s} = s
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..0..solved at 5
0..0..0..solved at 3
val ( UNIONS_2 ) : thm = |- UNIONS {s, t} = s UNION t
Warning: inventing type variables
0..0..solved at 2
0..0..1..solved at 5
0..0..0..solved at 4
0..0..0..solved at 3
val ( UNIONS_INSERT ) : thm = |- UNIONS (s INSERT u) = s UNION UNIONS u
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val ( FORALL_IN_UNIONS ) : thm =
  |- !P s. (!x. x IN UNIONS s ==> P x) <=> (!t x. t IN s /\ x IN t ==> P x)
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..0..0..solved at 4
val ( EXISTS_IN_UNIONS ) : thm =
  |- !P s. (?x. x IN UNIONS s /\ P x) <=> (?t x. t IN s /\ x IN t /\ P x)
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
val ( EMPTY_UNIONS ) : thm = |- !s. UNIONS s = {} <=> (!t. t IN s ==> t = {})
Warning: inventing type variables
0..0..0..0..3..11..solved at 23
0..0..0..2..solved at 7
0..0..1..solved at 4
0..0..0..0..3..11..solved at 23
0..0..1..solved at 5
0..0..0..2..solved at 6
val ( INTER_UNIONS ) : thm =
  |- (!s t. UNIONS s INTER t = UNIONS {x INTER t | x IN s}) /\
     (!s t. t INTER UNIONS s = UNIONS {t INTER x | x IN s})
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val ( UNIONS_SUBSET ) : thm =
  |- !f t. UNIONS f SUBSET t <=> (!s. s IN f ==> s SUBSET t)
Warning: inventing type variables
0..0..0..1..solved at 5
val ( SUBSET_UNIONS ) : thm =
  |- !f g. f SUBSET g ==> UNIONS f SUBSET UNIONS g
Warning: inventing type variables
0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..solved at 4
0..0..0..solved at 3
val ( UNIONS_UNION ) : thm =
  |- !s t. UNIONS (s UNION t) = UNIONS s UNION UNIONS t
val ( INTERS_0 ) : thm = |- INTERS {} = (:A)
Warning: inventing type variables
0..0..1..solved at 4
0..0..solved at 2
val ( INTERS_1 ) : thm = |- INTERS {s} = s
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
val ( INTERS_2 ) : thm = |- INTERS {s, t} = s INTER t
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val ( INTERS_INSERT ) : thm = |- INTERS (s INSERT u) = s INTER INTERS u
Warning: inventing type variables
0..0..solved at 2
0..0..1..solved at 6
0..0..0..solved at 4
0..0..0..solved at 3
val ( IMAGE_CLAUSES ) : thm =
  |- IMAGE f {} = {} /\ IMAGE f (x INSERT s) = f x INSERT IMAGE f s
Warning: inventing type variables
0..0..0..solved at 5
0..0..0..solved at 3
0..0..0..solved at 5
0..0..0..solved at 3
val ( IMAGE_UNION ) : thm =
  |- !f s t. IMAGE f (s UNION t) = IMAGE f s UNION IMAGE f t
Warning: inventing type variables
val ( IMAGE_ID ) : thm = |- !s. IMAGE (\x. x) s = s
Warning: inventing type variables
val ( IMAGE_I ) : thm = |- !s. IMAGE I s = s
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..0..solved at 3
val ( IMAGE_o ) : thm = |- !f g s. IMAGE (f o g) s = IMAGE f (IMAGE g s)
Warning: inventing type variables
0..0..0..2..solved at 6
val ( IMAGE_SUBSET ) : thm =
  |- !f s t. s SUBSET t ==> IMAGE f s SUBSET IMAGE f t
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
0..0..0..0..4..10..16..31..solved at 42
val ( IMAGE_INTER_INJ ) : thm =
  |- !f s t.
         (!x y. f x = f y ==> x = y)
         ==> IMAGE f (s INTER t) = IMAGE f s INTER IMAGE f t
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..2..3..7..solved at 16
0..0..0..2..4..solved at 9
val ( IMAGE_DIFF_INJ ) : thm =
  |- !f s t.
         (!x y. f x = f y ==> x = y)
         ==> IMAGE f (s DIFF t) = IMAGE f s DIFF IMAGE f t
Warning: inventing type variables
0..0..1..solved at 6
0..0..1..3..7..solved at 12
0..0..1..3..7..solved at 12
val ( IMAGE_DELETE_INJ ) : thm =
  |- !f s a.
         (!x. f x = f a ==> x = a)
         ==> IMAGE f (s DELETE a) = IMAGE f s DELETE f a
Warning: inventing type variables
0..0..0..solved at 3
0..0..solved at 2
val ( IMAGE_EQ_EMPTY ) : thm = |- !f s. IMAGE f s = {} <=> s = {}
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..solved at 4
val ( FORALL_IN_IMAGE ) : thm =
  |- !f s. (!y. y IN IMAGE f s ==> P y) <=> (!x. x IN s ==> P (f x))
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..0..solved at 4
val ( EXISTS_IN_IMAGE ) : thm =
  |- !f s. (?y. y IN IMAGE f s /\ P y) <=> (?x. x IN s /\ P (f x))
0..0..1..solved at 4
0..0..solved at 2
0..0..0..0..1..2..3..6..11..19..solved at 31
0..0..solved at 2
val ( SUBSET_IMAGE ) : thm =
  |- !f s t. s SUBSET IMAGE f t <=> (?u. u SUBSET t /\ s = IMAGE f u)
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..0..solved at 4
val ( EXISTS_SUBSET_IMAGE ) : thm =
  |- !P f s.
         (?t. t SUBSET IMAGE f s /\ P t) <=>
         (?t. t SUBSET s /\ P (IMAGE f t))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..2..solved at 5
val ( IMAGE_CONST ) : thm =
  |- !s c. IMAGE (\x. c) s = (if s = {} then {} else {c})
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
val ( SIMPLE_IMAGE ) : thm = |- !f s. {f x | x IN s} = IMAGE f s
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
val ( SIMPLE_IMAGE_GEN ) : thm = |- !f p. {f x | P x} = IMAGE f {x | P x}
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..0..0..solved at 4
val ( IMAGE_UNIONS ) : thm =
  |- !f s. IMAGE f (UNIONS s) = UNIONS (IMAGE (IMAGE f) s)
Warning: inventing type variables
0..0..0..solved at 3
val ( FUN_IN_IMAGE ) : thm = |- !f s x. x IN s ==> f x IN IMAGE f s
Warning: inventing type variables
0..0..1..solved at 4
0..0..0..1..2..3..5..7..9..15..21..27..solved at 44
val ( SURJECTIVE_IMAGE_EQ ) : thm =
  |- !s t.
         (!y. y IN t ==> (?x. f x = y)) /\ (!x. f x IN t <=> x IN s)
         ==> IMAGE f s = t
Warning: inventing type variables
val ( EMPTY_GSPEC ) : thm = |- {x | F} = {}
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
val ( SING_GSPEC ) : thm =
  |- (!a. {x | x = a} = {a}) /\ (!a. {x | a = x} = {a})
Warning: inventing type variables
0..0..1..2..3..7..12..17..28..39..50..77..104..131..solved at 160
0..0..0..solved at 3
val ( IN_ELIM_PAIR_THM ) : thm = |- !P a b. a,b IN {x,y | P x y} <=> P a b
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..2..solved at 6
0..0..1..solved at 4
val ( FORALL_IN_GSPEC ) : thm =
  |- (!P f. (!z. z IN {f x | P x} ==> Q z) <=> (!x. P x ==> Q (f x))) /\
     (!P f.
          (!z. z IN {f x y | P x y} ==> Q z) <=> (!x y. P x y ==> Q (f x y))) /\
     (!P f.
          (!z. z IN {f w x y | P w x y} ==> Q z) <=>
          (!w x y. P w x y ==> Q (f w x y)))
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..0..solved at 4
val ( EXISTS_IN_GSPEC ) : thm =
  |- (!P f. (?z. z IN {f x | P x} /\ Q z) <=> (?x. P x /\ Q (f x))) /\
     (!P f. (?z. z IN {f x y | P x y} /\ Q z) <=> (?x y. P x y /\ Q (f x y))) /\
     (!P f.
          (?z. z IN {f w x y | P w x y} /\ Q z) <=>
          (?w x y. P w x y /\ Q (f w x y)))
0..0..1..2..5..9..15..25..40..66..123..229..496..solved at 530
val ( SET_PROVE_CASES ) : thm =
  |- !P. P {} /\ (!a s. ~(a IN s) ==> P (a INSERT s)) ==> (!s. P s)
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..0..solved at 4
val ( UNIONS_IMAGE ) : thm =
  |- !f s. UNIONS (IMAGE f s) = {y | ?x. x IN s /\ y IN f x}
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..solved at 4
val ( INTERS_IMAGE ) : thm =
  |- !f s. INTERS (IMAGE f s) = {y | !x. x IN s ==> y IN f x}
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..0..solved at 4
val ( UNIONS_GSPEC ) : thm =
  |- (!P f. UNIONS {f x | P x} = {a | ?x. P x /\ a IN f x}) /\
     (!P f. UNIONS {f x y | P x y} = {a | ?x y. P x y /\ a IN f x y}) /\
     (!P f.
          UNIONS {f x y z | P x y z} = {a | ?x y z. P x y z /\ a IN f x y z})
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..2..solved at 6
0..0..1..solved at 4
0..0..1..2..solved at 6
0..0..1..solved at 4
val ( INTERS_GSPEC ) : thm =
  |- (!P f. INTERS {f x | P x} = {a | !x. P x ==> a IN f x}) /\
     (!P f. INTERS {f x y | P x y} = {a | !x y. P x y ==> a IN f x y}) /\
     (!P f.
          INTERS {f x y z | P x y z} = {a | !x y z. P x y z ==> a IN f x y z})
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( FINITE_INDUCT_STRONG ) : thm =
  |- !P. P {} /\ (!x s. P s /\ ~(x IN s) /\ FINITE s ==> P (x INSERT s))
         ==> (!s. FINITE s ==> P s)
Warning: inventing type variables
val ( FINITE_EMPTY ) : thm = |- FINITE {}
0..0..1..2..5..9..15..solved at 24
0..0..2..4..solved at 8
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..2..4..12..21..solved at 31
val ( FINITE_SUBSET ) : thm = |- !s t. FINITE t /\ s SUBSET t ==> FINITE s
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
0..0..1..3..solved at 7
val ( FINITE_UNION_IMP ) : thm =
  |- !s t. FINITE s /\ FINITE t ==> FINITE (s UNION t)
0..0..solved at 3
0..0..solved at 2
val ( FINITE_UNION ) : thm =
  |- !s t. FINITE (s UNION t) <=> FINITE s /\ FINITE t
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val ( FINITE_INTER ) : thm =
  |- !s t. FINITE s \/ FINITE t ==> FINITE (s INTER t)
0..0..solved at 2
val ( FINITE_INSERT ) : thm = |- !s x. FINITE (x INSERT s) <=> FINITE s
Warning: inventing type variables
val ( FINITE_SING ) : thm = |- !a. FINITE {a}
0..0..0..4..solved at 10
val ( FINITE_DELETE_IMP ) : thm = |- !s x. FINITE s ==> FINITE (s DELETE x)
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( FINITE_DELETE ) : thm = |- !s x. FINITE (s DELETE x) <=> FINITE s
Warning: inventing type variables
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 5
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..3..solved at 7
0..0..3..solved at 9
val ( FINITE_FINITE_UNIONS ) : thm =
  |- !s. FINITE s ==> (FINITE (UNIONS s) <=> (!t. t IN s ==> FINITE t))
0..0..solved at 2
0..0..1..solved at 6
0..0..0..solved at 3
0..0..0..solved at 4
val ( FINITE_IMAGE_EXPAND ) : thm =
  |- !f s. FINITE s ==> FINITE {y | ?x. x IN s /\ y = f x}
val ( FINITE_IMAGE ) : thm = |- !f s. FINITE s ==> FINITE (IMAGE f s)
0..0..solved at 2
0..0..1..solved at 5
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..2..4..8..19..34..solved at 50
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( FINITE_IMAGE_INJ_GENERAL ) : thm =
  |- !f A s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\ FINITE A
         ==> FINITE {x | x IN s /\ f x IN A}
0..0..0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
val ( FINITE_FINITE_PREIMAGE_GENERAL ) : thm =
  |- !f s t.
         FINITE t /\ (!y. y IN t ==> FINITE {x | x IN s /\ f x = y})
         ==> FINITE {x | x IN s /\ f x IN t}
val ( FINITE_FINITE_PREIMAGE ) : thm =
  |- !f t.
         FINITE t /\ (!y. y IN t ==> FINITE {x | f x = y})
         ==> FINITE {x | f x IN t}
0..0..solved at 2
0..0..solved at 2
0..0..0..solved at 3
val ( FINITE_IMAGE_INJ_EQ ) : thm =
  |- !f s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> (FINITE (IMAGE f s) <=> FINITE s)
val ( FINITE_IMAGE_INJ ) : thm =
  |- !f A. (!x y. f x = f y ==> x = y) /\ FINITE A ==> FINITE {x | f x IN A}
0..0..0..solved at 3
val ( INFINITE_IMAGE_INJ ) : thm =
  |- !f. (!x y. f x = f y ==> x = y)
         ==> (!s. INFINITE s ==> INFINITE (IMAGE f s))
Warning: inventing type variables
0..0..0..solved at 3
val ( INFINITE_NONEMPTY ) : thm = |- !s. INFINITE s ==> ~(s = {})
0..0..solved at 2
0..0..solved at 2
val ( INFINITE_DIFF_FINITE ) : thm =
  |- !s t. INFINITE s /\ FINITE t ==> INFINITE (s DIFF t)
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..2..5..11..18..30..47..64..100..164..229..solved at 260
0..0..0..2..4..8..15..25..36..52..71..99..148..216..304..431..solved at 473
0..0..1..2..4..9..17..32..57..89..138..228..321..452..649..887..1226..1746..2324..3091..solved at 3446
val ( FINITE_SUBSET_IMAGE ) : thm =
  |- !f s t.
         FINITE t /\ t SUBSET IMAGE f s <=>
         (?s'. FINITE s' /\ s' SUBSET s /\ t = IMAGE f s')
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..0..0..0..solved at 5
val ( EXISTS_FINITE_SUBSET_IMAGE ) : thm =
  |- !P f s.
         (?t. FINITE t /\ t SUBSET IMAGE f s /\ P t) <=>
         (?t. FINITE t /\ t SUBSET s /\ P (IMAGE f t))
0..0..0..0..1..4..9..17..26..35..50..65..105..solved at 128
val ( FINITE_SUBSET_IMAGE_IMP ) : thm =
  |- !f s t.
         FINITE t /\ t SUBSET IMAGE f s
         ==> (?s'. FINITE s' /\ s' SUBSET s /\ t SUBSET IMAGE f s')
Warning: inventing type variables
0..0..1..2..solved at 6
val ( FINITE_DIFF ) : thm = |- !s t. FINITE s ==> FINITE (s DIFF t)
val ( FINREC ) : thm =
  |- (FINREC f b s a 0 <=> s = {} /\ a = b) /\
     (FINREC f b s a (SUC n) <=>
      (?x c. x IN s /\ FINREC f b (s DELETE x) c n /\ a = f x c))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..0..0..1..5..11..solved at 19
val ( FINREC_1_LEMMA ) : thm =
  |- !f b s a. FINREC f b s a (SUC 0) <=> (?x. s = {x} /\ a = f x b)
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( FINREC_SUC_LEMMA ) : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (!n s z.
                  FINREC f b s z (SUC n)
                  ==> (!x. x IN s
                           ==> (?w. FINREC f b (s DELETE x) w n /\ z = f x w)))
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..1..2..7..13..23..34..45..56..80..104..141..237..solved at 327
0..0..1..3..7..17..solved at 23
val ( FINREC_UNIQUE_LEMMA ) : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (!n1 n2 s a1 a2.
                  FINREC f b s a1 n1 /\ FINREC f b s a2 n2
                  ==> a1 = a2 /\ n1 = n2)
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( FINREC_EXISTS_LEMMA ) : thm =
  |- !f b s. FINITE s ==> (?a n. FINREC f b s a n)
0..0..1..2..solved at 6
0..0..solved at 2
0..0..1..solved at 4
val ( FINREC_FUN_LEMMA ) : thm =
  |- !P R.
         (!s. P s ==> (?a n. R s a n)) /\
         (!n1 n2 s a1 a2. R s a1 n1 /\ R s a2 n2 ==> a1 = a2 /\ n1 = n2)
         ==> (?f. !s a. P s ==> ((?n. R s a n) <=> f s = a))
0..0..solved at 3
val ( FINREC_FUN ) : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (?g. g {} = b /\
                  (!s x. FINITE s /\ x IN s ==> g s = f x (g (s DELETE x))))
0..0..2..solved at 5
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( SET_RECURSION_LEMMA ) : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> (?g. g {} = b /\
                  (!x s.
                       FINITE s
                       ==> g (x INSERT s) =
                           (if x IN s then g s else f x (g s))))
Warning: inventing type variables
val ( ITSET ) : thm =
  |- !b f s.
         ITSET f s b =
         (@g. g {} = b /\
              (!x s.
                   FINITE s
                   ==> g (x INSERT s) = (if x IN s then g s else f x (g s))))
         s
val ( FINITE_RECURSION ) : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> ITSET f {} b = b /\
             (!x s.
                  FINITE s
                  ==> ITSET f (x INSERT s) b =
                      (if x IN s then ITSET f s b else f x (ITSET f s b)))
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val ( FINITE_RECURSION_DELETE ) : thm =
  |- !f b.
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s))
         ==> ITSET f {} b = b /\
             (!x s.
                  FINITE s
                  ==> ITSET f s b =
                      (if x IN s
                       then f x (ITSET f (s DELETE x) b)
                       else ITSET f (s DELETE x) b))
Warning: inventing type variables
0..0..2..solved at 5
0..0..3..solved at 6
0..0..3..solved at 6
val ( ITSET_EQ ) : thm =
  |- !s f g b.
         FINITE s /\
         (!x. x IN s ==> f x = g x) /\
         (!x y s. ~(x = y) ==> f x (f y s) = f y (f x s)) /\
         (!x y s. ~(x = y) ==> g x (g y s) = g y (g x s))
         ==> ITSET f s b = ITSET g s b
Warning: inventing type variables
val ( SUBSET_RESTRICT ) : thm = |- !s P. {x | x IN s /\ P x} SUBSET s
0..0..1..2..solved at 6
val ( FINITE_RESTRICT ) : thm =
  |- !s P. FINITE s ==> FINITE {x | x IN s /\ P x}
Warning: inventing type variables
val ( CARD ) : thm = |- !s. CARD s = ITSET (\x n. SUC n) s 0
val ( CARD_CLAUSES ) : thm =
  |- CARD {} = 0 /\
     (!x s.
          FINITE s
          ==> CARD (x INSERT s) = (if x IN s then CARD s else SUC (CARD s)))
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 4
0..0..0..solved at 4
0..0..0..solved at 3
val ( CARD_UNION ) : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ s INTER t = {}
         ==> CARD (s UNION t) = CARD s + CARD t
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
val ( CARD_DELETE ) : thm =
  |- !x s.
         FINITE s
         ==> CARD (s DELETE x) = (if x IN s then CARD s - 1 else CARD s)
Warning: inventing type variables
0..0..1..2..5..9..15..25..35..47..67..87..114..solved at 152
val ( CARD_UNION_EQ ) : thm =
  |- !s t u.
         FINITE u /\ s INTER t = {} /\ s UNION t = u
         ==> CARD s + CARD t = CARD u
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
val ( CARD_DIFF ) : thm =
  |- !s t. FINITE s /\ t SUBSET s ==> CARD (s DIFF t) = CARD s - CARD t
Warning: inventing type variables
val ( CARD_EQ_0 ) : thm = |- !s. FINITE s ==> (CARD s = 0 <=> s = {})
val ( FINITE_INDUCT_DELETE ) : thm =
  |- !P. P {} /\
         (!s. FINITE s /\ ~(s = {})
              ==> (?x. x IN s /\ (P (s DELETE x) ==> P s)))
         ==> (!s. FINITE s ==> P s)
Warning: inventing type variables
val ( HAS_SIZE ) : thm = |- !s n. s HAS_SIZE n <=> FINITE s /\ CARD s = n
Warning: inventing type variables
val ( HAS_SIZE_CARD ) : thm = |- !s n. s HAS_SIZE n ==> CARD s = n
Warning: inventing type variables
val ( HAS_SIZE_0 ) : thm = |- !s n. s HAS_SIZE 0 <=> s = {}
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..2..4..10..18..30..48..66..88..solved at 99
val ( HAS_SIZE_SUC ) : thm =
  |- !s n.
         s HAS_SIZE SUC n <=>
         ~(s = {}) /\ (!a. a IN s ==> s DELETE a HAS_SIZE n)
Warning: inventing type variables
val ( HAS_SIZE_UNION ) : thm =
  |- !s t m n.
         s HAS_SIZE m /\ t HAS_SIZE n /\ DISJOINT s t
         ==> s UNION t HAS_SIZE m + n
Warning: inventing type variables
val ( HAS_SIZE_DIFF ) : thm =
  |- !s t m n.
         s HAS_SIZE m /\ t HAS_SIZE n /\ t SUBSET s
         ==> s DIFF t HAS_SIZE m - n
Warning: inventing type variables
0..0..0..0..solved at 4
0..0..0..0..solved at 4
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 7
0..0..0..0..solved at 5
0..0..0..0..solved at 4
0..0..2..4..7..17..31..66..117..228..383..696..1122..1957..solved at 2075
val ( HAS_SIZE_UNIONS ) : thm =
  |- !s t m n.
         s HAS_SIZE m /\
         (!x. x IN s ==> t x HAS_SIZE n) /\
         (!x y. x IN s /\ y IN s /\ ~(x = y) ==> DISJOINT (t x) (t y))
         ==> UNIONS {t x | x IN s} HAS_SIZE m * n
Warning: inventing type variables
val ( FINITE_HAS_SIZE ) : thm = |- !s. FINITE s <=> s HAS_SIZE CARD s
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
Warning: inventing type variables
0..0..0..2..8..20..49..103..solved at 184
val ( HAS_SIZE_CLAUSES ) : thm =
  |- (s HAS_SIZE 0 <=> s = {}) /\
     (s HAS_SIZE SUC n <=>
      (?a t. t HAS_SIZE n /\ ~(a IN t) /\ s = a INSERT t))
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..0..solved at 3
0..0..1..2..solved at 6
0..0..1..2..3..solved at 8
val ( HAS_SIZE_CONV ) : term -> thm = <fun>
0..0..1..2..solved at 6
0..0..solved at 3
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..1..solved at 4
val ( CARD_SUBSET_EQ ) : thm =
  |- !a b. FINITE b /\ a SUBSET b /\ CARD a = CARD b ==> a = b
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
val ( CARD_SUBSET ) : thm =
  |- !a b. a SUBSET b /\ FINITE b ==> CARD a <= CARD b
0..0..1..2..5..12..22..37..56..solved at 74
val ( CARD_SUBSET_LE ) : thm =
  |- !a b. FINITE b /\ a SUBSET b /\ CARD b <= CARD a ==> a = b
Warning: inventing type variables
0..0..1..2..5..solved at 13
0..0..solved at 2
val ( SUBSET_CARD_EQ ) : thm =
  |- !s t. FINITE t /\ s SUBSET t ==> (CARD s = CARD t <=> s = t)
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..7..15..25..40..62..93..159..253..solved at 294
0..0..1..solved at 4
0..0..solved at 2
0..0..2..solved at 5
0..0..1..solved at 4
0..0..1..5..14..solved at 24
val ( CARD_PSUBSET ) : thm =
  |- !a b. a PSUBSET b /\ FINITE b ==> CARD a < CARD b
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
val ( CARD_UNION_LE ) : thm =
  |- !s t. FINITE s /\ FINITE t ==> CARD (s UNION t) <= CARD s + CARD t
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..solved at 3
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 7
0..0..0..0..solved at 5
0..0..0..0..solved at 4
Warning: inventing type variables
val ( CARD_UNIONS_LE ) : thm =
  |- !s t m n.
         s HAS_SIZE m /\ (!x. x IN s ==> FINITE (t x) /\ CARD (t x) <= n)
         ==> CARD (UNIONS {t x | x IN s}) <= m * n
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
Warning: inventing type variables
0..0..solved at 2
val ( CARD_UNION_GEN ) : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> CARD (s UNION t) = (CARD s + CARD t) - CARD (s INTER t)
Warning: inventing type variables
0..0..0..solved at 3
0..0..solved at 2
0..0..0..solved at 4
0..0..0..solved at 3
val ( CARD_UNION_OVERLAP_EQ ) : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> (CARD (s UNION t) = CARD s + CARD t <=> s INTER t = {})
Warning: inventing type variables
val ( CARD_UNION_OVERLAP ) : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD (s UNION t) < CARD s + CARD t
         ==> ~(s INTER t = {})
0..0..3..6..16..33..60..123..solved at 148
0..0..2..4..10..20..35..77..136..243..470..842..1459..solved at 2793
0..0..3..9..24..59..112..228..solved at 259
0..0..2..solved at 5
val ( CARD_IMAGE_INJ ) : thm =
  |- !f s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\ FINITE s
         ==> CARD (IMAGE f s) = CARD s
0..0..1..2..9..21..47..87..161..241..405..578..951..1711..2759..solved at 3322
val ( HAS_SIZE_IMAGE_INJ ) : thm =
  |- !f s n.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\ s HAS_SIZE n
         ==> IMAGE f s HAS_SIZE n
val ( CARD_IMAGE_LE ) : thm =
  |- !f s. FINITE s ==> CARD (IMAGE f s) <= CARD s
0..0..0..1..2..3..8..solved at 16
0..0..1..solved at 4
0..0..1..2..5..9..15..23..solved at 37
0..0..solved at 2
val ( CARD_IMAGE_INJ_EQ ) : thm =
  |- !f s t.
         FINITE s /\
         (!x. x IN s ==> f x IN t) /\
         (!y. y IN t ==> (?!x. x IN s /\ f x = y))
         ==> CARD t = CARD s
Warning: inventing type variables
0..0..1..2..4..6..8..18..solved at 30
val ( CARD_SUBSET_IMAGE ) : thm =
  |- !f s t. FINITE t /\ s SUBSET IMAGE f t ==> CARD s <= CARD t
0..0..solved at 2
0..0..1..5..12..solved at 22
val ( CHOOSE_SUBSET ) : thm =
  |- !s. FINITE s ==> (!n. n <= CARD s ==> (?t. t SUBSET s /\ t HAS_SIZE n))
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..1..solved at 6
0..0..0..0..solved at 4
0..0..0..0..solved at 5
0..0..1..2..3..7..14..26..47..77..solved at 94
val ( HAS_SIZE_PRODUCT_DEPENDENT ) : thm =
  |- !s m t n.
         s HAS_SIZE m /\ (!x. x IN s ==> t x HAS_SIZE n)
         ==> {x,y | x IN s /\ y IN t x} HAS_SIZE m * n
0..0..0..0..solved at 4
0..0..0..solved at 3
0..0..0..1..solved at 6
0..0..0..0..solved at 5
0..0..0..0..solved at 4
val ( FINITE_PRODUCT_DEPENDENT ) : thm =
  |- !f s t.
         FINITE s /\ (!x. x IN s ==> FINITE (t x))
         ==> FINITE {f x y | x IN s /\ y IN t x}
val ( FINITE_PRODUCT ) : thm =
  |- !s t. FINITE s /\ FINITE t ==> FINITE {x,y | x IN s /\ y IN t}
val ( CARD_PRODUCT ) : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> CARD {x,y | x IN s /\ y IN t} = CARD s * CARD t
val ( HAS_SIZE_PRODUCT ) : thm =
  |- !s m t n.
         s HAS_SIZE m /\ t HAS_SIZE n
         ==> {x,y | x IN s /\ y IN t} HAS_SIZE m * n
- : unit = ()
Warning: inventing type variables
val ( CROSS ) : thm = |- !s t. s CROSS t = {x,y | x IN s /\ y IN t}
Warning: inventing type variables
val ( IN_CROSS ) : thm = |- !x y s t. x,y IN s CROSS t <=> x IN s /\ y IN t
Warning: inventing type variables
val ( HAS_SIZE_CROSS ) : thm =
  |- !s t m n. s HAS_SIZE m /\ t HAS_SIZE n ==> s CROSS t HAS_SIZE m * n
Warning: inventing type variables
val ( FINITE_CROSS ) : thm =
  |- !s t. FINITE s /\ FINITE t ==> FINITE (s CROSS t)
Warning: inventing type variables
val ( CARD_CROSS ) : thm =
  |- !s t. FINITE s /\ FINITE t ==> CARD (s CROSS t) = CARD s * CARD t
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( CROSS_EQ_EMPTY ) : thm = |- !s t. s CROSS t = {} <=> s = {} \/ t = {}
0..0..solved at 2
0..0..solved at 2
0..0..4..8..solved at 12
0..0..2..solved at 6
0..0..2..solved at 5
0..0..solved at 2
0..0..3..solved at 6
0..0..4..solved at 7
0..0..2..6..14..46..85..182..345..630..solved at 708
val ( HAS_SIZE_FUNSPACE ) : thm =
  |- !d n t m s.
         s HAS_SIZE m /\ t HAS_SIZE n
         ==> {f | (!x. x IN s ==> f x IN t) /\ (!x. ~(x IN s) ==> f x = d)} HAS_SIZE
             n EXP m
Warning: inventing type variables
0..0..1..3..7..13..24..63..102..180..268..solved at 277
val ( CARD_FUNSPACE ) : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> CARD
             {f | (!x. x IN s ==> f x IN t) /\ (!x. ~(x IN s) ==> f x = d)} =
             CARD t EXP CARD s
Warning: inventing type variables
0..0..1..3..5..11..21..32..45..68..91..solved at 100
val ( FINITE_FUNSPACE ) : thm =
  |- !s t.
         FINITE s /\ FINITE t
         ==> FINITE
             {f | (!x. x IN s ==> f x IN t) /\ (!x. ~(x IN s) ==> f x = d)}
val ( HAS_SIZE_POWERSET ) : thm =
  |- !s n. s HAS_SIZE n ==> {t | t SUBSET s} HAS_SIZE 2 EXP n
0..0..1..3..8..14..solved at 20
val ( CARD_POWERSET ) : thm =
  |- !s. FINITE s ==> CARD {t | t SUBSET s} = 2 EXP CARD s
0..0..1..3..8..13..solved at 19
val ( FINITE_POWERSET ) : thm = |- !s. FINITE s ==> FINITE {t | t SUBSET s}
0..0..0..solved at 3
val ( FINITE_UNIONS ) : thm =
  |- !s. FINITE (UNIONS s) <=> FINITE s /\ (!t. t IN s ==> FINITE t)
val ( HAS_SIZE_NUMSEG_LT ) : thm = |- !n. {m | m < n} HAS_SIZE n
val ( CARD_NUMSEG_LT ) : thm = |- !n. CARD {m | m < n} = n
val ( FINITE_NUMSEG_LT ) : thm = |- !n. FINITE {m | m < n}
val ( HAS_SIZE_NUMSEG_LE ) : thm = |- !n. {m | m <= n} HAS_SIZE n + 1
val ( FINITE_NUMSEG_LE ) : thm = |- !n. FINITE {m | m <= n}
val ( CARD_NUMSEG_LE ) : thm = |- !n. CARD {m | m <= n} = n + 1
0..0..2..7..14..32..82..191..466..1144..2508..5758..13277..28479..solved at 31328
val num_FINITE : thm = |- !s. FINITE s <=> (?a. !x. x IN s ==> x <= a)
0..0..1..4..8..15..solved at 34
val num_FINITE_AVOID : thm = |- !s. FINITE s ==> (?a. ~(a IN s))
0..0..0..solved at 3
val num_INFINITE : thm = |- INFINITE (:num)
0..0..1..2..solved at 6
val string_INFINITE : thm = |- INFINITE (:(char)list)
0..0..1..5..solved at 10
0..0..solved at 2
0..0..1..solved at 5
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..2..6..solved at 19
0..0..3..8..solved at 22
0..0..2..6..solved at 19
0..0..solved at 2
0..0..3..8..solved at 22
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..2..6..solved at 22
0..0..solved at 3
0..0..solved at 2
0..0..2..solved at 9
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..3..7..22..54..solved at 65
val ( HAS_SIZE_INDEX ) : thm =
  |- !s n.
         s HAS_SIZE n
         ==> (?f. (!m. m < n ==> f m IN s) /\
                  (!x. x IN s ==> (?!m. m < n /\ f m = x)))
val set_of_list : thm =
  |- set_of_list [] = {} /\ set_of_list (CONS h t) = h INSERT set_of_list t
Warning: inventing type variables
val list_of_set : thm =
  |- !s. list_of_set s = (@l. set_of_list l = s /\ LENGTH l = CARD s)
val ( LIST_OF_SET_PROPERTIES ) : thm =
  |- !s. FINITE s
         ==> set_of_list (list_of_set s) = s /\
             LENGTH (list_of_set s) = CARD s
Warning: inventing type variables
0..0..1..solved at 4
val ( SET_OF_LIST_OF_SET ) : thm =
  |- !s. FINITE s ==> set_of_list (list_of_set s) = s
Warning: inventing type variables
0..0..1..solved at 4
val ( LENGTH_LIST_OF_SET ) : thm =
  |- !s. FINITE s ==> LENGTH (list_of_set s) = CARD s
val ( MEM_LIST_OF_SET ) : thm =
  |- !s. FINITE s ==> (!x. MEM x (list_of_set s) <=> x IN s)
Warning: inventing type variables
val ( FINITE_SET_OF_LIST ) : thm = |- !l. FINITE (set_of_list l)
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 5
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 5
0..0..solved at 2
0..0..solved at 2
val ( IN_SET_OF_LIST ) : thm = |- !x l. x IN set_of_list l <=> MEM x l
Warning: inventing type variables
val ( SET_OF_LIST_APPEND ) : thm =
  |- !l1 l2. set_of_list (APPEND l1 l2) = set_of_list l1 UNION set_of_list l2
Warning: inventing type variables
val ( SET_OF_LIST_MAP ) : thm =
  |- !f l. set_of_list (MAP f l) = IMAGE f (set_of_list l)
val dest_setenum : term -> term list = <fun>
val is_setenum : term -> bool = <fun>
val mk_setenum : term list * hol_type -> term = <fun>
val mk_fset : term list -> term = <fun>
Warning: inventing type variables
val pairwise : thm =
  |- !s r. pairwise r s <=> (!x y. x IN s /\ y IN s /\ ~(x = y) ==> r x y)
val ( PAIRWISE ) : thm =
  |- (PAIRWISE r [] <=> T) /\
     (PAIRWISE r (CONS h t) <=> ALL (r h) t /\ PAIRWISE r t)
Warning: inventing type variables
val ( PAIRWISE_EMPTY ) : thm = |- !r. pairwise r {} <=> T
Warning: inventing type variables
0..0..solved at 2
val ( PAIRWISE_SING ) : thm = |- !r x. pairwise r {x} <=> T
Warning: inventing type variables
0..0..2..4..8..18..31..46..solved at 60
val ( PAIRWISE_MONO ) : thm =
  |- !r s t. pairwise r s /\ t SUBSET s ==> pairwise r t
Warning: inventing type variables
val ( CARD_SET_OF_LIST_LE ) : thm = |- !l. CARD (set_of_list l) <= LENGTH l
Warning: inventing type variables
0..0..1..3..7..solved at 13
0..0..3..7..15..solved at 28
0..0..solved at 2
0..0..4..9..18..solved at 35
0..0..2..solved at 7
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( HAS_SIZE_SET_OF_LIST ) : thm =
  |- !l. set_of_list l HAS_SIZE LENGTH l <=> PAIRWISE (\x y. ~(x = y)) l
0..0..1..2..6..12..22..34..48..69..99..140..211..307..435..642..905..1303..1847..solved at 2499
0..0..1..7..23..57..137..284..501..solved at 666
0..0..0..1..2..3..12..solved at 21
0..0..1..2..5..12..22..36..52..74..106..152..212..321..452..711..1026..1572..2205..3406..5353..8956..solved at 11113
val ( SURJECTIVE_IFF_INJECTIVE_GEN ) : thm =
  |- !s t f.
         FINITE s /\ FINITE t /\ CARD s = CARD t /\ IMAGE f s SUBSET t
         ==> ((!y. y IN t ==> (?x. x IN s /\ f x = y)) <=>
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
val ( SURJECTIVE_IFF_INJECTIVE ) : thm =
  |- !s f.
         FINITE s /\ IMAGE f s SUBSET s
         ==> ((!y. y IN s ==> (?x. x IN s /\ f x = y)) <=>
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
0..0..1..2..5..solved at 13
0..0..2..9..20..43..82..solved at 135
val ( IMAGE_IMP_INJECTIVE_GEN ) : thm =
  |- !s t f.
         FINITE s /\ CARD s = CARD t /\ IMAGE f s = t
         ==> (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
Warning: inventing type variables
0..0..1..2..5..9..15..22..solved at 38
val ( IMAGE_IMP_INJECTIVE ) : thm =
  |- !s f.
         FINITE s /\ IMAGE f s = s
         ==> (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
0..0..solved at 3
0..0..solved at 3
0..0..5..10..24..51..solved at 66
0..0..solved at 2
0..0..4..8..19..41..solved at 64
0..0..4..8..19..42..solved at 65
0..0..5..10..24..solved at 32
val ( CARD_LE_INJ ) : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD s <= CARD t
         ==> (?f. IMAGE f s SUBSET t /\
                  (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
Warning: inventing type variables
0..0..1..solved at 5
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
val ( FORALL_IN_CLAUSES ) : thm =
  |- (!P. (!x. x IN {} ==> P x) <=> T) /\
     (!P a s. (!x. x IN a INSERT s ==> P x) <=> P a /\ (!x. x IN s ==> P x))
Warning: inventing type variables
0..0..solved at 2
0..0..1..solved at 5
0..0..0..solved at 4
0..0..0..solved at 3
val ( EXISTS_IN_CLAUSES ) : thm =
  |- (!P. (?x. x IN {} /\ P x) <=> F) /\
     (!P a s. (?x. x IN a INSERT s /\ P x) <=> P a \/ (?x. x IN s /\ P x))
Warning: inventing type variables
val ( SURJECTIVE_ON_RIGHT_INVERSE ) : thm =
  |- !f t.
         (!y. y IN t ==> (?x. x IN s /\ f x = y)) <=>
         (?g. !y. y IN t ==> g y IN s /\ f (g y) = y)
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..2..solved at 6
Warning: inventing type variables
0..0..1..3..8..21..46..solved at 96
0..0..1..2..5..9..15..22..29..36..solved at 45
val ( INJECTIVE_ON_LEFT_INVERSE ) : thm =
  |- !f s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) <=>
         (?g. !x. x IN s ==> g (f x) = x)
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..2..5..9..15..29..44..68..108..150..213..348..523..solved at 570
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
val ( BIJECTIVE_ON_LEFT_RIGHT_INVERSE ) : thm =
  |- !f s t.
         (!x. x IN s ==> f x IN t)
         ==> ((!x y. x IN s /\ y IN s /\ f x = f y ==> x = y) /\
              (!y. y IN t ==> (?x. x IN s /\ f x = y)) <=>
              (?g. (!y. y IN t ==> g y IN s) /\
                   (!y. y IN t ==> f (g y) = y) /\
                   (!x. x IN s ==> g (f x) = x)))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
val ( SURJECTIVE_RIGHT_INVERSE ) : thm =
  |- (!y. ?x. f x = y) <=> (?g. !y. f (g y) = y)
Warning: inventing type variables
val ( INJECTIVE_LEFT_INVERSE ) : thm =
  |- (!x y. f x = f y ==> x = y) <=> (?g. !x. g (f x) = x)
val ( BIJECTIVE_LEFT_RIGHT_INVERSE ) : thm =
  |- !f. (!x y. f x = f y ==> x = y) /\ (!y. ?x. f x = y) <=>
         (?g. (!y. f (g y) = y) /\ (!x. g (f x) = x))
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..2..solved at 6
val ( FUNCTION_FACTORS_RIGHT ) : thm =
  |- !f g. (!x. ?y. g y = f x) <=> (?h. f = g o h)
Warning: inventing type variables
0..0..1..2..solved at 6
0..0..1..2..5..solved at 11
Warning: inventing type variables
0..0..1..4..11..solved at 18
0..0..1..3..7..15..26..solved at 39
val ( FUNCTION_FACTORS_LEFT ) : thm =
  |- !f g. (!x y. g x = g y ==> f x = f y) <=> (?h. f = h o g)
0..0..1..2..5..8..11..14..17..20..36..56..78..109..148..191..248..317..solved at 371
0..0..1..2..5..8..11..14..17..20..36..56..78..109..148..191..248..317..solved at 375
0..0..1..solved at 4
val ( INJECTIVE_ON_IMAGE ) : thm =
  |- !f u.
         (!s t. s SUBSET u /\ t SUBSET u /\ IMAGE f s = IMAGE f t ==> s = t) <=>
         (!x y. x IN u /\ y IN u /\ f x = f y ==> x = y)
val ( INJECTIVE_IMAGE ) : thm =
  |- !f. (!s t. IMAGE f s = IMAGE f t ==> s = t) <=>
         (!x y. f x = f y ==> x = y)
0..0..solved at 2
0..0..0..1..2..3..5..7..9..solved at 17
0..0..solved at 2
0..0..solved at 2
0..0..0..0..1..2..3..4..5..6..9..12..15..21..27..33..solved at 55
val ( SURJECTIVE_ON_IMAGE ) : thm =
  |- !f u v.
         (!t. t SUBSET v ==> (?s. s SUBSET u /\ IMAGE f s = t)) <=>
         (!y. y IN v ==> (?x. x IN u /\ f x = y))
val ( SURJECTIVE_IMAGE ) : thm =
  |- !f. (!t. ?s. IMAGE f s = t) <=> (!y. ?x. f x = y)
0..0..1..2..5..11..solved at 18
0..0..1..2..5..solved at 13
val ( CARD_EQ_BIJECTION ) : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD s = CARD t
         ==> (?f. (!x. x IN s ==> f x IN t) /\
                  (!y. y IN t ==> (?x. x IN s /\ f x = y)) /\
                  (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
0..0..1..solved at 4
0..0..1..2..5..10..18..31..46..63..88..solved at 117
0..0..1..solved at 4
0..0..1..solved at 4
val ( CARD_EQ_BIJECTIONS ) : thm =
  |- !s t.
         FINITE s /\ FINITE t /\ CARD s = CARD t
         ==> (?f g.
                  (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
                  (!y. y IN t ==> g y IN s /\ f (g y) = y))
0..0..0..1..2..3..8..solved at 16
0..0..1..solved at 4
0..0..1..2..5..9..15..30..47..76..solved at 120
0..0..solved at 2
val ( BIJECTIONS_HAS_SIZE ) : thm =
  |- !s t f g.
         (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
         (!y. y IN t ==> g y IN s /\ f (g y) = y) /\
         s HAS_SIZE n
         ==> t HAS_SIZE n
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
0..0..1..solved at 4
val ( BIJECTIONS_HAS_SIZE_EQ ) : thm =
  |- !s t f g.
         (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
         (!y. y IN t ==> g y IN s /\ f (g y) = y)
         ==> (!n. s HAS_SIZE n <=> t HAS_SIZE n)
0..0..1..3..8..15..29..60..solved at 90
0..0..1..3..8..15..solved at 21
val ( BIJECTIONS_CARD_EQ ) : thm =
  |- !s t f g.
         (FINITE s \/ FINITE t) /\
         (!x. x IN s ==> f x IN t /\ g (f x) = x) /\
         (!y. y IN t ==> g y IN s /\ f (g y) = y)
         ==> CARD s = CARD t
0..0..2..4..solved at 8
0..0..solved at 2
0..0..2..5..13..34..70..160..300..605..1071..2263..3998..8099..solved at 12555
0..0..3..solved at 6
0..0..3..solved at 6
val ( WF_FINITE ) : thm =
  |- !(<<). (!x. ~(x << x)) /\
            (!x y z. x << y /\ y << z ==> x << z) /\
            (!x. FINITE {y | y << x})
            ==> WF (<<)
Warning: inventing type variables
val le_c : thm =
  |- !t s.
         s <=_c t <=>
         (?f. (!x. x IN s ==> f x IN t) /\
              (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y))
Warning: inventing type variables
val lt_c : thm = |- !t s. s <_c t <=> s <=_c t /\ ~(t <=_c s)
Warning: inventing type variables
val eq_c : thm =
  |- !t s.
         s =_c t <=>
         (?f. (!x. x IN s ==> f x IN t) /\
              (!y. y IN t ==> (?!x. x IN s /\ f x = y)))
Warning: inventing type variables
val ge_c : thm = |- !t s. s >=_c t <=> t <=_c s
Warning: inventing type variables
val gt_c : thm = |- !t s. s >_c t <=> t <_c s
Warning: inventing type variables
0..0..0..1..2..3..solved at 8
0..0..0..1..2..3..6..9..12..21..30..39..58..77..96..solved at 107
val ( LE_C ) : thm =
  |- !s t. s <=_c t <=> (?g. !x. x IN s ==> (?y. y IN t /\ g y = x))
Warning: inventing type variables
0..0..0..1..2..3..8..solved at 16
0..0..0..1..2..3..8..solved at 16
val ( GE_C ) : thm =
  |- !s t. s >=_c t <=> (?f. !y. y IN t ==> (?x. x IN s /\ y = f x))
Warning: inventing type variables
val ( COUNTABLE ) : thm = |- !t. COUNTABLE t <=> (:num) >=_c t
- : unit = ()
- : unit = ()
- : unit = ()
val numseg : thm = |- !m n. m..n = {x | m <= x /\ x <= n}
val ( FINITE_NUMSEG ) : thm = |- !m n. FINITE (m..n)
val ( NUMSEG_COMBINE_R ) : thm =
  |- !m p n. m <= p + 1 /\ p <= n ==> (m..p) UNION (p + 1..n) = m..n
val ( NUMSEG_COMBINE_L ) : thm =
  |- !m p n. m <= p /\ p <= n + 1 ==> (m..p - 1) UNION (p..n) = m..n
val ( NUMSEG_LREC ) : thm = |- !m n. m <= n ==> m INSERT (m + 1..n) = m..n
val ( NUMSEG_RREC ) : thm = |- !m n. m <= n ==> n INSERT (m..n - 1) = m..n
val ( NUMSEG_REC ) : thm =
  |- !m n. m <= SUC n ==> m..SUC n = SUC n INSERT (m..n)
val ( IN_NUMSEG ) : thm = |- !m n p. p IN m..n <=> m <= p /\ p <= n
val ( IN_NUMSEG_0 ) : thm = |- !m n. m IN 0..n <=> m <= n
val ( NUMSEG_SING ) : thm = |- !n. n..n = {n}
0..0..1..7..solved at 11
0..0..0..4..13..solved at 25
val ( NUMSEG_EMPTY ) : thm = |- !m n. m..n = {} <=> n < m
val ( CARD_NUMSEG_LEMMA ) : thm = |- !m d. CARD (m..m + d) = d + 1
0..0..1..2..5..9..15..24..33..44..67..90..125..solved at 185
val ( CARD_NUMSEG ) : thm = |- !m n. CARD (m..n) = (n + 1) - m
val ( HAS_SIZE_NUMSEG ) : thm = |- !m n. m..n HAS_SIZE (n + 1) - m
val ( CARD_NUMSEG_1 ) : thm = |- !n. CARD (1..n) = n
val ( HAS_SIZE_NUMSEG_1 ) : thm = |- !n. 1..n HAS_SIZE n
val ( NUMSEG_CLAUSES ) : thm =
  |- (!m. m..0 = (if m = 0 then {0} else {})) /\
     (!m n. m..SUC n = (if m <= SUC n then SUC n INSERT (m..n) else m..n))
0..0..1..2..5..8..11..solved at 19
0..0..3..6..15..54..118..265..680..1689..5287..solved at 11598
0..0..0..0..2..4..6..10..14..18..30..42..68..114..161..216..305..399..508..670..875..1105..solved at 1498
0..0..1..3..8..solved at 13
val ( FINITE_INDEX_NUMSEG ) : thm =
  |- !s. FINITE s <=>
         (?f. (!i j. i IN 1..CARD s /\ j IN 1..CARD s /\ f i = f j ==> i = j) /\
              s = IMAGE f (1..CARD s))
0..0..0..0..1..3..5..12..21..41..70..112..159..242..330..451..600..781..1008..1316..1670..solved at 2062
0..0..1..solved at 4
val ( FINITE_INDEX_NUMBERS ) : thm =
  |- !s. FINITE s <=>
         (?k f.
              (!i j. i IN k /\ j IN k /\ f i = f j ==> i = j) /\
              FINITE k /\
              s = IMAGE f k)
0..0..4..9..14..29..48..67..120..173..226..279..360..441..542..703..864..1089..1314..1539..1868..2321..2774..3227..solved at 3486
val ( DISJOINT_NUMSEG ) : thm =
  |- !m n p q. DISJOINT (m..n) (p..q) <=> n < p \/ q < m \/ n < m \/ q < p
val ( NUMSEG_ADD_SPLIT ) : thm =
  |- !m n p. m <= n + 1 ==> m..n + p = (m..n) UNION (n + 1..n + p)
val ( NUMSEG_OFFSET_IMAGE ) : thm =
  |- !m n p. m + p..n + p = IMAGE (\i. i + p) (m..n)
0..0..2..8..19..solved at 25
0..0..2..8..18..solved at 24
val ( SUBSET_NUMSEG ) : thm =
  |- !m n p q. m..n SUBSET p..q <=> n < m \/ p <= m /\ n <= q
val ( NUMSEG_LE ) : thm = |- !n. {x | x <= n} = 0..n
val ( NUMSEG_LT ) : thm =
  |- !n. {x | x < n} = (if n = 0 then {} else 0..n - 1)
0..0..1..solved at 4
0..0..solved at 2
0..0..1..2..5..9..15..27..41..66..107..solved at 125
val ( NUMSEG_CONV ) : conv = <fun>
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..3..6..19..42..78..127..186..270..412..638..solved at 776
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..4..8..23..51..93..156..solved at 192
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..1..2..solved at 9
0..0..2..4..solved at 8
0..0..1..2..solved at 9
val ( TOPOLOGICAL_SORT ) : thm =
  |- !(<<). (!x y. x << y /\ y << x ==> x = y) /\
            (!x y z. x << y /\ y << z ==> x << z)
            ==> (!n s.
                     s HAS_SIZE n
                     ==> (?f. s = IMAGE f (1..n) /\
                              (!j k.
                                   j IN 1..n /\ k IN 1..n /\ j < k
                                   ==> ~(f k << f j))))
val ( FINITE_INTSEG ) : thm =
  |- (!l r. FINITE {x | l <= x /\ x <= r}) /\
     (!l r. FINITE {x | l <= x /\ x < r}) /\
     (!l r. FINITE {x | l < x /\ x <= r}) /\
     (!l r. FINITE {x | l < x /\ x < r})
Warning: inventing type variables
val neutral : thm = |- !op. neutral op = (@x. !y. op x y = y /\ op y x = y)
val monoidal : thm =
  |- !op. monoidal op <=>
          (!x y. op x y = op y x) /\
          (!x y z. op x (op y z) = op (op x y) z) /\
          (!x. op (neutral op) x = x)
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 7
0..0..solved at 2
0..0..1..2..solved at 7
0..0..1..2..8..17..53..104..solved at 158
val ( MONOIDAL_AC ) : thm =
  |- !op. monoidal op
          ==> (!a. op (neutral op) a = a) /\
              (!a. op a (neutral op) = a) /\
              (!a b. op a b = op b a) /\
              (!a b c. op (op a b) c = op a (op b c)) /\
              (!a b c. op a (op b c) = op b (op a c))
val support : thm =
  |- !s f op. support op f s = {x | x IN s /\ ~(f x = neutral op)}
Warning: inventing type variables
val iterate : thm =
  |- !f s op.
         iterate op s f =
         (if FINITE (support op f s)
          then ITSET (\x a. op (f x) a) (support op f s) (neutral op)
          else neutral op)
Warning: inventing type variables
val ( IN_SUPPORT ) : thm =
  |- !op f x s. x IN support op f s <=> x IN s /\ ~(f x = neutral op)
Warning: inventing type variables
val ( SUPPORT_SUPPORT ) : thm =
  |- !op f s. support op f (support op f s) = support op f s
Warning: inventing type variables
0..0..1..solved at 4
0..0..1..solved at 4
val ( SUPPORT_EMPTY ) : thm =
  |- !op f s. (!x. x IN s ==> f x = neutral op) <=> support op f s = {}
Warning: inventing type variables
val ( SUPPORT_SUBSET ) : thm = |- !op f s. support op f s SUBSET s
Warning: inventing type variables
0..0..1..2..solved at 6
val ( FINITE_SUPPORT ) : thm =
  |- !op f s. FINITE s ==> FINITE (support op f s)
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..1..2..solved at 6
0..0..1..solved at 5
0..0..solved at 2
val ( SUPPORT_CLAUSES ) : thm =
  |- (!f. support op f {} = {}) /\
     (!f x s.
          support op f (x INSERT s) =
          (if f x = neutral op
           then support op f s
           else x INSERT support op f s)) /\
     (!f x s. support op f (s DELETE x) = support op f s DELETE x) /\
     (!f s t. support op f (s UNION t) = support op f s UNION support op f t) /\
     (!f s t. support op f (s INTER t) = support op f s INTER support op f t) /\
     (!f s t. support op f (s DIFF t) = support op f s DIFF support op f t) /\
     (!f g s. support op g (IMAGE f s) = IMAGE f (support op (g o f) s))
Warning: inventing type variables
val ( SUPPORT_DELTA ) : thm =
  |- !op s f a.
         support op (\x. if x = a then f x else neutral op) s =
         (if a IN s then support op f {a} else {})
Warning: inventing type variables
val ( FINITE_SUPPORT_DELTA ) : thm =
  |- !op f a. FINITE (support op (\x. if x = a then f x else neutral op) s)
Warning: inventing type variables
val ( ITERATE_SUPPORT ) : thm =
  |- !op f s. iterate op (support op f s) f = iterate op s f
Warning: inventing type variables
val ( ITERATE_EXPAND_CASES ) : thm =
  |- !op f s.
         iterate op s f =
         (if FINITE (support op f s)
          then iterate op (support op f s) f
          else neutral op)
0..0..2..4..11..20..34..72..114..190..381..solved at 438
0..0..solved at 2
0..0..2..4..10..solved at 16
val ( ITERATE_CLAUSES_GEN ) : thm =
  |- !op. monoidal op
          ==> (!f. iterate op {} f = neutral op) /\
              (!f x s.
                   monoidal op /\ FINITE (support op f s)
                   ==> iterate op (x INSERT s) f =
                       (if x IN s
                        then iterate op s f
                        else op (f x) (iterate op s f)))
Warning: inventing type variables
val ( ITERATE_CLAUSES ) : thm =
  |- !op. monoidal op
          ==> (!f. iterate op {} f = neutral op) /\
              (!f x s.
                   FINITE s
                   ==> iterate op (x INSERT s) f =
                       (if x IN s
                        then iterate op s f
                        else op (f x) (iterate op s f)))
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..solved at 3
0..0..solved at 4
0..0..solved at 2
0..0..0..solved at 5
0..0..0..solved at 3
0..0..solved at 2
0..0..1..solved at 5
Warning: inventing type variables
0..0..1..2..5..9..15..solved at 22
0..0..solved at 2
0..0..3..6..12..25..46..94..155..254..479..solved at 599
val ( ITERATE_UNION ) : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE s /\ FINITE t /\ DISJOINT s t
                   ==> iterate op (s UNION t) f =
                       op (iterate op s f) (iterate op t f))
val ( ITERATE_UNION_GEN ) : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE (support op f s) /\
                   FINITE (support op f t) /\
                   DISJOINT (support op f s) (support op f t)
                   ==> iterate op (s UNION t) f =
                       op (iterate op s f) (iterate op t f))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..1..solved at 4
0..0..solved at 2
Warning: inventing type variables
0..0..1..2..5..9..15..22..29..36..53..70..97..132..167..210..282..354..455..576..697..838..1034..1230..1481..solved at 1835
val ( ITERATE_DIFF ) : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE s /\ t SUBSET s
                   ==> op (iterate op (s DIFF t) f) (iterate op t f) =
                       iterate op s f)
val ( ITERATE_DIFF_GEN ) : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE (support op f s) /\
                   support op f t SUBSET support op f s
                   ==> op (iterate op (s DIFF t) f) (iterate op t f) =
                       iterate op s f)
Warning: inventing type variables
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
Warning: inventing type variables
val ( ITERATE_INCL_EXCL ) : thm =
  |- !op. monoidal op
          ==> (!s t f.
                   FINITE s /\ FINITE t
                   ==> op (iterate op s f) (iterate op t f) =
                       op (iterate op (s UNION t) f)
                       (iterate op (s INTER t) f))
val ( ITERATE_CLOSED ) : thm =
  |- !op. monoidal op
          ==> (!P. P (neutral op) /\ (!x y. P x /\ P y ==> P (op x y))
                   ==> (!f s.
                            (!x. x IN s /\ ~(f x = neutral op) ==> P (f x))
                            ==> P (iterate op s f)))
val ( ITERATE_RELATED ) : thm =
  |- !op. monoidal op
          ==> (!R. R (neutral op) (neutral op) /\
                   (!x1 y1 x2 y2.
                        R x1 x2 /\ R y1 y2 ==> R (op x1 y1) (op x2 y2))
                   ==> (!f g s.
                            FINITE s /\ (!x. x IN s ==> R (f x) (g x))
                            ==> R (iterate op s f) (iterate op s g)))
0..0..2..10..33..89..264..814..2481..solved at 6396
0..0..1..2..6..solved at 11
val ( ITERATE_EQ_NEUTRAL ) : thm =
  |- !op. monoidal op
          ==> (!f s.
                   (!x. x IN s ==> f x = neutral op)
                   ==> iterate op s f = neutral op)
0..0..1..2..5..9..15..solved at 26
val ( ITERATE_SING ) : thm =
  |- !op. monoidal op ==> (!f x. iterate op {x} f = f x)
0..0..1..6..22..48..121..253..441..992..1771..3020..5157..8831..solved at 12430
val ( ITERATE_DELETE ) : thm =
  |- !op. monoidal op
          ==> (!f s a.
                   FINITE s /\ a IN s
                   ==> op (f a) (iterate op (s DELETE a) f) = iterate op s f)
Warning: inventing type variables
val ( ITERATE_DELTA ) : thm =
  |- !op. monoidal op
          ==> (!f a s.
                   iterate op s (\x. if x = a then f x else neutral op) =
                   (if a IN s then f a else neutral op))
Warning: inventing type variables
0..0..3..6..13..solved at 24
0..0..2..4..8..16..28..43..67..95..155..236..348..490..727..solved at 823
0..0..4..8..19..solved at 30
0..0..3..6..solved at 13
0..0..1..9..19..37..76..127..solved at 141
0..0..solved at 2
0..0..1..8..17..34..67..112..solved at 126
val ( ITERATE_IMAGE ) : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
                   ==> iterate op (IMAGE f s) g = iterate op s (g o f))
0..0..0..1..3..7..20..solved at 34
0..0..1..solved at 4
0..0..1..2..5..9..15..35..solved at 65
val ( ITERATE_BIJECTION ) : thm =
  |- !op. monoidal op
          ==> (!f p s.
                   (!x. x IN s ==> p x IN s) /\
                   (!y. y IN s ==> (?!x. x IN s /\ p x = y))
                   ==> iterate op s f = iterate op s (f o p))
Warning: inventing type variables
0..0..0..solved at 3
0..0..0..1..solved at 6
0..0..0..0..solved at 5
0..0..0..0..solved at 4
Warning: inventing type variables
0..0..solved at 2
val ( ITERATE_ITERATE_PRODUCT ) : thm =
  |- !op. monoidal op
          ==> (!s t x.
                   FINITE s /\ (!i. i IN s ==> FINITE (t i))
                   ==> iterate op s (\i. iterate op (t i) (x i)) =
                       iterate op {i,j | i IN s /\ j IN t i} (\(i,j). x i j))
0..0..solved at 2
0..0..1..2..5..solved at 11
0..0..solved at 2
0..0..1..2..5..10..20..solved at 31
0..0..solved at 2
0..0..1..7..solved at 11
0..0..3..7..solved at 11
0..0..2..4..12..24..44..84..solved at 142
val ( ITERATE_EQ ) : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   (!x. x IN s ==> f x = g x)
                   ==> iterate op s f = iterate op s g)
0..0..0..1..2..3..8..solved at 16
0..0..1..solved at 4
0..0..1..2..10..22..49..93..171..282..522..811..solved at 842
0..0..1..2..5..9..15..23..solved at 37
val ( ITERATE_EQ_GENERAL ) : thm =
  |- !op. monoidal op
          ==> (!s t f g h.
                   (!y. y IN t ==> (?!x. x IN s /\ h x = y)) /\
                   (!x. x IN s ==> h x IN t /\ g (h x) = f x)
                   ==> iterate op s f = iterate op t g)
0..0..0..1..2..3..solved at 8
0..0..1..2..5..9..15..30..47..76..solved at 121
0..0..1..solved at 4
0..0..1..solved at 4
val ( ITERATE_EQ_GENERAL_INVERSES ) : thm =
  |- !op. monoidal op
          ==> (!s t f g h k.
                   (!y. y IN t ==> k y IN s /\ h (k y) = y) /\
                   (!x. x IN s ==> h x IN t /\ k (h x) = x /\ g (h x) = f x)
                   ==> iterate op s f = iterate op t g)
0..0..1..solved at 4
0..0..2..solved at 6
0..0..0..2..4..8..solved at 18
0..0..1..2..5..solved at 13
val ( ITERATE_INJECTION ) : thm =
  |- !op. monoidal op
          ==> (!f p s.
                   FINITE s /\
                   (!x. x IN s ==> p x IN s) /\
                   (!x y. x IN s /\ y IN s /\ p x = p y ==> x = y)
                   ==> iterate op s (f o p) = iterate op s f)
0..0..3..11..31..solved at 42
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
val ( ITERATE_UNION_NONZERO ) : thm =
  |- !op. monoidal op
          ==> (!f s t.
                   FINITE s /\
                   FINITE t /\
                   (!x. x IN s INTER t ==> f x = neutral op)
                   ==> iterate op (s UNION t) f =
                       op (iterate op s f) (iterate op t f))
Warning: inventing type variables
val ( ITERATE_OP ) : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   FINITE s
                   ==> iterate op s (\x. op (f x) (g x)) =
                       op (iterate op s f) (iterate op s g))
0..0..2..4..solved at 9
0..0..solved at 2
0..0..2..4..solved at 8
0..0..solved at 2
val ( ITERATE_SUPERSET ) : thm =
  |- !op. monoidal op
          ==> (!f u v.
                   u SUBSET v /\
                   (!x. x IN v /\ ~(x IN u) ==> f x = neutral op)
                   ==> iterate op v f = iterate op u f)
0..0..4..8..18..34..solved at 48
0..0..2..4..solved at 8
0..0..4..8..18..34..solved at 48
0..0..2..4..8..16..39..83..147..248..472..749..1436..solved at 2196
0..0..4..8..18..solved at 32
0..0..2..4..8..solved at 14
val ( ITERATE_IMAGE_NONZERO ) : thm =
  |- !op. monoidal op
          ==> (!g f s.
                   FINITE s /\
                   (!x y.
                        x IN s /\ y IN s /\ ~(x = y) /\ f x = f y
                        ==> g (f x) = neutral op)
                   ==> iterate op (IMAGE f s) g = iterate op s (g o f))
Warning: inventing type variables
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val ( ITERATE_CASES ) : thm =
  |- !op. monoidal op
          ==> (!s P f g.
                   FINITE s
                   ==> iterate op s (\x. if P x then f x else g x) =
                       op (iterate op {x | x IN s /\ P x} f)
                       (iterate op {x | x IN s /\ ~P x} g))
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..1..2..5..11..25..55..100..209..399..solved at 697
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
val ( ITERATE_OP_GEN ) : thm =
  |- !op. monoidal op
          ==> (!f g s.
                   FINITE (support op f s) /\ FINITE (support op g s)
                   ==> iterate op s (\x. op (f x) (g x)) =
                       op (iterate op s f) (iterate op s g))
Warning: inventing type variables
0..0..1..2..5..9..15..solved at 26
0..0..1..solved at 4
val ( ITERATE_CLAUSES_NUMSEG ) : thm =
  |- !op. monoidal op
          ==> (!m. iterate op (m..0) f = (if m = 0 then f 0 else neutral op)) /\
              (!m n.
                   iterate op (m..SUC n) f =
                   (if m <= SUC n
                    then op (iterate op (m..n) f) (f (SUC n))
                    else iterate op (m..n) f))
Warning: inventing type variables
0..0..1..2..6..solved at 12
val ( ITERATE_PAIR ) : thm =
  |- !op. monoidal op
          ==> (!f m n.
                   iterate op (2 * m..2 * n + 1) f =
                   iterate op (m..n) (\i. op (f (2 * i)) (f (2 * i + 1))))
- : unit = ()
Warning: inventing type variables
val nsum : thm = |- nsum = iterate (+)
0..0..1..2..solved at 8
0..0..solved at 2
0..0..solved at 2
val ( NEUTRAL_ADD ) : thm = |- neutral (+) = 0
0..0..1..solved at 4
0..0..solved at 2
0..0..solved at 2
val ( NEUTRAL_MUL ) : thm = |- neutral (*) = 1
val ( MONOIDAL_ADD ) : thm = |- monoidal (+)
val ( MONOIDAL_MUL ) : thm = |- monoidal (*)
Warning: inventing type variables
val ( NSUM_CLAUSES ) : thm =
  |- (!f. nsum {} f = 0) /\
     (!x f s.
          FINITE s
          ==> nsum (x INSERT s) f =
              (if x IN s then nsum s f else f x + nsum s f))
Warning: inventing type variables
val ( NSUM_UNION ) : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ DISJOINT s t
         ==> nsum (s UNION t) f = nsum s f + nsum t f
Warning: inventing type variables
val ( NSUM_DIFF ) : thm =
  |- !f s t.
         FINITE s /\ t SUBSET s ==> nsum (s DIFF t) f = nsum s f - nsum t f
val ( NSUM_INCL_EXCL ) : thm =
  |- !s t f.
         FINITE s /\ FINITE t
         ==> nsum s f + nsum t f = nsum (s UNION t) f + nsum (s INTER t) f
Warning: inventing type variables
val ( NSUM_SUPPORT ) : thm = |- !f s. nsum (support (+) f s) f = nsum s f
Warning: inventing type variables
val ( NSUM_ADD ) : thm =
  |- !f g s. FINITE s ==> nsum s (\x. f x + g x) = nsum s f + nsum s g
Warning: inventing type variables
val ( NSUM_ADD_GEN ) : thm =
  |- !f g s.
         FINITE {x | x IN s /\ ~(f x = 0)} /\
         FINITE {x | x IN s /\ ~(g x = 0)}
         ==> nsum s (\x. f x + g x) = nsum s f + nsum s g
val ( NSUM_EQ_0 ) : thm = |- !f s. (!x. x IN s ==> f x = 0) ==> nsum s f = 0
val ( NSUM_0 ) : thm = |- !s. nsum s (\n. 0) = 0
val ( NSUM_LMUL ) : thm = |- !f c s. nsum s (\x. c * f x) = c * nsum s f
val ( NSUM_RMUL ) : thm = |- !f c s. nsum s (\x. f x * c) = nsum s f * c
Warning: inventing type variables
val ( NSUM_LE ) : thm =
  |- !f g s. FINITE s /\ (!x. x IN s ==> f x <= g x) ==> nsum s f <= nsum s g
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val ( NSUM_LT ) : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> f x <= g x) /\ (?x. x IN s /\ f x < g x)
         ==> nsum s f < nsum s g
Warning: inventing type variables
0..0..2..6..15..30..73..134..229..368..553..800..1208..1747..2508..3645..5152..7046..solved at 7159
val ( NSUM_LT_ALL ) : thm =
  |- !f g s.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < g x)
         ==> nsum s f < nsum s g
Warning: inventing type variables
val ( NSUM_EQ ) : thm =
  |- !f g s. (!x. x IN s ==> f x = g x) ==> nsum s f = nsum s g
Warning: inventing type variables
val ( NSUM_CONST ) : thm = |- !c s. FINITE s ==> nsum s (\n. c) = CARD s * c
0..0..3..6..9..solved at 14
0..0..3..6..9..solved at 14
0..0..2..5..8..solved at 18
0..0..2..solved at 6
val ( NSUM_POS_BOUND ) : thm =
  |- !f b s. FINITE s /\ nsum s f <= b ==> (!x. x IN s ==> f x <= b)
Warning: inventing type variables
0..0..1..3..7..13..30..solved at 37
val ( NSUM_EQ_0_IFF ) : thm =
  |- !s. FINITE s ==> (nsum s f = 0 <=> (!x. x IN s ==> f x = 0))
Warning: inventing type variables
val ( NSUM_DELETE ) : thm =
  |- !f s a. FINITE s /\ a IN s ==> f a + nsum (s DELETE a) f = nsum s f
Warning: inventing type variables
val ( NSUM_SING ) : thm = |- !f x. nsum {x} f = f x
val ( NSUM_DELTA ) : thm =
  |- !s a. nsum s (\x. if x = a then b else 0) = (if a IN s then b else 0)
val ( NSUM_SWAP ) : thm =
  |- !f s t.
         FINITE s /\ FINITE t
         ==> nsum s (\i. nsum t (f i)) = nsum t (\j. nsum s (\i. f i j))
Warning: inventing type variables
val ( NSUM_IMAGE ) : thm =
  |- !f g s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> nsum (IMAGE f s) g = nsum s (g o f)
val ( NSUM_SUPERSET ) : thm =
  |- !f u v.
         u SUBSET v /\ (!x. x IN v /\ ~(x IN u) ==> f x = 0)
         ==> nsum v f = nsum u f
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..1..5..15..solved at 22
0..0..2..6..22..76..261..solved at 597
val ( NSUM_UNION_RZERO ) : thm =
  |- !f u v.
         FINITE u /\ (!x. x IN v /\ ~(x IN u) ==> f x = 0)
         ==> nsum (u UNION v) f = nsum u f
0..0..1..2..7..13..26..42..67..97..161..234..375..537..790..1087..1727..2450..solved at 2485
val ( NSUM_UNION_LZERO ) : thm =
  |- !f u v.
         FINITE v /\ (!x. x IN u /\ ~(x IN v) ==> f x = 0)
         ==> nsum (u UNION v) f = nsum v f
Warning: inventing type variables
val ( NSUM_RESTRICT ) : thm =
  |- !f s. FINITE s ==> nsum s (\x. if x IN s then f x else 0) = nsum s f
val ( NSUM_BOUND ) : thm =
  |- !s f b. FINITE s /\ (!x. x IN s ==> f x <= b) ==> nsum s f <= CARD s * b
Warning: inventing type variables
val ( NSUM_BOUND_GEN ) : thm =
  |- !s t b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x <= b DIV CARD s)
         ==> nsum s f <= b
0..0..0..solved at 3
val ( NSUM_BOUND_LT ) : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> f x <= b) /\ (?x. x IN s /\ f x < b)
         ==> nsum s f < CARD s * b
Warning: inventing type variables
0..0..2..6..15..30..77..142..261..426..699..1038..1725..2554..4260..6426..11402..17097..solved at 17200
val ( NSUM_BOUND_LT_ALL ) : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b)
         ==> nsum s f < CARD s * b
Warning: inventing type variables
val ( NSUM_BOUND_LT_GEN ) : thm =
  |- !s t b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b DIV CARD s)
         ==> nsum s f < b
Warning: inventing type variables
0..0..1..2..5..9..15..23..31..39..57..75..103..solved at 139
val ( NSUM_UNION_EQ ) : thm =
  |- !s t u.
         FINITE u /\ s INTER t = {} /\ s UNION t = u
         ==> nsum s f + nsum t f = nsum u f
0..0..1..2..6..11..19..34..49..70..117..164..237..386..553..836..1215..1685..2287..solved at 2748
val ( NSUM_EQ_SUPERSET ) : thm =
  |- !f s t.
         FINITE t /\
         t SUBSET s /\
         (!x. x IN t ==> f x = g x) /\
         (!x. x IN s /\ ~(x IN t) ==> f x = 0)
         ==> nsum s f = nsum t g
Warning: inventing type variables
val ( NSUM_RESTRICT_SET ) : thm =
  |- !P s f. nsum {x | x IN s /\ P x} f = nsum s (\x. if P x then f x else 0)
Warning: inventing type variables
val ( NSUM_NSUM_RESTRICT ) : thm =
  |- !R f s t.
         FINITE s /\ FINITE t
         ==> nsum s (\x. nsum {y | y IN t /\ R x y} (\y. f x y)) =
             nsum t (\y. nsum {x | x IN s /\ R x y} (\x. f x y))
Warning: inventing type variables
val ( CARD_EQ_NSUM ) : thm = |- !s. FINITE s ==> CARD s = nsum s (\x. 1)
val ( NSUM_MULTICOUNT_GEN ) : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k j)
         ==> nsum s (\i. CARD {j | j IN t /\ R i j}) = nsum t (\i. k i)
val ( NSUM_MULTICOUNT ) : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k)
         ==> nsum s (\i. CARD {j | j IN t /\ R i j}) = k * CARD t
0..0..1..3..solved at 8
0..0..0..solved at 3
0..0..solved at 2
val ( NSUM_IMAGE_GEN ) : thm =
  |- !f g s.
         FINITE s
         ==> nsum s g = nsum (IMAGE f s) (\y. nsum {x | x IN s /\ f x = y} g)
0..0..1..solved at 5
val ( NSUM_GROUP ) : thm =
  |- !f g s t.
         FINITE s /\ IMAGE f s SUBSET t
         ==> nsum t (\y. nsum {x | x IN s /\ f x = y} g) = nsum s g
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( NSUM_SUBSET ) : thm =
  |- !u v f.
         FINITE u /\ FINITE v /\ (!x. x IN u DIFF v ==> f x = 0)
         ==> nsum u f <= nsum v f
Warning: inventing type variables
0..0..1..3..solved at 7
0..0..solved at 2
0..0..1..4..12..30..solved at 51
val ( NSUM_SUBSET_SIMPLE ) : thm =
  |- !u v f. FINITE v /\ u SUBSET v ==> nsum u f <= nsum v f
val ( NSUM_IMAGE_NONZERO ) : thm =
  |- !d i s.
         FINITE s /\
         (!x y. x IN s /\ y IN s /\ ~(x = y) /\ i x = i y ==> d (i x) = 0)
         ==> nsum (IMAGE i s) d = nsum s (d o i)
val ( NSUM_BIJECTION ) : thm =
  |- !f p s.
         (!x. x IN s ==> p x IN s) /\
         (!y. y IN s ==> (?!x. x IN s /\ p x = y))
         ==> nsum s f = nsum s (f o p)
val ( NSUM_NSUM_PRODUCT ) : thm =
  |- !s t x.
         FINITE s /\ (!i. i IN s ==> FINITE (t i))
         ==> nsum s (\i. nsum (t i) (x i)) =
             nsum {i,j | i IN s /\ j IN t i} (\(i,j). x i j)
val ( NSUM_EQ_GENERAL ) : thm =
  |- !s t f g h.
         (!y. y IN t ==> (?!x. x IN s /\ h x = y)) /\
         (!x. x IN s ==> h x IN t /\ g (h x) = f x)
         ==> nsum s f = nsum t g
val ( NSUM_EQ_GENERAL_INVERSES ) : thm =
  |- !s t f g h k.
         (!y. y IN t ==> k y IN s /\ h (k y) = y) /\
         (!x. x IN s ==> h x IN t /\ k (h x) = x /\ g (h x) = f x)
         ==> nsum s f = nsum t g
Warning: inventing type variables
val ( NSUM_INJECTION ) : thm =
  |- !f p s.
         FINITE s /\
         (!x. x IN s ==> p x IN s) /\
         (!x y. x IN s /\ y IN s /\ p x = p y ==> x = y)
         ==> nsum s (f o p) = nsum s f
Warning: inventing type variables
val ( NSUM_UNION_NONZERO ) : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ (!x. x IN s INTER t ==> f x = 0)
         ==> nsum (s UNION t) f = nsum s f + nsum t f
0..0..2..4..10..18..30..solved at 46
0..0..2..4..8..16..28..59..103..173..solved at 212
val ( NSUM_UNIONS_NONZERO ) : thm =
  |- !f s.
         FINITE s /\
         (!t. t IN s ==> FINITE t) /\
         (!t1 t2 x.
              t1 IN s /\ t2 IN s /\ ~(t1 = t2) /\ x IN t1 /\ x IN t2
              ==> f x = 0)
         ==> nsum (UNIONS s) f = nsum s (\t. nsum t f)
val ( NSUM_CASES ) : thm =
  |- !s P f g.
         FINITE s
         ==> nsum s (\x. if P x then f x else g x) =
             nsum {x | x IN s /\ P x} f + nsum {x | x IN s /\ ~P x} g
val ( NSUM_CLOSED ) : thm =
  |- !P f s.
         P 0 /\ (!x y. P x /\ P y ==> P (x + y)) /\ (!a. a IN s ==> P (f a))
         ==> P (nsum s f)
val ( NSUM_ADD_NUMSEG ) : thm =
  |- !f g m n. nsum (m..n) (\i. f i + g i) = nsum (m..n) f + nsum (m..n) g
val ( NSUM_LE_NUMSEG ) : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i <= g i)
         ==> nsum (m..n) f <= nsum (m..n) g
0..0..1..4..13..29..64..122..204..solved at 247
val ( NSUM_EQ_NUMSEG ) : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i = g i)
         ==> nsum (m..n) f = nsum (m..n) g
val ( NSUM_CONST_NUMSEG ) : thm =
  |- !c m n. nsum (m..n) (\n. c) = ((n + 1) - m) * c
Warning: inventing type variables
val ( NSUM_EQ_0_NUMSEG ) : thm =
  |- !f s. (!i. m <= i /\ i <= n ==> f i = 0) ==> nsum (m..n) f = 0
val ( NSUM_EQ_0_IFF_NUMSEG ) : thm =
  |- !f m n. nsum (m..n) f = 0 <=> (!i. m <= i /\ i <= n ==> f i = 0)
0..0..1..7..18..38..78..147..solved at 161
val ( NSUM_TRIV_NUMSEG ) : thm = |- !f m n. n < m ==> nsum (m..n) f = 0
val ( NSUM_SING_NUMSEG ) : thm = |- !f n. nsum (n..n) f = f n
val ( NSUM_CLAUSES_NUMSEG ) : thm =
  |- (!m. nsum (m..0) f = (if m = 0 then f 0 else 0)) /\
     (!m n.
          nsum (m..SUC n) f =
          (if m <= SUC n then nsum (m..n) f + f (SUC n) else nsum (m..n) f))
val ( NSUM_SWAP_NUMSEG ) : thm =
  |- !a b c d f.
         nsum (a..b) (\i. nsum (c..d) (f i)) =
         nsum (c..d) (\j. nsum (a..b) (\i. f i j))
val ( NSUM_ADD_SPLIT ) : thm =
  |- !f m n p.
         m <= n + 1
         ==> nsum (m..n + p) f = nsum (m..n) f + nsum (n + 1..n + p) f
val ( NSUM_OFFSET ) : thm =
  |- !p f m n. nsum (m + p..n + p) f = nsum (m..n) (\i. f (i + p))
val ( NSUM_OFFSET_0 ) : thm =
  |- !f m n. m <= n ==> nsum (m..n) f = nsum (0..n - m) (\i. f (i + m))
val ( NSUM_CLAUSES_LEFT ) : thm =
  |- !f m n. m <= n ==> nsum (m..n) f = f m + nsum (m + 1..n) f
val ( NSUM_CLAUSES_RIGHT ) : thm =
  |- !f m n. 0 < n /\ m <= n ==> nsum (m..n) f = nsum (m..n - 1) f + f n
val ( NSUM_PAIR ) : thm =
  |- !f m n.
         nsum (2 * m..2 * n + 1) f =
         nsum (m..n) (\i. f (2 * i) + f (2 * i + 1))
Warning: inventing type variables
- : unit = ()
0..0..2..4..8..27..52..93..143..223..solved at 280
val ( CARD_UNIONS ) : thm =
  |- !s. FINITE s /\
         (!t. t IN s ==> FINITE t) /\
         (!t u. t IN s /\ u IN s /\ ~(t = u) ==> t INTER u = {})
         ==> CARD (UNIONS s) = nsum s CARD
- : unit = ()
Warning: inventing type variables
val sum : thm = |- sum = iterate (+)
0..0..1..2..solved at 8
0..0..solved at 2
0..0..solved at 2
val ( NEUTRAL_REAL_ADD ) : thm = |- neutral (+) = &0
0..0..1..2..solved at 8
0..0..solved at 2
0..0..solved at 2
val ( NEUTRAL_REAL_MUL ) : thm = |- neutral (*) = &1
val ( MONOIDAL_REAL_ADD ) : thm = |- monoidal (+)
val ( MONOIDAL_REAL_MUL ) : thm = |- monoidal (*)
Warning: inventing type variables
val ( SUM_CLAUSES ) : thm =
  |- (!f. sum {} f = &0) /\
     (!x f s.
          FINITE s
          ==> sum (x INSERT s) f =
              (if x IN s then sum s f else f x + sum s f))
Warning: inventing type variables
val ( SUM_UNION ) : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ DISJOINT s t
         ==> sum (s UNION t) f = sum s f + sum t f
Warning: inventing type variables
val ( SUM_DIFF ) : thm =
  |- !f s t. FINITE s /\ t SUBSET s ==> sum (s DIFF t) f = sum s f - sum t f
val ( SUM_INCL_EXCL ) : thm =
  |- !s t f.
         FINITE s /\ FINITE t
         ==> sum s f + sum t f = sum (s UNION t) f + sum (s INTER t) f
Warning: inventing type variables
val ( SUM_SUPPORT ) : thm = |- !f s. sum (support (+) f s) f = sum s f
Warning: inventing type variables
val ( SUM_ADD ) : thm =
  |- !f g s. FINITE s ==> sum s (\x. f x + g x) = sum s f + sum s g
Warning: inventing type variables
val ( SUM_ADD_GEN ) : thm =
  |- !f g s.
         FINITE {x | x IN s /\ ~(f x = &0)} /\
         FINITE {x | x IN s /\ ~(g x = &0)}
         ==> sum s (\x. f x + g x) = sum s f + sum s g
val ( SUM_EQ_0 ) : thm = |- !f s. (!x. x IN s ==> f x = &0) ==> sum s f = &0
val ( SUM_0 ) : thm = |- !s. sum s (\n. &0) = &0
val ( SUM_LMUL ) : thm = |- !f c s. sum s (\x. c * f x) = c * sum s f
val ( SUM_RMUL ) : thm = |- !f c s. sum s (\x. f x * c) = sum s f * c
Warning: inventing type variables
val ( SUM_NEG ) : thm = |- !f s. sum s (\x. --f x) = --sum s f
Warning: inventing type variables
val ( SUM_SUB ) : thm =
  |- !f g s. FINITE s ==> sum s (\x. f x - g x) = sum s f - sum s g
Warning: inventing type variables
val ( SUM_LE ) : thm =
  |- !f g s. FINITE s /\ (!x. x IN s ==> f x <= g x) ==> sum s f <= sum s g
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
val ( SUM_LT ) : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> f x <= g x) /\ (?x. x IN s /\ f x < g x)
         ==> sum s f < sum s g
Warning: inventing type variables
0..0..2..6..15..30..73..134..229..368..553..800..1208..1747..2508..3645..5152..7046..solved at 7159
val ( SUM_LT_ALL ) : thm =
  |- !f g s.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < g x)
         ==> sum s f < sum s g
Warning: inventing type variables
val ( SUM_EQ ) : thm =
  |- !f g s. (!x. x IN s ==> f x = g x) ==> sum s f = sum s g
Warning: inventing type variables
val ( SUM_ABS ) : thm =
  |- !f s. FINITE s ==> abs (sum s f) <= sum s (\x. abs (f x))
val ( SUM_ABS_LE ) : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> abs (f x) <= g x)
         ==> abs (sum s f) <= sum s g
Warning: inventing type variables
val ( SUM_CONST ) : thm = |- !c s. FINITE s ==> sum s (\n. c) = &(CARD s) * c
Warning: inventing type variables
Warning: inventing type variables
val ( SUM_POS_LE ) : thm =
  |- !f s. FINITE s /\ (!x. x IN s ==> &0 <= f x) ==> &0 <= sum s f
0..0..3..solved at 6
0..0..3..solved at 6
0..0..3..6..9..25..47..79..140..237..351..solved at 363
0..0..3..6..9..25..48..84..148..249..379..solved at 392
0..0..2..5..8..19..37..63..110..182..270..solved at 349
0..0..2..solved at 6
val ( SUM_POS_BOUND ) : thm =
  |- !f b s.
         FINITE s /\ (!x. x IN s ==> &0 <= f x) /\ sum s f <= b
         ==> (!x. x IN s ==> f x <= b)
Warning: inventing type variables
0..0..1..2..3..4..9..22..35..56..81..solved at 94
0..0..1..solved at 4
val ( SUM_POS_EQ_0 ) : thm =
  |- !f s.
         FINITE s /\ (!x. x IN s ==> &0 <= f x) /\ sum s f = &0
         ==> (!x. x IN s ==> f x = &0)
0..0..2..9..16..26..59..solved at 68
val ( SUM_ZERO_EXISTS ) : thm =
  |- !u s.
         FINITE s /\ sum s u = &0
         ==> (!i. i IN s ==> u i = &0) \/
             (?j k. j IN s /\ u j < &0 /\ k IN s /\ u k > &0)
Warning: inventing type variables
val ( SUM_DELETE ) : thm =
  |- !f s a. FINITE s /\ a IN s ==> sum (s DELETE a) f = sum s f - f a
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
val ( SUM_DELETE_CASES ) : thm =
  |- !f s a.
         FINITE s
         ==> sum (s DELETE a) f = (if a IN s then sum s f - f a else sum s f)
Warning: inventing type variables
val ( SUM_SING ) : thm = |- !f x. sum {x} f = f x
val ( SUM_DELTA ) : thm =
  |- !s a. sum s (\x. if x = a then b else &0) = (if a IN s then b else &0)
val ( SUM_SWAP ) : thm =
  |- !f s t.
         FINITE s /\ FINITE t
         ==> sum s (\i. sum t (f i)) = sum t (\j. sum s (\i. f i j))
Warning: inventing type variables
val ( SUM_IMAGE ) : thm =
  |- !f g s.
         (!x y. x IN s /\ y IN s /\ f x = f y ==> x = y)
         ==> sum (IMAGE f s) g = sum s (g o f)
val ( SUM_SUPERSET ) : thm =
  |- !f u v.
         u SUBSET v /\ (!x. x IN v /\ ~(x IN u) ==> f x = &0)
         ==> sum v f = sum u f
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..1..5..15..solved at 22
0..0..2..6..22..76..261..solved at 597
val ( SUM_UNION_RZERO ) : thm =
  |- !f u v.
         FINITE u /\ (!x. x IN v /\ ~(x IN u) ==> f x = &0)
         ==> sum (u UNION v) f = sum u f
0..0..1..2..7..13..26..42..67..97..161..234..375..537..790..1087..1727..2450..solved at 2485
val ( SUM_UNION_LZERO ) : thm =
  |- !f u v.
         FINITE v /\ (!x. x IN u /\ ~(x IN v) ==> f x = &0)
         ==> sum (u UNION v) f = sum v f
Warning: inventing type variables
val ( SUM_RESTRICT ) : thm =
  |- !f s. FINITE s ==> sum s (\x. if x IN s then f x else &0) = sum s f
val ( SUM_BOUND ) : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> f x <= b) ==> sum s f <= &(CARD s) * b
Warning: inventing type variables
0..0..2..5..10..21..39..63..93..149..232..400..714..1313..2437..solved at 3778
val ( SUM_BOUND_GEN ) : thm =
  |- !s t b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x <= b / &(CARD s))
         ==> sum s f <= b
val ( SUM_ABS_BOUND ) : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> abs (f x) <= b)
         ==> abs (sum s f) <= &(CARD s) * b
0..0..0..solved at 3
val ( SUM_BOUND_LT ) : thm =
  |- !s f b.
         FINITE s /\ (!x. x IN s ==> f x <= b) /\ (?x. x IN s /\ f x < b)
         ==> sum s f < &(CARD s) * b
Warning: inventing type variables
0..0..2..6..15..30..77..142..253..408..645..946..1535..2256..3565..5301..8800..12859..solved at 12962
val ( SUM_BOUND_LT_ALL ) : thm =
  |- !s f b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b)
         ==> sum s f < &(CARD s) * b
Warning: inventing type variables
0..0..2..5..10..25..47..75..111..180..279..473..834..1570..2960..5933..11269..solved at 19226
val ( SUM_BOUND_LT_GEN ) : thm =
  |- !s t b.
         FINITE s /\ ~(s = {}) /\ (!x. x IN s ==> f x < b / &(CARD s))
         ==> sum s f < b
Warning: inventing type variables
0..0..1..2..5..9..15..23..31..39..57..75..103..solved at 139
val ( SUM_UNION_EQ ) : thm =
  |- !s t u.
         FINITE u /\ s INTER t = {} /\ s UNION t = u
         ==> sum s f + sum t f = sum u f
0..0..1..2..6..11..19..34..49..70..117..164..237..386..553..836..1213..1681..2277..solved at 2734
val ( SUM_EQ_SUPERSET ) : thm =
  |- !f s t.
         FINITE t /\
         t SUBSET s /\
         (!x. x IN t ==> f x = g x) /\
         (!x. x IN s /\ ~(x IN t) ==> f x = &0)
         ==> sum s f = sum t g
Warning: inventing type variables
Warning: inventing type variables
val ( SUM_RESTRICT_SET ) : thm =
  |- !P s f. sum {x | x IN s /\ P x} f = sum s (\x. if P x then f x else &0)
Warning: inventing type variables
val ( SUM_SUM_RESTRICT ) : thm =
  |- !R f s t.
         FINITE s /\ FINITE t
         ==> sum s (\x. sum {y | y IN t /\ R x y} (\y. f x y)) =
             sum t (\y. sum {x | x IN s /\ R x y} (\x. f x y))
Warning: inventing type variables
val ( CARD_EQ_SUM ) : thm = |- !s. FINITE s ==> &(CARD s) = sum s (\x. &1)
val ( SUM_MULTICOUNT_GEN ) : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k j)
         ==> sum s (\i. &(CARD {j | j IN t /\ R i j})) = sum t (\i. &(k i))
val ( SUM_MULTICOUNT ) : thm =
  |- !R s t k.
         FINITE s /\
         FINITE t /\
         (!j. j IN t ==> CARD {i | i IN s /\ R i j} = k)
         ==> sum s (\i. &(CARD {j | j IN t /\ R i j})) = &(k * CARD t)
0..0..1..3..solved at 8
0..0..0..solved at 3
0..0..solved at 2
val ( SUM_IMAGE_GEN ) : thm =
  |- !f g s.
         FINITE s
         ==> sum s g = sum (IMAGE f s) (\y. sum {x | x IN s /\ f x = y} g)
0..0..1..solved at 5
val ( SUM_GROUP ) : thm =
  |- !f g s t.
         FINITE s /\ IMAGE f s SUBSET t
         ==> sum t (\y. sum {x | x IN s /\ f x = y} g) = sum s g
Warning: inventing type variables
val ( REAL_OF_NUM_SUM ) : thm =
  |- !f s. FINITE s ==> &(nsum s f) = sum s (\x. &(f x))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( SUM_SUBSET ) : thm =
  |- !u v f.
         FINITE u /\
         FINITE v /\
         (!x. x IN u DIFF v ==> f x <= &0) /\
         (!x. x IN v DIFF u ==> &0 <= f x)
         ==> sum u f <= sum v f
0..0..1..3..solved at 7
0..0..solved at 2
0..0..1..4..10..25..solved at 41
0..0..1..solved at 4
val ( SUM_SUBSET_SIMPLE ) : thm =
  |- !u v f.
         FINITE v /\ u SUBSET v /\ (!x. x IN v DIFF u ==> &0 <= f x)
         ==> sum u f <= sum v f
val ( SUM_IMAGE_NONZERO ) : thm =
  |- !d i s.
         FINITE s /\
         (!x y. x IN s /\ y IN s /\ ~(x = y) /\ i x = i y ==> d (i x) = &0)
         ==> sum (IMAGE i s) d = sum s (d o i)
val ( SUM_BIJECTION ) : thm =
  |- !f p s.
         (!x. x IN s ==> p x IN s) /\
         (!y. y IN s ==> (?!x. x IN s /\ p x = y))
         ==> sum s f = sum s (f o p)
val ( SUM_SUM_PRODUCT ) : thm =
  |- !s t x.
         FINITE s /\ (!i. i IN s ==> FINITE (t i))
         ==> sum s (\i. sum (t i) (x i)) =
             sum {i,j | i IN s /\ j IN t i} (\(i,j). x i j)
val ( SUM_EQ_GENERAL ) : thm =
  |- !s t f g h.
         (!y. y IN t ==> (?!x. x IN s /\ h x = y)) /\
         (!x. x IN s ==> h x IN t /\ g (h x) = f x)
         ==> sum s f = sum t g
val ( SUM_EQ_GENERAL_INVERSES ) : thm =
  |- !s t f g h k.
         (!y. y IN t ==> k y IN s /\ h (k y) = y) /\
         (!x. x IN s ==> h x IN t /\ k (h x) = x /\ g (h x) = f x)
         ==> sum s f = sum t g
Warning: inventing type variables
val ( SUM_INJECTION ) : thm =
  |- !f p s.
         FINITE s /\
         (!x. x IN s ==> p x IN s) /\
         (!x y. x IN s /\ y IN s /\ p x = p y ==> x = y)
         ==> sum s (f o p) = sum s f
Warning: inventing type variables
val ( SUM_UNION_NONZERO ) : thm =
  |- !f s t.
         FINITE s /\ FINITE t /\ (!x. x IN s INTER t ==> f x = &0)
         ==> sum (s UNION t) f = sum s f + sum t f
0..0..2..4..10..18..30..solved at 46
0..0..2..4..8..16..28..59..103..173..solved at 214
val ( SUM_UNIONS_NONZERO ) : thm =
  |- !f s.
         FINITE s /\
         (!t. t IN s ==> FINITE t) /\
         (!t1 t2 x.
              t1 IN s /\ t2 IN s /\ ~(t1 = t2) /\ x IN t1 /\ x IN t2
              ==> f x = &0)
         ==> sum (UNIONS s) f = sum s (\t. sum t f)
val ( SUM_CASES ) : thm =
  |- !s P f g.
         FINITE s
         ==> sum s (\x. if P x then f x else g x) =
             sum {x | x IN s /\ P x} f + sum {x | x IN s /\ ~P x} g
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
val ( SUM_CASES_1 ) : thm =
  |- !s a.
         FINITE s /\ a IN s
         ==> sum s (\x. if x = a then y else f x) = sum s f + y - f a
0..0..solved at 2
0..0..solved at 2
0..0..2..solved at 6
0..0..0..1..2..3..8..solved at 16
val ( SUM_LE_INCLUDED ) : thm =
  |- !f g s t i.
         FINITE s /\
         FINITE t /\
         (!y. y IN t ==> &0 <= g y) /\
         (!x. x IN s ==> (?y. y IN t /\ i y = x /\ f x <= g y))
         ==> sum s f <= sum t g
0..0..0..0..solved at 4
val ( SUM_IMAGE_LE ) : thm =
  |- !f g s.
         FINITE s /\ (!x. x IN s ==> &0 <= g (f x))
         ==> sum (IMAGE f s) g <= sum s (g o f)
val ( SUM_CLOSED ) : thm =
  |- !P f s.
         P (&0) /\
         (!x y. P x /\ P y ==> P (x + y)) /\
         (!a. a IN s ==> P (f a))
         ==> P (sum s f)
val ( SUM_ADD_NUMSEG ) : thm =
  |- !f g m n. sum (m..n) (\i. f i + g i) = sum (m..n) f + sum (m..n) g
val ( SUM_SUB_NUMSEG ) : thm =
  |- !f g m n. sum (m..n) (\i. f i - g i) = sum (m..n) f - sum (m..n) g
val ( SUM_LE_NUMSEG ) : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i <= g i)
         ==> sum (m..n) f <= sum (m..n) g
0..0..1..4..13..29..64..122..204..solved at 247
val ( SUM_EQ_NUMSEG ) : thm =
  |- !f g m n.
         (!i. m <= i /\ i <= n ==> f i = g i) ==> sum (m..n) f = sum (m..n) g
val ( SUM_ABS_NUMSEG ) : thm =
  |- !f m n. abs (sum (m..n) f) <= sum (m..n) (\i. abs (f i))
val ( SUM_CONST_NUMSEG ) : thm =
  |- !c m n. sum (m..n) (\n. c) = &((n + 1) - m) * c
Warning: inventing type variables
val ( SUM_EQ_0_NUMSEG ) : thm =
  |- !f s. (!i. m <= i /\ i <= n ==> f i = &0) ==> sum (m..n) f = &0
0..0..1..7..18..38..78..147..solved at 161
val ( SUM_TRIV_NUMSEG ) : thm = |- !f m n. n < m ==> sum (m..n) f = &0
val ( SUM_POS_LE_NUMSEG ) : thm =
  |- !m n f. (!p. m <= p /\ p <= n ==> &0 <= f p) ==> &0 <= sum (m..n) f
0..0..1..2..6..12..28..48..72..100..147..195..316..458..652..894..1207..1592..2128..2732..3491..4404..5471..6812..8440..10222..12256..14610..17294..solved at 19757
val ( SUM_POS_EQ_0_NUMSEG ) : thm =
  |- !f m n.
         (!p. m <= p /\ p <= n ==> &0 <= f p) /\ sum (m..n) f = &0
         ==> (!p. m <= p /\ p <= n ==> f p = &0)
val ( SUM_SING_NUMSEG ) : thm = |- !f n. sum (n..n) f = f n
val ( SUM_CLAUSES_NUMSEG ) : thm =
  |- (!m. sum (m..0) f = (if m = 0 then f 0 else &0)) /\
     (!m n.
          sum (m..SUC n) f =
          (if m <= SUC n then sum (m..n) f + f (SUC n) else sum (m..n) f))
val ( SUM_SWAP_NUMSEG ) : thm =
  |- !a b c d f.
         sum (a..b) (\i. sum (c..d) (f i)) =
         sum (c..d) (\j. sum (a..b) (\i. f i j))
val ( SUM_ADD_SPLIT ) : thm =
  |- !f m n p.
         m <= n + 1
         ==> sum (m..n + p) f = sum (m..n) f + sum (n + 1..n + p) f
val ( SUM_OFFSET ) : thm =
  |- !p f m n. sum (m + p..n + p) f = sum (m..n) (\i. f (i + p))
val ( SUM_OFFSET_0 ) : thm =
  |- !f m n. m <= n ==> sum (m..n) f = sum (0..n - m) (\i. f (i + m))
val ( SUM_CLAUSES_LEFT ) : thm =
  |- !f m n. m <= n ==> sum (m..n) f = f m + sum (m + 1..n) f
val ( SUM_CLAUSES_RIGHT ) : thm =
  |- !f m n. 0 < n /\ m <= n ==> sum (m..n) f = sum (m..n - 1) f + f n
val ( SUM_PAIR ) : thm =
  |- !f m n.
         sum (2 * m..2 * n + 1) f =
         sum (m..n) (\i. f (2 * i) + f (2 * i + 1))
val ( REAL_OF_NUM_SUM_NUMSEG ) : thm =
  |- !f m n. &(nsum (m..n) f) = sum (m..n) (\i. &(f i))
val ( SUM_PARTIAL_SUC ) : thm =
  |- !f g m n.
         sum (m..n) (\k. f k * (g (k + 1) - g k)) =
         (if m <= n
          then f (n + 1) * g (n + 1) -
               f m * g m -
               sum (m..n) (\k. g (k + 1) * (f (k + 1) - f k))
          else &0)
val ( SUM_PARTIAL_PRE ) : thm =
  |- !f g m n.
         sum (m..n) (\k. f k * (g k - g (k - 1))) =
         (if m <= n
          then f (n + 1) * g n -
               f m * g (m - 1) -
               sum (m..n) (\k. g k * (f (k + 1) - f k))
          else &0)
val ( SUM_DIFFS ) : thm =
  |- !m n.
         sum (m..n) (\k. f k - f (k + 1)) =
         (if m <= n then f m - f (n + 1) else &0)
val ( SUM_DIFFS_ALT ) : thm =
  |- !m n.
         sum (m..n) (\k. f (k + 1) - f k) =
         (if m <= n then f (n + 1) - f m else &0)
val ( SUM_COMBINE_R ) : thm =
  |- !f m n p.
         m <= n + 1 /\ n <= p
         ==> sum (m..n) f + sum (n + 1..p) f = sum (m..p) f
val ( SUM_COMBINE_L ) : thm =
  |- !f m n p.
         0 < n /\ m <= n /\ n <= p + 1
         ==> sum (m..n - 1) f + sum (n..p) f = sum (m..p) f
Warning: inventing type variables
- : unit = ()
val ( REAL_SUB_POW ) : thm =
  |- !x y n.
         1 <= n
         ==> x pow n - y pow n =
             (x - y) * sum (0..n - 1) (\i. x pow i * y pow (n - 1 - i))
val ( REAL_SUB_POW_R1 ) : thm =
  |- !x n. 1 <= n ==> x pow n - &1 = (x - &1) * sum (0..n - 1) (\i. x pow i)
val ( REAL_SUB_POW_L1 ) : thm =
  |- !x n. 1 <= n ==> &1 - x pow n = (&1 - x) * sum (0..n - 1) (\i. x pow i)
- : unit = ()
- : unit = ()
val dimindex : thm =
  |- !s. dimindex s = (if FINITE (:A) then CARD (:A) else 1)
val ( DIMINDEX_NONZERO ) : thm = |- !s. ~(dimindex s = 0)
val ( DIMINDEX_GE_1 ) : thm = |- !s. 1 <= dimindex s
val ( DIMINDEX_UNIV ) : thm = |- !s. dimindex s = dimindex (:A)
0..0..1..2..5..9..15..solved at 32
0..0..2..solved at 6
val ( DIMINDEX_UNIQUE ) : thm = |- (:A) HAS_SIZE n ==> dimindex (:A) = n
val finite_image_tybij : thm =
  |- (!a. finite_index (dest_finite_image a) = a) /\
     (!r. r IN 1..dimindex (:A) <=> dest_finite_image (finite_index r) = r)
0..0..0..1..2..3..5..7..9..solved at 16
val ( FINITE_IMAGE_IMAGE ) : thm =
  |- (:(A)finite_image) = IMAGE finite_index (1..dimindex (:A))
0..0..1..2..5..9..15..30..47..76..solved at 127
val ( HAS_SIZE_FINITE_IMAGE ) : thm =
  |- !s. (:(A)finite_image) HAS_SIZE dimindex s
0..0..1..solved at 4
val ( CARD_FINITE_IMAGE ) : thm = |- !s. CARD (:(A)finite_image) = dimindex s
0..0..1..solved at 4
val ( FINITE_FINITE_IMAGE ) : thm = |- FINITE (:(A)finite_image)
val ( DIMINDEX_FINITE_IMAGE ) : thm = |- !s t. dimindex s = dimindex t
0..0..0..1..4..solved at 9
0..0..1..2..5..9..15..30..47..76..solved at 124
val ( FINITE_INDEX_WORKS ) : thm =
  |- !i. ?!n. 1 <= n /\ n <= dimindex (:A) /\ finite_index n = i
0..0..1..2..5..9..15..22..solved at 36
0..0..solved at 2
val ( FINITE_INDEX_INJ ) : thm =
  |- !i j.
         1 <= i /\ i <= dimindex (:A) /\ 1 <= j /\ j <= dimindex (:A)
         ==> (finite_index i = finite_index j <=> i = j)
0..0..solved at 2
0..0..1..2..6..10..solved at 16
val ( FORALL_FINITE_INDEX ) : thm =
  |- (!k. P k) <=> (!i. 1 <= i /\ i <= dimindex (:N) ==> P (finite_index i))
val cart_tybij : thm =
  |- (!a. mk_cart (dest_cart a) = a) /\ (!r. T <=> dest_cart (mk_cart r) = r)
- : unit = ()
Warning: inventing type variables
val finite_index : thm = |- !x i. x$i = dest_cart x (finite_index i)
0..0..solved at 2
0..0..1..2..6..12..27..solved at 44
val ( CART_EQ ) : thm =
  |- !x y. x = y <=> (!i. 1 <= i /\ i <= dimindex (:B) ==> x$i = y$i)
- : unit = ()
val lambda : thm =
  |- !g. (lambda) g = (@f. !i. 1 <= i /\ i <= dimindex (:B) ==> f$i = g i)
0..0..1..2..5..9..15..solved at 30
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
val ( LAMBDA_BETA ) : thm =
  |- !i. 1 <= i /\ i <= dimindex (:B) ==> (lambda) g$i = g i
0..0..1..2..5..9..solved at 16
0..0..1..2..5..9..solved at 16
val ( LAMBDA_UNIQUE ) : thm =
  |- !f g.
         (!i. 1 <= i /\ i <= dimindex (:B) ==> f$i = g i) <=> (lambda) g = f
Warning: inventing type variables
val ( LAMBDA_ETA ) : thm = |- !g. (lambda i. g$i) = g
0..0..0..0..4..9..18..30..solved at 42
val ( FINITE_INDEX_INRANGE ) : thm =
  |- !i. ?k. 1 <= k /\ k <= dimindex (:N) /\ (!x. x$i = x$k)
val ( CART_EQ_FULL ) : thm = |- !x y. x = y <=> (!i. x$i = y$i)
val finite_sum_tybij : thm =
  |- (!a. mk_finite_sum (dest_finite_sum a) = a) /\
     (!r. r IN 1..dimindex (:A) + dimindex (:B) <=>
          dest_finite_sum (mk_finite_sum r) = r)
val pastecart : thm =
  |- !f g.
         pastecart f g =
         (lambda i. if i <= dimindex (:M) then f$i else g$(i - dimindex (:M)))
val fstcart : thm = |- !f. fstcart f = (lambda i. f$i)
val sndcart : thm = |- !f. sndcart f = (lambda i. f$(i + dimindex (:M)))
0..0..0..1..2..3..5..7..9..solved at 16
val ( FINITE_SUM_IMAGE ) : thm =
  |- (:(A,B)finite_sum) =
     IMAGE mk_finite_sum (1..dimindex (:A) + dimindex (:B))
0..0..1..2..5..9..15..40..67..116..solved at 201
val ( DIMINDEX_HAS_SIZE_FINITE_SUM ) : thm =
  |- (:(M,N)finite_sum) HAS_SIZE dimindex (:M) + dimindex (:N)
val ( DIMINDEX_FINITE_SUM ) : thm =
  |- dimindex (:(M,N)finite_sum) = dimindex (:M) + dimindex (:N)
val ( FSTCART_PASTECART ) : thm = |- !x y. fstcart (pastecart x y) = x
val ( SNDCART_PASTECART ) : thm = |- !x y. sndcart (pastecart x y) = y
Warning: inventing type variables
val ( PASTECART_FST_SND ) : thm =
  |- !z. pastecart (fstcart z) (sndcart z) = z
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..1..2..6..12..27..48..solved at 81
val ( PASTECART_EQ ) : thm =
  |- !x y. x = y <=> fstcart x = fstcart y /\ sndcart x = sndcart y
Warning: inventing type variables
0..0..solved at 2
0..0..1..2..solved at 6
val ( FORALL_PASTECART ) : thm = |- (!p. P p) <=> (!x y. P (pastecart x y))
Warning: inventing type variables
0..0..1..2..8..15..solved at 40
0..0..solved at 2
val ( EXISTS_PASTECART ) : thm = |- (?p. P p) <=> (?x y. P (pastecart x y))
0..0..0..1..2..3..5..7..9..solved at 16
0..0..1..2..5..9..15..30..47..76..solved at 124
0..0..solved at 2
val define_finite_type : int -> thm = <fun>
val ( HAS_SIZE_1 ) : thm = |- (:1) HAS_SIZE 1
val ( HAS_SIZE_2 ) : thm = |- (:2) HAS_SIZE 2
val ( HAS_SIZE_3 ) : thm = |- (:3) HAS_SIZE 3
val ( DIMINDEX_1 ) : thm = |- dimindex (:1) = 1
val ( DIMINDEX_2 ) : thm = |- dimindex (:2) = 2
val ( DIMINDEX_3 ) : thm = |- dimindex (:3) = 3
0..0..solved at 3
0..0..solved at 2
0..0..2..4..7..19..solved at 33
0..0..1..2..3..10..solved at 17
0..0..2..4..7..19..solved at 33
0..0..1..2..3..10..solved at 16
0..0..3..6..17..36..64..solved at 95
0..0..2..4..13..27..47..solved at 60
val ( FINITE_CART ) : thm =
  |- !P. (!i. 1 <= i /\ i <= dimindex (:N) ==> FINITE {x | P i x})
         ==> FINITE {v | !i. 1 <= i /\ i <= dimindex (:N) ==> P i (v$i)}
val vector : thm = |- !l. vector l = (lambda i. EL (i - 1) l)
- : unit = ()
Warning: inventing type variables
val ( CASEWISE_DEF ) : thm =
  |- CASEWISE [] f x = (@y. T) /\
     CASEWISE (CONS h t) f x =
     (if ?y. FST h y = x then SND h f (@y. FST h y = x) else CASEWISE t f x)
Warning: inventing type variables
val ( CASEWISE ) : thm =
  |- CASEWISE [] f x = (@y. T) /\
     CASEWISE (CONS (s,t) clauses) f x =
     (if ?y. s y = x then t f (@y. s y = x) else CASEWISE clauses f x)
Warning: inventing type variables
0..0..0..0..1..9..solved at 20
0..0..0..0..3..12..solved at 27
0..0..1..2..6..16..solved at 31
0..0..solved at 2
0..0..1..2..10..23..45..73..109..150..237..341..solved at 482
0..0..2..7..17..57..111..252..solved at 259
val ( CASEWISE_CASES ) : thm =
  |- !clauses c x.
         (?s t a.
              MEM (s,t) clauses /\ s a = x /\ CASEWISE clauses c x = t c a) \/
         ~(?s t a. MEM (s,t) clauses /\ s a = x) /\
         CASEWISE clauses c x = (@y. T)
0..0..1..2..5..9..15..24..33..44..67..90..125..186..247..334..524..solved at 604
val ( CASEWISE_WORKS ) : thm =
  |- !clauses c.
         (!s t s' t' x y.
              MEM (s,t) clauses /\ MEM (s',t') clauses /\ s x = s' y
              ==> t c x = t' c y)
         ==> ALL (\(s,t). !x. CASEWISE clauses c (s x) = t c x) clauses
Warning: inventing type variables
val admissible : thm =
  |- !p (<<) s t.
         admissible (<<) p s t <=>
         (!f g a.
              p f a /\ p g a /\ (!z. z << s a ==> f z = g z)
              ==> t f a = t g a)
val tailadmissible : thm =
  |- !(<<) s p t.
         tailadmissible (<<) p s t <=>
         (?P G H.
              (!f a y. P f a /\ y << G f a ==> y << s a) /\
              (!f g a.
                   (!z. z << s a ==> f z = g z)
                   ==> (P f a <=> P g a) /\ G f a = G g a /\ H f a = H g a) /\
              (!f a. p f a ==> t f a = (if P f a then f (G f a) else H f a)))
Warning: inventing type variables
val superadmissible : thm =
  |- !(<<) p s t.
         superadmissible (<<) p s t <=>
         admissible (<<) (\f a. T) s p ==> tailadmissible (<<) p s t
Warning: inventing type variables
0..0..solved at 3
0..0..solved at 3
0..0..solved at 4
0..0..solved at 5
val ( MATCH_SEQPATTERN ) : thm =
  |- _MATCH x (_SEQPATTERN r s) =
     (if ?y. r x y then _MATCH x r else _MATCH x s)
Warning: inventing type variables
val ( ADMISSIBLE_CONST ) : thm = |- !p s c. admissible (<<) p s (\f. c)
0..0..1..3..solved at 7
val ( ADMISSIBLE_BASE ) : thm =
  |- !(<<) p s t.
         (!f a. p f a ==> t a << s a) ==> admissible (<<) p s (\f x. f (t x))
0..0..1..2..6..11..19..28..37..46..73..100..145..212..279..368..509..650..841..1124..1407..1782..2305..2828..3499..solved at 4403
val ( ADMISSIBLE_COMB ) : thm =
  |- !(<<) p s g y.
         admissible (<<) p s g /\ admissible (<<) p s y
         ==> admissible (<<) p s (\f x. g f x (y f x))
0..0..1..2..6..12..25..47..84..141..245..solved at 353
val ( ADMISSIBLE_RAND ) : thm =
  |- !(<<) p s g y.
         admissible (<<) p s y ==> admissible (<<) p s (\f x. g x (y f x))
0..0..1..2..3..7..35..80..139..252..387..solved at 519
0..0..1..2..3..7..35..80..139..252..387..solved at 463
val ( ADMISSIBLE_LAMBDA ) : thm =
  |- !(<<) p s t.
         admissible (<<) (\f (u,x). p f x) (\(u,x). s x) (\f (u,x). t f u x)
         ==> admissible (<<) p s (\f x u. t f u x)
0..0..1..2..6..11..19..29..39..50..91..141..235..375..577..845..1399..solved at 1533
val ( ADMISSIBLE_NEST ) : thm =
  |- !(<<) p s t.
         admissible (<<) p s t /\ (!f a. p f a ==> t f a << s a)
         ==> admissible (<<) p s (\f x. f (t f x))
Warning: inventing type variables
val ( ADMISSIBLE_COND ) : thm =
  |- !(<<) p P s h k.
         admissible (<<) p s P /\
         admissible (<<) (\f x. p f x /\ P f x) s h /\
         admissible (<<) (\f x. p f x /\ ~P f x) s k
         ==> admissible (<<) p s (\f x. if P f x then h f x else k f x)
Warning: inventing type variables
0..0..1..2..6..12..24..45..76..125..208..solved at 288
0..0..2..4..8..16..28..44..69..101..151..223..solved at 286
0..0..2..4..8..16..28..44..69..100..149..220..309..441..solved at 521
0..0..solved at 2
val ( ADMISSIBLE_MATCH ) : thm =
  |- !(<<) p s e f c.
         admissible (<<) p s e /\ admissible (<<) p s (\f x. c f x (e f x))
         ==> admissible (<<) p s (\f x. _MATCH (e f x) (c f x))
Warning: inventing type variables
0..0..1..2..6..11..19..38..65..106..192..292..436..solved at 553
0..0..2..4..9..18..52..121..210..359..620..solved at 701
0..0..2..4..9..18..52..121..210..359..620..solved at 878
0..0..3..6..12..25..83..212..381..638..1118..1786..2598..solved at 2715
val ( ADMISSIBLE_SEQPATTERN ) : thm =
  |- !(<<) p s c1 c2 e.
         admissible (<<) p s (\f x. ?y. c1 f x (e f x) y) /\
         admissible (<<) (\f x. p f x /\ (?y. c1 f x (e f x) y)) s
         (\f x. c1 f x (e f x)) /\
         admissible (<<) (\f x. p f x /\ ~(?y. c1 f x (e f x) y)) s
         (\f x. c2 f x (e f x))
         ==> admissible (<<) p s
             (\f x. _SEQPATTERN (c1 f x) (c2 f x) (e f x))
Warning: inventing type variables
0..0..1..2..7..13..27..43..69..98..153..212..305..432..589..787..1065..1365..1753..2218..2731..3327..4085..4879..5831..solved at 6125
0..0..1..2..7..13..27..43..69..98..153..212..305..432..589..787..1063..1361..1745..2206..2715..3307..4060..4849..5795..6839..7919..9094..10526..11984..13723..solved at 14089
0..0..1..2..7..13..27..43..69..98..153..212..305..410..545..699..915..1153..1461..1852..2291..2819..3481..4179..5007..5941..6911..7984..9353..10748..12463..14302..16229..18272..20734..23204..26101..solved at 26928
0..0..1..2..7..13..27..43..69..98..153..212..305..410..545..699..915..1153..1461..1852..2291..2819..3479..4175..4999..5929..6895..7964..9326..10714..12419..14242..16153..18174..20613..23060..25933..29025..32229..35676..39609..43606..48073..solved at 49267
val ( ADMISSIBLE_UNGUARDED_PATTERN ) : thm =
  |- !(<<) p s pat e t y.
         admissible (<<) p s pat /\
         admissible (<<) p s e /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x) s t /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x) s y
         ==> admissible (<<) p s
             (\f x.
                  _UNGUARDED_PATTERN (GEQ (pat f x) (e f x))
                  (GEQ (t f x) (y f x)))
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..1..2..7..19..42..78..137..solved at 187
0..0..1..2..7..19..42..78..137..solved at 187
0..0..1..2..3..7..15..33..92..182..286..491..717..1000..1344..solved at 1660
0..0..1..2..3..7..15..33..92..182..286..491..717..1000..1344..solved at 1547
0..0..1..2..7..13..26..42..66..109..184..282..450..645..906..1214..1585..solved at 1922
0..0..1..2..7..13..26..42..66..109..184..282..450..645..906..1214..1585..solved at 1922
val ( ADMISSIBLE_GUARDED_PATTERN ) : thm =
  |- !(<<) p s pat q e t y.
         admissible (<<) p s pat /\
         admissible (<<) p s e /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x /\ q f x) s t /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x) s q /\
         admissible (<<) (\f x. p f x /\ pat f x = e f x /\ q f x) s y
         ==> admissible (<<) p s
             (\f x.
                  _GUARDED_PATTERN (GEQ (pat f x) (e f x)) (q f x)
                  (GEQ (t f x) (y f x)))
0..0..1..2..6..12..25..41..68..113..197..307..500..726..1041..1410..1881..solved at 2329
val ( ADMISSIBLE_NSUM ) : thm =
  |- !(<<) p s h a b.
         admissible (<<) (\f (k,x). a x <= k /\ k <= b x /\ p f x)
         (\(k,x). s x)
         (\f (k,x). h f x k)
         ==> admissible (<<) p s (\f x. nsum (a x..b x) (h f x))
0..0..1..2..6..12..25..41..68..113..197..307..500..726..1041..1410..1881..solved at 2329
val ( ADMISSIBLE_SUM ) : thm =
  |- !(<<) p s h a b.
         admissible (<<) (\f (k,x). a x <= k /\ k <= b x /\ p f x)
         (\(k,x). s x)
         (\f (k,x). h f x k)
         ==> admissible (<<) p s (\f x. sum (a x..b x) (h f x))
Warning: inventing type variables
0..0..solved at 2
Warning: inventing type variables
0..0..1..2..7..19..42..78..137..solved at 187
0..0..1..2..3..7..13..23..41..70..112..191..solved at 250
val ( ADMISSIBLE_MAP ) : thm =
  |- !(<<) p s h l.
         admissible (<<) p s l /\
         admissible (<<) (\f (y,x). p f x /\ MEM y (l f x)) (\(y,x). s x)
         (\f (y,x). h f x y)
         ==> admissible (<<) p s (\f x. MAP (h f x) (l f x))
Warning: inventing type variables
val ( ADMISSIBLE_MATCH_SEQPATTERN ) : thm =
  |- !(<<) p s c1 c2 e.
         admissible (<<) p s (\f x. ?y. c1 f x (e f x) y) /\
         admissible (<<) (\f x. p f x /\ (?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c1 f x)) /\
         admissible (<<) (\f x. p f x /\ ~(?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c2 f x))
         ==> admissible (<<) p s
             (\f x. _MATCH (e f x) (_SEQPATTERN (c1 f x) (c2 f x)))
0..0..1..2..7..19..42..78..137..solved at 187
0..0..2..4..14..35..68..solved at 84
0..0..2..4..14..35..68..solved at 104
val ( ADMISSIBLE_IMP_SUPERADMISSIBLE ) : thm =
  |- !(<<) p s t. admissible (<<) p s t ==> superadmissible (<<) p s t
Warning: inventing type variables
val ( SUPERADMISSIBLE_CONST ) : thm =
  |- !p s c. superadmissible (<<) p s (\f. c)
0..0..1..2..solved at 6
0..0..1..2..7..19..42..78..140..solved at 193
0..0..2..4..16..39..78..solved at 101
0..0..2..4..16..39..78..solved at 121
val ( SUPERADMISSIBLE_TAIL ) : thm =
  |- !(<<) p s t.
         admissible (<<) p s t /\
         (!f a. p f a ==> (!y. y << t f a ==> y << s a))
         ==> superadmissible (<<) p s (\f x. f (t f x))
0..0..2..4..12..33..80..solved at 109
0..0..1..2..3..7..28..58..93..156..224..320..452..612..798..1098..1416..1822..2337..2900..3583..solved at 4191
0..0..2..4..12..33..80..solved at 89
0..0..1..2..3..7..28..58..93..156..224..320..452..612..798..1098..1416..1822..2337..2900..3583..solved at 4521
0..0..1..2..9..26..54..solved at 83
0..0..1..2..3..7..20..41..67..110..157..227..331..463..620..867..1133..1468..1887..2352..2941..solved at 3821
0..0..1..2..9..26..54..solved at 63
0..0..1..2..3..7..20..41..67..110..157..227..331..463..620..867..1133..1468..1887..2352..2941..solved at 3463
0..0..1..2..solved at 6
0..0..2..4..solved at 9
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
0..0..solved at 4
0..0..solved at 3
0..0..solved at 2
0..0..solved at 2
0..0..solved at 6
0..0..solved at 5
0..0..solved at 2
0..0..solved at 2
val ( SUPERADMISSIBLE_COND ) : thm =
  |- !(<<) p P s h k.
         admissible (<<) p s P /\
         superadmissible (<<) (\f x. p f x /\ P f x) s h /\
         superadmissible (<<) (\f x. p f x /\ ~P f x) s k
         ==> superadmissible (<<) p s (\f x. if P f x then h f x else k f x)
Warning: inventing type variables
val ( SUPERADMISSIBLE_MATCH_SEQPATTERN ) : thm =
  |- !(<<) p s c1 c2 e.
         admissible (<<) p s (\f x. ?y. c1 f x (e f x) y) /\
         superadmissible (<<) (\f x. p f x /\ (?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c1 f x)) /\
         superadmissible (<<) (\f x. p f x /\ ~(?y. c1 f x (e f x) y)) s
         (\f x. _MATCH (e f x) (c2 f x))
         ==> superadmissible (<<) p s
             (\f x. _MATCH (e f x) (_SEQPATTERN (c1 f x) (c2 f x)))
0..0..solved at 2
0..0..0..solved at 3
0..0..1..2..6..12..25..solved at 45
0..0..1..2..3..10..solved at 17
0..0..1..2..9..26..53..solved at 82
0..0..solved at 2
0..0..1..2..9..26..53..solved at 62
0..0..solved at 2
0..0..1..2..5..9..15..22..29..36..67..104..175..273..solved at 350
val ( SUPERADMISSIBLE_MATCH_UNGUARDED_PATTERN ) : thm =
  |- !(<<) p s e pat arg.
         (!f a t u.
              p f a /\ pat t = e a /\ pat u = e a ==> arg a t = arg a u) /\
         (!f a t. p f a /\ pat t = e a ==> (!y. y << arg a t ==> y << s a))
         ==> superadmissible (<<) p s
             (\f x. match e x with pat t -> f (arg x t))
0..0..0..solved at 3
0..0..0..0..solved at 4
0..0..1..2..6..12..25..41..67..solved at 102
0..0..1..2..3..7..17..30..46..70..97..140..solved at 190
0..0..1..2..9..26..53..solved at 82
0..0..0..solved at 3
0..0..1..2..9..26..53..solved at 62
0..0..0..solved at 3
0..0..1..2..5..9..15..22..29..36..53..70..97..161..232..370..554..815..1134..1579..2071..2741..3531..4571..5783..7374..solved at 8357
val ( SUPERADMISSIBLE_MATCH_GUARDED_PATTERN ) : thm =
  |- !(<<) p s e pat q arg.
         (!f a t u.
              p f a /\ pat t = e a /\ q a t /\ pat u = e a /\ q a u
              ==> arg a t = arg a u) /\
         (!f a t.
              p f a /\ q a t /\ pat t = e a
              ==> (!y. y << arg a t ==> y << s a))
         ==> superadmissible (<<) p s
             (\f x. match e x with pat t when q x t -> f (arg x t))
Warning: inventing type variables
0..0..solved at 2
0..0..1..3..11..33..69..solved at 111
0..0..1..3..11..33..69..solved at 89
0..0..1..4..13..solved at 18
0..0..1..4..13..solved at 19
0..0..1..4..13..solved at 19
0..0..1..2..solved at 6
val ( WF_REC_TAIL_GENERAL' ) : thm =
  |- !P G H H'.
         WF (<<) /\
         (!f g x.
              (!z. z << x ==> f z = g z)
              ==> (P f x <=> P g x) /\ G f x = G g x /\ H' f x = H' g x) /\
         (!f x y. P f x /\ y << G f x ==> y << x) /\
         (!f x. H f x = (if P f x then f (G f x) else H' f x))
         ==> (?f. !x. f x = H f x)
0..0..1..3..11..31..61..114..201..302..473..solved at 633
0..0..1..3..11..31..61..114..201..302..473..solved at 562
0..0..1..4..12..27..55..116..196..solved at 236
0..0..1..4..12..27..55..108..178..solved at 219
0..0..2..6..19..50..101..solved at 143
0..0..2..6..19..50..101..solved at 121
0..0..2..7..21..solved at 26
0..0..2..7..21..solved at 27
0..0..1..2..5..11..19..32..solved at 51
0..0..2..5..solved at 9
val ( WF_REC_CASES ) : thm =
  |- !(<<) clauses.
         WF (<<) /\
         ALL
         (\(s,t). ?P G H.
                      (!f a y. P f a /\ y << G f a ==> y << s a) /\
                      (!f g a.
                           (!z. z << s a ==> f z = g z)
                           ==> (P f a <=> P g a) /\
                               G f a = G g a /\
                               H f a = H g a) /\
                      (!f a. t f a = (if P f a then f (G f a) else H f a)))
         clauses
         ==> (?f. !x. f x = CASEWISE clauses f x)
Warning: inventing type variables
val ( WF_REC_CASES' ) : thm =
  |- !(<<) clauses.
         WF (<<) /\ ALL (\(s,t). tailadmissible (<<) (\f a. T) s t) clauses
         ==> (?f. !x. f x = CASEWISE clauses f x)
0..0..1..6..11..28..59..115..212..391..solved at 471
val ( RECURSION_CASEWISE ) : thm =
  |- !clauses. (?(<<). WF (<<) /\
                       ALL (\(s,t). tailadmissible (<<) (\f a. T) s t)
                       clauses) /\
               (!s t s' t' f x y.
                    MEM (s,t) clauses /\ MEM (s',t') clauses
                    ==> s x = s' y
                    ==> t f x = t' f y)
               ==> (?f. ALL (\(s,t). !x. f (s x) = t f x) clauses)
Warning: inventing type variables
0..0..1..3..solved at 9
0..0..1..solved at 4
0..0..1..3..solved at 12
0..0..solved at 2
0..0..1..solved at 5
0..0..1..3..solved at 7
0..0..1..solved at 4
0..0..1..3..solved at 8
0..0..3..7..solved at 12
0..0..3..7..solved at 14
0..0..3..8..solved at 17
0..0..3..7..solved at 15
0..0..3..solved at 7
0..0..3..solved at 8
0..0..3..solved at 6
0..0..3..solved at 8
0..0..3..7..solved at 12
0..0..3..7..solved at 14
0..0..3..8..solved at 17
0..0..2..5..solved at 14
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
0..0..solved at 3
Warning: inventing type variables
Warning: inventing type variables
0..0..1..2..5..10..17..solved at 26
Warning: inventing type variables
val ( RECURSION_CASEWISE_PAIRWISE ) : thm =
  |- !clauses. (?(<<). WF (<<) /\
                       ALL (\(s,t). tailadmissible (<<) (\f a. T) s t)
                       clauses) /\
               ALL (\(s,t). !f x y. s x = s y ==> t f x = t f y) clauses /\
               PAIRWISE
               (\(s,t) (s',t'). !f x y. s x = s' y ==> t f x = t' f y)
               clauses
               ==> (?f. ALL (\(s,t). !x. f (s x) = t f x) clauses)
Warning: inventing type variables
val ( SUPERADMISSIBLE_T ) : thm =
  |- superadmissible (<<) (\f x. T) s t <=> tailadmissible (<<) (\f x. T) s t
val ( RECURSION_SUPERADMISSIBLE ) : thm =
  |- !clauses. (?(<<). WF (<<) /\
                       ALL (\(s,t). superadmissible (<<) (\f a. T) s t)
                       clauses) /\
               ALL (\(s,t). !f x y. s x = s y ==> t f x = t f y) clauses /\
               PAIRWISE
               (\(s,t) (s',t'). !f x y. s x = s' y ==> t f x = t' f y)
               clauses
               ==> (?f. ALL (\(s,t). !x. f (s x) = t f x) clauses)
File "/home/student/OCaml/hol_light (gzip)/define.ml", line 929, characters 10-16:
Warning Y: unused variable and_tm.
File "/home/student/OCaml/hol_light (gzip)/define.ml", line 494, characters 8-29:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
File "/home/student/OCaml/hol_light (gzip)/define.ml", line 720, characters 8-95:
Warning P: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
0..0..solved at 2
0..0..solved at 2
Warning: inventing type variables
Warning: inventing type variables
0..0..0..solved at 3
val instantiate_casewise_recursion : term -> thm = <fun>
val pure_prove_recursive_function_exists : term -> thm = <fun>
val prove_general_recursive_function_exists : term -> thm = <fun>
val define : term -> thm = <fun>
- : unit = ()
val help_path : string list ref = {contents = ["$/Help"]}
val help : string -> unit = <fun>
val theorems : (string * thm) list ref = {contents = []}
val omit : term -> term = <fun>
val exactly : term -> term = <fun>
val name : string -> term = <fun>
val search : term list -> (string * thm) list = <fun>
- : unit = ()
- : unit = ()
- : unit = ()
	Camlp5 Parsing version 5.14

# 

